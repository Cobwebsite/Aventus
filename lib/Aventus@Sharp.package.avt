// AventusSharp@Main:1.0.6
// npm:@aventusjs/sharp
//#region js def //
declare global {

namespace AventusSharp{
namespace WebSocket {
interface WsRouterOptions {
    url: string;
}
}

namespace RAM {
type RamWebSocketListenOnStart = {
    GetAll: boolean;
    GetById: boolean;
    Create: boolean;
    CreateMany: boolean;
    Update: boolean;
    UpdateMany: boolean;
    Delete: boolean;
    DeleteMany: boolean;
};
}

namespace Data {
abstract class Storable extends Aventus.Data implements Aventus.IData {
    Id: number;
    /**
     * @inerhit
     */
    toJSON(): any;
}
}

namespace Data {
abstract class StorableTimestamp extends Data.Storable implements Aventus.IData {
    CreatedDate: Date;
    UpdatedDate: Date;
}
}

namespace WebSocket {
enum WsErrorCode {
    UnknowError = 0,
    CantDefineAssembly = 1,
    ConfigError = 2,
    MultipleMainEndpoint = 3,
    CantGetValueFromBody = 4,
    NoConnection = 5,
    NoEndPoint = 6,
    NoPath = 7
}
}

namespace WebSocket {
interface WsRouteSendOptions {
    uid?: string;
    timeout?: number;
}
}

namespace WebSocket {
interface SocketMessage {
    channel: string;
    data?: any;
    uid?: string;
}
}

namespace WebSocket {
enum SocketErrorCode {
    socketClosed = 0,
    timeout = 1,
    differentChannel = 2,
    unknow = 3
}
}

namespace WebSocket {
class Socket {
    static Debug: boolean;
    private static connections;
    static getInstance(url: string, el: any): WebSocket.Socket;
    private socket;
    private url;
    private elements;
    private reopenInterval;
    onOpen: Aventus.Callback<(ev: Event) => any>;
    onClose: Aventus.Callback<(ev: Event) => any>;
    onError: Aventus.Callback<(ev: Event) => any>;
    onMessage: Aventus.Callback<(ev: MessageEvent<any>) => any>;
    get readyState(): number;
    protected constructor(url: string, el: any);
    protected registerEl(el: any): void;
    private createWebSocket;
    protected removeSocket(): void;
    protected reopen(): void;
    close(el: any, code?: number | undefined, reason?: string | undefined): void;
    send(data: string | ArrayBufferLike | Blob | ArrayBufferView): void;
    /**
    * Check if socket is ready
    */
    isReady(): boolean;
}
}

namespace WebSocket {
interface SocketSendMessageOptions {
    channel: string;
    body?: {
        [key: string | number]: any;
    };
    timeout?: number;
    uid?: string;
}
}

namespace WebSocket {
interface SocketRoute<T = any> {
    channel: string;
    callback: (data: T, params: Aventus.UriParamsValue, uid?: string) => void;
}
}

namespace Routes {
enum RouteErrorCode {
    UnknowError = 0,
    FormContentTypeUnknown = 1,
    CantGetValueFromBody = 2,
    CantMoveFile = 3,
    CantCreateFolders = 4,
    RouteAlreadyExist = 5
}
}

namespace Data {
interface IStorableTimestamp extends Aventus.IData {
    CreatedDate: Date;
    UpdatedDate: Date;
}
}

namespace Tools {
interface IWithError<T extends Aventus.GenericError> {
}
}

namespace Tools {
interface IResultWithError<T extends Aventus.GenericError> extends Tools.IWithError<T> {
}
}

namespace Data {
enum DataErrorCode {
    DefaultDMGenericType = 0,
    DMOnlyForceInherit = 1,
    TypeNotStorable = 2,
    TypeTooMuchStorable = 3,
    GenericNotAbstract = 4,
    ParentNotAbstract = 5,
    InfiniteLoop = 6,
    InterfaceNotUnique = 7,
    SelfReferecingDependance = 8,
    DMNotExist = 9,
    DMAlreadyExist = 10,
    MethodNotFound = 11,
    StorageDisconnected = 12,
    StorageNotFound = 13,
    NoConnectionInsideStorage = 14,
    TypeNotExistInsideStorage = 15,
    UnknowError = 16,
    NoItemProvided = 17,
    NoTransactionInProgress = 18,
    WrongType = 19,
    NoTypeIdentifierFoundInsideQuery = 20,
    ItemNoExistInsideStorage = 21,
    ItemAlreadyExist = 22,
    ValidationError = 23,
    GetAllNotAllowed = 24,
    GetByIdNotAllowed = 25,
    GetByIdsNotAllowed = 26,
    WhereNotAllowed = 27,
    CreateNotAllowed = 28,
    UpdateNotAllowed = 29,
    DeleteNotAllowed = 30,
    NumberOfItemsNotMatching = 31,
    FieldTypeNotFound = 32,
    MemberNotFound = 33,
    TooMuchMemberFound = 34,
    TypeNotFound = 35,
    ReverseLinkNotExist = 36,
    ErrorCreatingReverseQuery = 37,
    LinkNotSet = 38
}
}

namespace Data {
abstract class SharpClass {
    /**
     * The current namespace
     */
    get namespace(): string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    get $type(): string;
    /**
     * Get the name of the class
     */
    get className(): string;
    /**
     * Clone the object by transforming a parsed JSON string back into the original type
     */
    clone(): this;
    /**
     * Get a JSON for the current object
     */
    toJSON(): any;
}
}

namespace Data {
@Convertible()
class FieldErrorInfo extends Data.SharpClass {
    static get Fullname(): string;
    Name: string;
}
}

namespace Data.CustomTableMembers {
abstract class AventusFile<T> {
    Uri: string;
    Upload?: File;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    get $type(): string;
    /**
     * @inerhit
     */
    toJSON(): any;
}
}

type RealDate = Date;

namespace Data {
@Convertible()
class Datetime extends Data.SharpClass {
    static get Fullname(): string;
    DateTime: RealDate;
}
}

namespace Data {
@Convertible()
class Date extends Data.SharpClass {
    static get Fullname(): string;
    DateTime: RealDate;
}
}

namespace Data {
@Convertible()
class DataError extends Aventus.GenericError<typeof Data.DataErrorCode> {
    static get Fullname(): string;
}
}

namespace Tools {
@Convertible()
class VoidWithError<T extends Aventus.GenericError = Aventus.GenericError> extends Aventus.VoidWithError<T> implements Tools.IWithError<T>, Tools.IWithError<T> {
    static get Fullname(): string;
}
}

namespace Data {
@Convertible()
class VoidWithDataError extends Tools.VoidWithError<Data.DataError> {
    static get Fullname(): string;
}
}

namespace Tools {
@Convertible()
class ResultWithError<T, U extends Aventus.GenericError = Aventus.GenericError> extends Aventus.ResultWithError<T, U> implements Tools.IResultWithError<U>, Tools.IResultWithError<U> {
    static get Fullname(): string;
}
}

namespace Routes {
abstract class StorableRouter<T extends Aventus.IData> extends Aventus.HttpRoute {

    @BindThis()
	GetAll(): Promise<Tools.ResultWithError<T[]>>;
    @BindThis()
	Create(body: {
        item: T;
    } | FormData): Promise<Tools.ResultWithError<T>>;
    @BindThis()
	CreateMany(body: {
        list: T[];
    } | FormData): Promise<Tools.ResultWithError<T[]>>;
    @BindThis()
	GetById(id: number): Promise<Tools.ResultWithError<T>>;
    @BindThis()
	GetByIds(body: {
        ids: number[];
    } | FormData): Promise<Tools.ResultWithError<T[]>>;
    @BindThis()
	Update(id: number, body: {
        item: T;
    } | FormData): Promise<Tools.ResultWithError<T>>;
    @BindThis()
	UpdateMany(body: {
        list: T[];
    } | FormData): Promise<Tools.ResultWithError<T[]>>;
    @BindThis()
	Delete(id: number): Promise<Tools.ResultWithError<T>>;
    @BindThis()
	DeleteMany(body: {
        ids: number[];
    } | FormData): Promise<Tools.ResultWithError<T[]>>;
    abstract StorableName(): string;
}
}

namespace Data {
@Convertible()
class ResultWithDataError<T> extends Tools.ResultWithError<T, Data.DataError> {
    static get Fullname(): string;
}
}

namespace Routes {
@Convertible()
class RouteError extends Aventus.GenericError<typeof Routes.RouteErrorCode> {
    static get Fullname(): string;
}
}

namespace Routes {
@Convertible()
class ResultWithRouteError<T> extends Tools.ResultWithError<T, Routes.RouteError> {
    static get Fullname(): string;
}
}

namespace Routes {
@Convertible()
class VoidWithRouteError extends Tools.VoidWithError<Routes.RouteError> {
    static get Fullname(): string;
}
}

namespace WebSocket {
type InternalSocketRoute = WebSocket.SocketRoute & Aventus.PreparedUri;
}

namespace WebSocket {
interface ConnectionOptions {
    log?: boolean;
    logPrefix?: string;
    host?: string;
    port?: number;
    useHttps?: boolean;
    routes?: {
        [key: string]: WebSocket.InternalSocketRoute[];
    };
    /**
     * Define the name for the websocket
     * It ll open the ws connection on /ws/${socketName}
     */
    socketName?: string;
    /**
     * Define if the message must be buffered before the socket open.
     * If true, when the socket is opened, all messages in buffered will be sent
     */
    allowSendBeforeOpen?: boolean;
    /**
     * Define the websocket connection must be open during creation
     */
    autoStart?: boolean;
    /**
     * Define if a /ping msg must be sent
     */
    sendPing?: number;
}
}

namespace WebSocket {
class SocketError extends Aventus.GenericError<WebSocket.SocketErrorCode> {
}
}

namespace WebSocket {
abstract class Connection {
    static Debug: boolean;
    protected options: Required<WebSocket.ConnectionOptions>;
    protected waitingList: {
        [uuid: string]: (channel: string, data: any) => void;
    };
    protected memoryBeforeOpen: WebSocket.SocketSendMessageOptions[];
    protected socket?: WebSocket.Socket;
    protected actionGuard: Aventus.ActionGuard;
    /**
     * Create a singleton
     */
    static getInstance(): WebSocket.Connection;
    protected constructor();
    readonly onOpen: Aventus.Callback<() => void>;
    readonly onClose: Aventus.Callback<(event: Event) => void>;
    readonly onError: Aventus.Callback<(event: Event) => void>;
    /**
     * Define the configuration for your websocket
     */
    protected abstract configure(options: WebSocket.ConnectionOptions): WebSocket.ConnectionOptions;
    /**
     * Configure a new Websocket
     */
    protected _configure(options?: WebSocket.ConnectionOptions): Required<WebSocket.ConnectionOptions>;
    private getUrl;
    /**
     * Add a new route to listen to the websocket
     */
    addRoute(newRoute: WebSocket.SocketRoute): void;
    /**
     * The route to remove
     * @param route - The route to remove
     */
    removeRoute(route: WebSocket.SocketRoute): void;
    protected openCallback: ((isOpen: boolean) => void) | undefined;
    /**
     * Try to open the websocket
     */
    open(): Promise<boolean>;
    protected jsonReplacer(key: string, value: any): any;
    /**
     * Send a message though the websocket
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param options the options to add to the message (typically the uid)
     */
    sendMessage<T>(options: WebSocket.SocketSendMessageOptions): Promise<Aventus.VoidWithError>;
    /**
     * Send a message though the websocket and wait one answer give in parameters callbacks
     * @param channelName The channel on which the message is sent
     * @param body The data to send
     * @param timeout The timeout before the request failed
     */
    sendMessageAndWait<T>(options: WebSocket.SocketSendMessageOptions): Promise<Aventus.ResultWithError<Aventus.ExtractFromError<T>>>;
    /**
     * Check if socket is ready
     */
    isReady(): boolean;
    protected sendPingTimeout: number;
    protected sendPing(): void;
    protected startPing(): void;
    protected stopPing(): void;
    protected _onOpen(): void;
    protected errorOccur: boolean;
    protected _onError(event: Event): void;
    protected _onClose(event: Event): void;
    /**
     * Close the current connection
     */
    close(): void;
    protected onMessage(event: MessageEvent<any>): void;
    /**
     * Print a msg inside the console
     */
    protected log(message: {} | string): void;
}
}

namespace WebSocket {
class EndPoint extends WebSocket.Connection {
    /**
     * Create a singleton
     */
    static getInstance(): WebSocket.EndPoint;
    protected constructor();
    protected register(): void;
    /**
     * @inheritdoc
     */
    protected configure(options: WebSocket.ConnectionOptions): WebSocket.ConnectionOptions;
    protected get path(): string;
}
}

namespace WebSocket {
type WsEndPointType = (abstract new (...args: any[]) => WebSocket.EndPoint);
}

namespace WebSocket {
abstract class WsEvent<T extends any = any> {
    protected endpoint: WebSocket.EndPoint;
    onTrigger: Aventus.Callback<(item: Aventus.ExtractFromError<T>, params: Aventus.UriParamsValue, uid?: string) => void>;
    protected routeInfo: WebSocket.SocketRoute<Aventus.ExtractFromError<T>>;
    protected _listening: boolean;
    get listening(): boolean;
    getPrefix: () => string;
    constructor(endpoint?: WebSocket.EndPoint, getPrefix?: () => string);
    init(): void;
    /**
     * Define the websocket path
     */
    protected abstract path(): string;
    /**
     * Override this method to tell that the event must listen when created
     */
    protected listenOnBoot(): boolean;
    /**
     * Add the event to the endpoint. After that, the on trigger event can be triggered
     */
    listen(): void;
    /**
     * Remove the event from the endpoint. After that, the on trigger event won't be triggered
     */
    stop(): void;
    protected onEvent(data: Aventus.ExtractFromError<T>, params: Aventus.UriParamsValue, uid?: string): void;
}
}

namespace WebSocket {
type ExtractResultFrom<T extends WebSocket.WsEvent, U = any> = T extends WebSocket.WsEvent<infer U> ? U : never;
}

namespace WebSocket {
type WsEventType = abstract new (...args: any[]) => WebSocket.WsEvent;
}

type ExtractResponse<T extends WebSocket.WsEvent<U>, U = any> = T extends WebSocket.WsEvent<infer U> ? Aventus.ResultWithError<Aventus.ExtractFromError<U>> : never;

namespace WebSocket {
class StorableWsRoute_DeleteMany<T extends Aventus.IData> extends WebSocket.WsEvent<Tools.ResultWithError<T[]>> {
    /**
     * @inheritdoc
     */
    protected path(): string;
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix?: () => string, StorableName?: () => string);
}
}

namespace WebSocket {
class StorableWsRouter_Delete<T> extends WebSocket.WsEvent<T> {
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix: () => string, StorableName: () => string);
    /**
     * @inheritdoc
     */
    protected path(): string;
}
}

namespace WebSocket {
class StorableWsRoute_UpdateMany<T extends Aventus.IData> extends WebSocket.WsEvent<Tools.ResultWithError<T[]>> {
    /**
     * @inheritdoc
     */
    protected path(): string;
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix?: () => string, StorableName?: () => string);
}
}

namespace WebSocket {
class StorableWsRouter_Update<T> extends WebSocket.WsEvent<T> {
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix: () => string, StorableName: () => string);
    /**
     * @inheritdoc
     */
    protected path(): string;
}
}

namespace WebSocket {
class StorableWsRouter_GetByIds<T> extends WebSocket.WsEvent<T[]> {
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix: () => string, StorableName: () => string);
    /**
     * @inheritdoc
     */
    protected path(): string;
}
}

namespace WebSocket {
class StorableWsRouter_GetById<T> extends WebSocket.WsEvent<T> {
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix: () => string, StorableName: () => string);
    /**
     * @inheritdoc
     */
    protected path(): string;
}
}

namespace WebSocket {
class StorableWsRoute_CreateMany<T extends Aventus.IData> extends WebSocket.WsEvent<Tools.ResultWithError<T[]>> {
    /**
     * @inheritdoc
     */
    protected path(): string;
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix?: () => string, StorableName?: () => string);
}
}

namespace WebSocket {
class StorableWsRouter_Create<T> extends WebSocket.WsEvent<T> {
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix: () => string, StorableName: () => string);
    /**
     * @inheritdoc
     */
    protected path(): string;
}
}

namespace WebSocket {
class StorableWsRouter_GetAll<T> extends WebSocket.WsEvent<T[]> {
    StorableName: () => string;
    constructor(endpoint: WebSocket.EndPoint, getPrefix: () => string, StorableName: () => string);
    /**
     * @inheritdoc
     */
    protected path(): string;
}
}

namespace WebSocket {
type RouterRoutes = {
    [name: string]: WebSocket.WsEvent;
};
}

namespace WebSocket {
class Router<T extends WebSocket.RouterRoutes> {
    readonly endpoint: WebSocket.EndPoint;
    events: T;
    constructor(endpoint?: WebSocket.EndPoint);
    getPrefix(): string;
    protected defineEvents(): Partial<T>;
}
}

namespace WebSocket {
type WsRouterType = abstract new (...args: any[]) => WebSocket.Router<any>;
}

namespace WebSocket {
type StorableWsRouter__Routes<T extends Aventus.IData> = {
    GetAll: WebSocket.StorableWsRouter_GetAll<T>;
    Create: WebSocket.StorableWsRouter_Create<T>;
    CreateMany: WebSocket.StorableWsRoute_CreateMany<T>;
    GetById: WebSocket.StorableWsRouter_GetById<T>;
    GetByIds: WebSocket.StorableWsRouter_GetByIds<T>;
    Update: WebSocket.StorableWsRouter_Update<T>;
    UpdateMany: WebSocket.StorableWsRoute_UpdateMany<T>;
    Delete: WebSocket.StorableWsRouter_Delete<T>;
    DeleteMany: WebSocket.StorableWsRoute_DeleteMany<T>;
};
}

namespace WebSocket {
abstract class StorableWsRouter<T extends Aventus.IData, __Route extends WebSocket.StorableWsRouter__Routes<T> = WebSocket.StorableWsRouter__Routes<T>> extends WebSocket.Router<__Route> {
    protected defineEvents(): Partial<__Route>;
    GetAll(options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRouter_GetAll<T>>>;
    Create(body: {
        item: T;
    } | FormData, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRouter_Create<T>>>;
    CreateMany(body: {
        list: T[];
    } | FormData, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRoute_CreateMany<T>>>;
    GetById(id: number, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRouter_GetById<T>>>;
    GetByIds(body: {
        ids: number[];
    } | FormData, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRouter_GetByIds<T>>>;
    Update(id: number, body: {
        item: T;
    } | FormData, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRouter_Update<T>>>;
    UpdateMany(body: {
        list: T[];
    } | FormData, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRoute_UpdateMany<T>>>;
    Delete(id: number, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRouter_Delete<T>>>;
    DeleteMany(body: {
        ids: number[];
    } | FormData, options?: WebSocket.WsRouteSendOptions): Promise<ExtractResponse<WebSocket.StorableWsRoute_DeleteMany<T>>>;
    abstract StorableName(): string;
}
}

namespace WebSocket {
@Convertible()
class WsError extends Aventus.GenericError<typeof WebSocket.WsErrorCode> {
    static get Fullname(): string;
}
}

namespace WebSocket {
@Convertible()
class ResultWithWsError<T> extends Tools.ResultWithError<T, WebSocket.WsError> {
    static get Fullname(): string;
}
}

namespace WebSocket {
@Convertible()
class VoidWithWsError extends Tools.VoidWithError<WebSocket.WsError> {
    static get Fullname(): string;
}
}

namespace RAM {
class RamCompletor<T extends Data.Storable> {
    protected objects: T[];
    protected fields: ___AventusSharp.RAM.ItemField<T, any>[];
    protected error?: Aventus.VoidWithError;
    constructor(objects?: T | T[], error?: Aventus.VoidWithError);
    add<U extends Aventus.IData>(field: ___AventusSharp.RAM.ItemField<T, U>): RAM.RamCompletor<T>;
    run(): Promise<Aventus.VoidWithError>;
}
}

namespace RAM {
abstract class RamHttp<T extends Data.Storable> extends Aventus.Ram<T> {
    protected getAllDone: boolean;
    protected routes: Routes.StorableRouter<T>;
    abstract defineRoutes(): Routes.StorableRouter<T>;
    protected constructor();
    protected beforeGetAll(result: Aventus.ResultRamWithError<Map<number, Aventus.RamItem<T>>>): Promise<void>;
    protected beforeGetById(id: number, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): Promise<void>;
    protected beforeGetByIds(ids: number[], result: Aventus.ResultRamWithError<Aventus.RamItem<T>[]>): Promise<void>;
    complete(objects?: T | T[], error?: Aventus.VoidWithError): RAM.RamCompletor<T>;
    protected beforeCreateItem(item: T, fromList: boolean, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): Promise<void>;
    protected beforeCreateList(list: T[], result: Aventus.ResultRamWithError<Aventus.RamItem<T>[]>): Promise<void>;
    protected beforeUpdateItem(item: T, fromList: boolean, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): Promise<void>;
    protected beforeUpdateList(list: T[], result: Aventus.ResultRamWithError<Aventus.RamItem<T>[]>): Promise<void>;
    protected beforeDeleteItem(item: T, fromList: boolean, result: Aventus.VoidWithError): Promise<void>;
    protected beforeDeleteList(list: T[], result: Aventus.VoidWithError): Promise<void>;
}
}

namespace RAM {
abstract class RamWebSocket<T extends Data.Storable> extends Aventus.Ram<T> {
    protected getAllDone: boolean;
    private routes;
    protected otherGetAllLocked: {
        [uid: string]: true;
    };
    protected otherGetByIdLocked: {
        [uid: string]: true;
    };
    protected otherCreateItemLocked: {
        [uid: string]: true;
    };
    protected otherCreateListLocked: {
        [uid: string]: true;
    };
    protected otherUpdateItemLocked: {
        [uid: string]: true;
    };
    protected otherUpdateListLocked: {
        [uid: string]: true;
    };
    protected otherDeleteItemLocked: {
        [uid: string]: true;
    };
    protected otherDeleteListLocked: {
        [uid: string]: true;
    };
    abstract defineRoutes(): WebSocket.StorableWsRouter<T>;
    protected constructor();
    protected addEventsBindings(): void;
    protected listenOnStart(): RAM.RamWebSocketListenOnStart;
    complete(objects?: T | T[], error?: Aventus.VoidWithError): RAM.RamCompletor<T>;
    @BindThis()
	protected otherGetAll(items: Aventus.ExtractFromError<T[]>, params: Aventus.UriParams, uid?: string): any;
    protected beforeGetAll(result: Aventus.ResultRamWithError<Map<number, Aventus.RamItem<T>>>): Promise<void>;
    @BindThis()
	protected otherGetById(item: Aventus.ExtractFromError<T>, params: Aventus.UriParams, uid?: string): any;
    protected beforeGetById(id: number, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): Promise<void>;
    protected beforeGetByIds(ids: number[], result: Aventus.ResultRamWithError<Aventus.RamItem<T>[]>): Promise<void>;
    @BindThis()
	protected otherCreateItem(item: Aventus.ExtractFromError<T>, params: Aventus.UriParams, uid?: string): any;
    protected beforeCreateItem(item: T, fromList: boolean, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): Promise<void>;
    @BindThis()
	protected otherCreateList(items: Aventus.ExtractFromError<T[]>, params: Aventus.UriParams, uid?: string): any;
    protected beforeCreateList(list: T[], result: Aventus.ResultRamWithError<Aventus.RamItem<T>[]>): Promise<void>;
    @BindThis()
	protected otherUpdateItem(item: Aventus.ExtractFromError<T>, params: Aventus.UriParams, uid?: string): any;
    protected beforeUpdateItem(item: T, fromList: boolean, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): Promise<void>;
    @BindThis()
	protected otherUpdateList(items: T[], params: Aventus.UriParams, uid?: string): any;
    protected beforeUpdateList(list: T[], result: Aventus.ResultRamWithError<Aventus.RamItem<T>[]>): Promise<void>;
    @BindThis()
	protected otherDeleteItem(item: Aventus.ExtractFromError<T>, params: Aventus.UriParams, uid?: string): void;
    protected beforeDeleteItem(item: T, fromList: boolean, result: Aventus.VoidWithError): Promise<void>;
    @BindThis()
	protected otherDeleteList(items: T[], params: Aventus.UriParams, uid?: string): void;
    protected beforeDeleteList(list: T[], result: Aventus.VoidWithError): Promise<void>;
    /**
    * Delete element inside Ram without firing delete event
    */
    protected deleteData(item: Aventus.KeysObject<T>, result: Aventus.ResultRamWithError<Aventus.RamItem<T>>): void;
}
}

	}
}
declare module ___AventusSharp {
namespace RAM {
type KeysOfType<T, U> = {
    [K in keyof T]: NonNullable<T[K]> extends U ? K : never;
}[keyof T];
}

namespace RAM {
type NumberKeys<T> = {
    [K in keyof T]: T[K] extends number ? K : never;
}[keyof T];
}

namespace RAM {
type ItemField<T extends Aventus.IData, U extends Aventus.IData> = {
    id: RAM.NumberKeys<T>;
    obj: RAM.KeysOfType<T, U>;
    ram: typeof Aventus.Ram<U>;
};
}
}//#endregion js def //
//#region js src //
{"namespace":"AventusSharp","available":[{"code":"Data.Storable=class Storable extends Aventus.Data {\n    Id = 0;\n    /**\n     * @inerhit\n     */\n    toJSON() {\n        let toAvoid = ['className', 'namespace'];\n        return Aventus.Json.classToJson(this, {\n            isValidKey: (key) => !toAvoid.includes(key),\n            beforeEnd: (result) => {\n                let resultTemp = {};\n                if (result.$type) {\n                    resultTemp.$type = result.$type;\n                    for (let key in result) {\n                        if (key != '$type') {\n                            resultTemp[key] = result[key];\n                        }\n                    }\n                    return resultTemp;\n                }\n                return result;\n            }\n        });\n    }\n}\nData.Storable.Namespace=`AventusSharp.Data`;\r\nData.Storable.$schema={...(Aventus.Data?.$schema ?? {}), \"Id\":\"number\"};\r\nAventus.Converter.register(Data.Storable.Fullname, Data.Storable);\r\n__as1(_.Data, 'Storable', Data.Storable);\r\n","dependances":[{"fullName":"Aventus.Data","isStrong":true},{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Aventus.Json","isStrong":false}],"fullName":"AventusSharp.Data.Storable","required":false,"type":2,"isExported":true,"convertibleName":""},{"code":"Data.StorableTimestamp=class StorableTimestamp extends Data.Storable {\n    CreatedDate = new Date();\n    UpdatedDate = new Date();\n}\nData.StorableTimestamp.Namespace=`AventusSharp.Data`;\r\nData.StorableTimestamp.$schema={...(Data.Storable?.$schema ?? {}), \"CreatedDate\":\"Date\",\"UpdatedDate\":\"Date\"};\r\nAventus.Converter.register(Data.StorableTimestamp.Fullname, Data.StorableTimestamp);\r\n__as1(_.Data, 'StorableTimestamp', Data.StorableTimestamp);\r\n","dependances":[{"fullName":"AventusSharp.Data.Storable","isStrong":true},{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Date","isStrong":false}],"fullName":"AventusSharp.Data.StorableTimestamp","required":false,"type":2,"isExported":true,"convertibleName":""},{"code":"(function (WsErrorCode) {\n    WsErrorCode[WsErrorCode[\"UnknowError\"] = 0] = \"UnknowError\";\n    WsErrorCode[WsErrorCode[\"CantDefineAssembly\"] = 1] = \"CantDefineAssembly\";\n    WsErrorCode[WsErrorCode[\"ConfigError\"] = 2] = \"ConfigError\";\n    WsErrorCode[WsErrorCode[\"MultipleMainEndpoint\"] = 3] = \"MultipleMainEndpoint\";\n    WsErrorCode[WsErrorCode[\"CantGetValueFromBody\"] = 4] = \"CantGetValueFromBody\";\n    WsErrorCode[WsErrorCode[\"NoConnection\"] = 5] = \"NoConnection\";\n    WsErrorCode[WsErrorCode[\"NoEndPoint\"] = 6] = \"NoEndPoint\";\n    WsErrorCode[WsErrorCode[\"NoPath\"] = 7] = \"NoPath\";\n})(WebSocket.WsErrorCode || (WebSocket.WsErrorCode = {}));\n__as1(_.WebSocket, 'WsErrorCode', WebSocket.WsErrorCode);\r\n","dependances":[],"fullName":"AventusSharp.WebSocket.WsErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"(function (SocketErrorCode) {\n    SocketErrorCode[SocketErrorCode[\"socketClosed\"] = 0] = \"socketClosed\";\n    SocketErrorCode[SocketErrorCode[\"timeout\"] = 1] = \"timeout\";\n    SocketErrorCode[SocketErrorCode[\"differentChannel\"] = 2] = \"differentChannel\";\n    SocketErrorCode[SocketErrorCode[\"unknow\"] = 3] = \"unknow\";\n})(WebSocket.SocketErrorCode || (WebSocket.SocketErrorCode = {}));\n__as1(_.WebSocket, 'SocketErrorCode', WebSocket.SocketErrorCode);\r\n","dependances":[],"fullName":"AventusSharp.WebSocket.SocketErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"WebSocket.Socket=class Socket {\n    static Debug = false;\n    static connections = {};\n    static getInstance(url, el) {\n        if (!this.connections[url]) {\n            this.connections[url] = new WebSocket.Socket(url, el);\n        }\n        else {\n            this.connections[url].registerEl(el);\n        }\n        return this.connections[url];\n    }\n    socket;\n    url;\n    elements = [];\n    reopenInterval = 0;\n    onOpen = new Aventus.Callback();\n    onClose = new Aventus.Callback();\n    onError = new Aventus.Callback();\n    onMessage = new Aventus.Callback();\n    get readyState() {\n        return this.socket.readyState;\n    }\n    constructor(url, el) {\n        this.url = url;\n        this.elements = [el];\n        this.socket = this.createWebSocket();\n        this.reopen = this.reopen.bind(this);\n        this.onClose.add(this.reopen);\n    }\n    registerEl(el) {\n        if (!this.elements.includes(el)) {\n            this.elements.push(el);\n        }\n    }\n    createWebSocket() {\n        this.removeSocket();\n        const socket = new window.WebSocket(this.url);\n        socket.onopen = (e) => {\n            clearInterval(this.reopenInterval);\n            this.onOpen.trigger(e);\n        };\n        socket.onclose = (e) => {\n            this.onClose.trigger(e);\n        };\n        socket.onerror = (e) => {\n            this.onError.trigger(e);\n        };\n        socket.onmessage = (e) => {\n            this.onMessage.trigger(e);\n        };\n        this.socket = socket;\n        return socket;\n    }\n    removeSocket() {\n        if (this.socket) {\n            this.socket.onopen = null;\n            this.socket.onclose = null;\n            this.socket.onerror = null;\n            this.socket.onmessage = null;\n            this.socket.close();\n        }\n    }\n    reopen() {\n        clearInterval(this.reopenInterval);\n        this.reopenInterval = setInterval(async () => {\n            console.warn(\"try reopen socket \");\n            await this.createWebSocket();\n            if (this.isReady()) {\n                clearInterval(this.reopenInterval);\n            }\n        }, 5000);\n    }\n    close(el, code, reason) {\n        let index = this.elements.indexOf(el);\n        if (index != -1) {\n            this.elements.splice(0, 1);\n        }\n        if (this.elements.length == 0) {\n            this.removeSocket();\n            delete WebSocket.Socket.connections[this.url];\n        }\n    }\n    send(data) {\n        this.socket.send(data);\n    }\n    /**\n    * Check if socket is ready\n    */\n    isReady() {\n        return this.socket.readyState == 1;\n    }\n}\nWebSocket.Socket.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'Socket', WebSocket.Socket);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.Socket","isStrong":false},{"fullName":"WebSocket","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Event","isStrong":false},{"fullName":"MessageEvent","isStrong":false},{"fullName":"ArrayBufferLike","isStrong":false},{"fullName":"Blob","isStrong":false},{"fullName":"ArrayBufferView","isStrong":false}],"fullName":"AventusSharp.WebSocket.Socket","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"(function (RouteErrorCode) {\n    RouteErrorCode[RouteErrorCode[\"UnknowError\"] = 0] = \"UnknowError\";\n    RouteErrorCode[RouteErrorCode[\"FormContentTypeUnknown\"] = 1] = \"FormContentTypeUnknown\";\n    RouteErrorCode[RouteErrorCode[\"CantGetValueFromBody\"] = 2] = \"CantGetValueFromBody\";\n    RouteErrorCode[RouteErrorCode[\"CantMoveFile\"] = 3] = \"CantMoveFile\";\n    RouteErrorCode[RouteErrorCode[\"CantCreateFolders\"] = 4] = \"CantCreateFolders\";\n    RouteErrorCode[RouteErrorCode[\"RouteAlreadyExist\"] = 5] = \"RouteAlreadyExist\";\n})(Routes.RouteErrorCode || (Routes.RouteErrorCode = {}));\n__as1(_.Routes, 'RouteErrorCode', Routes.RouteErrorCode);\r\n","dependances":[],"fullName":"AventusSharp.Routes.RouteErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"(function (DataErrorCode) {\n    DataErrorCode[DataErrorCode[\"DefaultDMGenericType\"] = 0] = \"DefaultDMGenericType\";\n    DataErrorCode[DataErrorCode[\"DMOnlyForceInherit\"] = 1] = \"DMOnlyForceInherit\";\n    DataErrorCode[DataErrorCode[\"TypeNotStorable\"] = 2] = \"TypeNotStorable\";\n    DataErrorCode[DataErrorCode[\"TypeTooMuchStorable\"] = 3] = \"TypeTooMuchStorable\";\n    DataErrorCode[DataErrorCode[\"GenericNotAbstract\"] = 4] = \"GenericNotAbstract\";\n    DataErrorCode[DataErrorCode[\"ParentNotAbstract\"] = 5] = \"ParentNotAbstract\";\n    DataErrorCode[DataErrorCode[\"InfiniteLoop\"] = 6] = \"InfiniteLoop\";\n    DataErrorCode[DataErrorCode[\"InterfaceNotUnique\"] = 7] = \"InterfaceNotUnique\";\n    DataErrorCode[DataErrorCode[\"SelfReferecingDependance\"] = 8] = \"SelfReferecingDependance\";\n    DataErrorCode[DataErrorCode[\"DMNotExist\"] = 9] = \"DMNotExist\";\n    DataErrorCode[DataErrorCode[\"DMAlreadyExist\"] = 10] = \"DMAlreadyExist\";\n    DataErrorCode[DataErrorCode[\"MethodNotFound\"] = 11] = \"MethodNotFound\";\n    DataErrorCode[DataErrorCode[\"StorageDisconnected\"] = 12] = \"StorageDisconnected\";\n    DataErrorCode[DataErrorCode[\"StorageNotFound\"] = 13] = \"StorageNotFound\";\n    DataErrorCode[DataErrorCode[\"NoConnectionInsideStorage\"] = 14] = \"NoConnectionInsideStorage\";\n    DataErrorCode[DataErrorCode[\"TypeNotExistInsideStorage\"] = 15] = \"TypeNotExistInsideStorage\";\n    DataErrorCode[DataErrorCode[\"UnknowError\"] = 16] = \"UnknowError\";\n    DataErrorCode[DataErrorCode[\"NoItemProvided\"] = 17] = \"NoItemProvided\";\n    DataErrorCode[DataErrorCode[\"NoTransactionInProgress\"] = 18] = \"NoTransactionInProgress\";\n    DataErrorCode[DataErrorCode[\"WrongType\"] = 19] = \"WrongType\";\n    DataErrorCode[DataErrorCode[\"NoTypeIdentifierFoundInsideQuery\"] = 20] = \"NoTypeIdentifierFoundInsideQuery\";\n    DataErrorCode[DataErrorCode[\"ItemNoExistInsideStorage\"] = 21] = \"ItemNoExistInsideStorage\";\n    DataErrorCode[DataErrorCode[\"ItemAlreadyExist\"] = 22] = \"ItemAlreadyExist\";\n    DataErrorCode[DataErrorCode[\"ValidationError\"] = 23] = \"ValidationError\";\n    DataErrorCode[DataErrorCode[\"GetAllNotAllowed\"] = 24] = \"GetAllNotAllowed\";\n    DataErrorCode[DataErrorCode[\"GetByIdNotAllowed\"] = 25] = \"GetByIdNotAllowed\";\n    DataErrorCode[DataErrorCode[\"GetByIdsNotAllowed\"] = 26] = \"GetByIdsNotAllowed\";\n    DataErrorCode[DataErrorCode[\"WhereNotAllowed\"] = 27] = \"WhereNotAllowed\";\n    DataErrorCode[DataErrorCode[\"CreateNotAllowed\"] = 28] = \"CreateNotAllowed\";\n    DataErrorCode[DataErrorCode[\"UpdateNotAllowed\"] = 29] = \"UpdateNotAllowed\";\n    DataErrorCode[DataErrorCode[\"DeleteNotAllowed\"] = 30] = \"DeleteNotAllowed\";\n    DataErrorCode[DataErrorCode[\"NumberOfItemsNotMatching\"] = 31] = \"NumberOfItemsNotMatching\";\n    DataErrorCode[DataErrorCode[\"FieldTypeNotFound\"] = 32] = \"FieldTypeNotFound\";\n    DataErrorCode[DataErrorCode[\"MemberNotFound\"] = 33] = \"MemberNotFound\";\n    DataErrorCode[DataErrorCode[\"TooMuchMemberFound\"] = 34] = \"TooMuchMemberFound\";\n    DataErrorCode[DataErrorCode[\"TypeNotFound\"] = 35] = \"TypeNotFound\";\n    DataErrorCode[DataErrorCode[\"ReverseLinkNotExist\"] = 36] = \"ReverseLinkNotExist\";\n    DataErrorCode[DataErrorCode[\"ErrorCreatingReverseQuery\"] = 37] = \"ErrorCreatingReverseQuery\";\n    DataErrorCode[DataErrorCode[\"LinkNotSet\"] = 38] = \"LinkNotSet\";\n})(Data.DataErrorCode || (Data.DataErrorCode = {}));\n__as1(_.Data, 'DataErrorCode', Data.DataErrorCode);\r\n","dependances":[],"fullName":"AventusSharp.Data.DataErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"Data.SharpClass=class SharpClass {\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * Get the name of the class\n     */\n    get className() {\n        return this.constructor.name;\n    }\n    /**\n     * Clone the object by transforming a parsed JSON string back into the original type\n     */\n    clone() {\n        return Aventus.Converter.transform(JSON.parse(JSON.stringify(this)));\n    }\n    /**\n     * Get a JSON for the current object\n     */\n    toJSON() {\n        let toAvoid = ['className', 'namespace'];\n        return Aventus.Json.classToJson(this, {\n            isValidKey: (key) => !toAvoid.includes(key),\n            beforeEnd: (result) => {\n                let resultTemp = {};\n                if (result.$type) {\n                    resultTemp.$type = result.$type;\n                    for (let key in result) {\n                        if (key != '$type') {\n                            resultTemp[key] = result[key];\n                        }\n                    }\n                    return resultTemp;\n                }\n                return result;\n            }\n        });\n    }\n}\nData.SharpClass.Namespace=`AventusSharp.Data`;\r\n__as1(_.Data, 'SharpClass', Data.SharpClass);\r\n","dependances":[{"fullName":"Aventus.Converter","isStrong":false},{"fullName":"Aventus.Json","isStrong":false}],"fullName":"AventusSharp.Data.SharpClass","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"Data.FieldErrorInfo=class FieldErrorInfo extends _.Data.SharpClass {\n    static get Fullname() { return \"AventusSharp.Data.FieldErrorInfo, AventusSharp\"; }\n    Name;\n}\nData.FieldErrorInfo.Namespace=`AventusSharp.Data`;\r\nData.FieldErrorInfo.$schema={...(Data.SharpClass?.$schema ?? {}), \"Name\":\"string\"};\r\nAventus.Converter.register(Data.FieldErrorInfo.Fullname, Data.FieldErrorInfo);\r\n__as1(_.Data, 'FieldErrorInfo', Data.FieldErrorInfo);\r\n","dependances":[{"fullName":"AventusSharp.Data.SharpClass","isStrong":true},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Data.FieldErrorInfo","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Data.CustomTableMembers.AventusFile=class AventusFile {\n    Uri;\n    Upload;\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * @inerhit\n     */\n    toJSON() {\n        let toAvoid = ['className', 'namespace'];\n        return Aventus.Json.classToJson(this, {\n            isValidKey: (key) => !toAvoid.includes(key),\n            beforeEnd: (result) => {\n                let resultTemp = {};\n                if (result.$type) {\n                    resultTemp.$type = result.$type;\n                    for (let key in result) {\n                        if (key != '$type') {\n                            resultTemp[key] = result[key];\n                        }\n                    }\n                    return resultTemp;\n                }\n                return result;\n            }\n        });\n    }\n}\nData.CustomTableMembers.AventusFile.Namespace=`AventusSharp.Data.CustomTableMembers`;\r\n__as1(_.Data.CustomTableMembers, 'AventusFile', Data.CustomTableMembers.AventusFile);\r\n","dependances":[{"fullName":"Uri","isStrong":false},{"fullName":"File","isStrong":false},{"fullName":"Aventus.Json","isStrong":false}],"fullName":"AventusSharp.Data.CustomTableMembers.AventusFile","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"Data.Datetime=class Datetime extends _.Data.SharpClass {\n    static get Fullname() { return \"AventusSharp.Data.Datetime, AventusSharp\"; }\n    DateTime;\n}\nData.Datetime.Namespace=`AventusSharp.Data`;\r\nData.Datetime.$schema={...(Data.SharpClass?.$schema ?? {}), \"DateTime\":\"AventusSharp.RealDate\"};\r\nAventus.Converter.register(Data.Datetime.Fullname, Data.Datetime);\r\n__as1(_.Data, 'Datetime', Data.Datetime);\r\n","dependances":[{"fullName":"AventusSharp.Data.SharpClass","isStrong":true},{"fullName":"Convertible","isStrong":false},{"fullName":"AventusSharp.RealDate","isStrong":false}],"fullName":"AventusSharp.Data.Datetime","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Data.Date=class Date extends _.Data.SharpClass {\n    static get Fullname() { return \"AventusSharp.Data.Date, AventusSharp\"; }\n    DateTime;\n}\nData.Date.Namespace=`AventusSharp.Data`;\r\nData.Date.$schema={...(Data.SharpClass?.$schema ?? {}), \"DateTime\":\"AventusSharp.RealDate\"};\r\nAventus.Converter.register(Data.Date.Fullname, Data.Date);\r\n__as1(_.Data, 'Date', Data.Date);\r\n","dependances":[{"fullName":"AventusSharp.Data.SharpClass","isStrong":true},{"fullName":"Convertible","isStrong":false},{"fullName":"AventusSharp.RealDate","isStrong":false}],"fullName":"AventusSharp.Data.Date","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Data.DataError=class DataError extends Aventus.GenericError {\n    static get Fullname() { return \"AventusSharp.Data.DataError, AventusSharp\"; }\n}\nData.DataError.Namespace=`AventusSharp.Data`;\r\nData.DataError.$schema={...(Aventus.GenericError?.$schema ?? {}), };\r\nAventus.Converter.register(Data.DataError.Fullname, Data.DataError);\r\n__as1(_.Data, 'DataError', Data.DataError);\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"AventusSharp.Data.DataErrorCode","isStrong":true},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Data.DataError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Tools.VoidWithError=class VoidWithError extends Aventus.VoidWithError {\n    static get Fullname() { return \"AventusSharp.Tools.VoidWithError, AventusSharp\"; }\n}\nTools.VoidWithError.Namespace=`AventusSharp.Tools`;\r\nTools.VoidWithError.$schema={...(Aventus.VoidWithError?.$schema ?? {}), };\r\nAventus.Converter.register(Tools.VoidWithError.Fullname, Tools.VoidWithError);\r\n__as1(_.Tools, 'VoidWithError', Tools.VoidWithError);\r\n","dependances":[{"fullName":"Aventus.VoidWithError","isStrong":true},{"fullName":"AventusSharp.Tools.IWithError","isStrong":true},{"fullName":"Convertible","isStrong":false},{"fullName":"Aventus.GenericError","isStrong":false}],"fullName":"AventusSharp.Tools.VoidWithError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Data.VoidWithDataError=class VoidWithDataError extends Tools.VoidWithError {\n    static get Fullname() { return \"AventusSharp.Data.VoidWithDataError, AventusSharp\"; }\n}\nData.VoidWithDataError.Namespace=`AventusSharp.Data`;\r\nData.VoidWithDataError.$schema={...(Tools.VoidWithError?.$schema ?? {}), };\r\nAventus.Converter.register(Data.VoidWithDataError.Fullname, Data.VoidWithDataError);\r\n__as1(_.Data, 'VoidWithDataError', Data.VoidWithDataError);\r\n","dependances":[{"fullName":"AventusSharp.Tools.VoidWithError","isStrong":true},{"fullName":"AventusSharp.Data.DataError","isStrong":false},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Data.VoidWithDataError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Tools.ResultWithError=class ResultWithError extends Aventus.ResultWithError {\n    static get Fullname() { return \"AventusSharp.Tools.ResultWithError, AventusSharp\"; }\n}\nTools.ResultWithError.Namespace=`AventusSharp.Tools`;\r\nTools.ResultWithError.$schema={...(Aventus.ResultWithError?.$schema ?? {}), };\r\nAventus.Converter.register(Tools.ResultWithError.Fullname, Tools.ResultWithError);\r\n__as1(_.Tools, 'ResultWithError', Tools.ResultWithError);\r\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"AventusSharp.Tools.IResultWithError","isStrong":true},{"fullName":"Convertible","isStrong":false},{"fullName":"Aventus.GenericError","isStrong":false}],"fullName":"AventusSharp.Tools.ResultWithError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Routes.StorableRouter=class StorableRouter extends Aventus.HttpRoute {\n    constructor(router) {\n        super(router);\n        this.GetAll = this.GetAll.bind(this);\n        this.Create = this.Create.bind(this);\n        this.CreateMany = this.CreateMany.bind(this);\n        this.GetById = this.GetById.bind(this);\n        this.GetByIds = this.GetByIds.bind(this);\n        this.Update = this.Update.bind(this);\n        this.UpdateMany = this.UpdateMany.bind(this);\n        this.Delete = this.Delete.bind(this);\n        this.DeleteMany = this.DeleteMany.bind(this);\n    }\n    async GetAll() {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}`, Aventus.HttpMethod.GET);\n        return await request.queryJSON(this.router);\n    }\n    async Create(body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}`, Aventus.HttpMethod.POST);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async CreateMany(body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}s`, Aventus.HttpMethod.POST);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async GetById(id) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}/${id}`, Aventus.HttpMethod.GET);\n        return await request.queryJSON(this.router);\n    }\n    async GetByIds(body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}/getbyids`, Aventus.HttpMethod.POST);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async Update(id, body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}/${id}`, Aventus.HttpMethod.PUT);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async UpdateMany(body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}s`, Aventus.HttpMethod.PUT);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async Delete(id) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}/${id}`, Aventus.HttpMethod.DELETE);\n        return await request.queryJSON(this.router);\n    }\n    async DeleteMany(body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.StorableName()}s`, Aventus.HttpMethod.DELETE);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n}\nRoutes.StorableRouter.Namespace=`AventusSharp.Routes`;\r\n__as1(_.Routes, 'StorableRouter', Routes.StorableRouter);\r\n","dependances":[{"fullName":"Aventus.HttpRoute","isStrong":true},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"BindThis","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":false},{"fullName":"Aventus.HttpRequest","isStrong":false},{"fullName":"Aventus.HttpMethod","isStrong":false},{"fullName":"TypeResult","isStrong":false},{"fullName":"FormData","isStrong":false}],"fullName":"AventusSharp.Routes.StorableRouter","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"Data.ResultWithDataError=class ResultWithDataError extends Tools.ResultWithError {\n    static get Fullname() { return \"AventusSharp.Data.ResultWithDataError, AventusSharp\"; }\n}\nData.ResultWithDataError.Namespace=`AventusSharp.Data`;\r\nData.ResultWithDataError.$schema={...(Tools.ResultWithError?.$schema ?? {}), };\r\nAventus.Converter.register(Data.ResultWithDataError.Fullname, Data.ResultWithDataError);\r\n__as1(_.Data, 'ResultWithDataError', Data.ResultWithDataError);\r\n","dependances":[{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":true},{"fullName":"AventusSharp.Data.DataError","isStrong":false},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Data.ResultWithDataError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Routes.RouteError=class RouteError extends Aventus.GenericError {\n    static get Fullname() { return \"AventusSharp.Routes.RouteError, AventusSharp\"; }\n}\nRoutes.RouteError.Namespace=`AventusSharp.Routes`;\r\nRoutes.RouteError.$schema={...(Aventus.GenericError?.$schema ?? {}), };\r\nAventus.Converter.register(Routes.RouteError.Fullname, Routes.RouteError);\r\n__as1(_.Routes, 'RouteError', Routes.RouteError);\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"AventusSharp.Routes.RouteErrorCode","isStrong":true},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Routes.RouteError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Routes.ResultWithRouteError=class ResultWithRouteError extends Tools.ResultWithError {\n    static get Fullname() { return \"AventusSharp.Routes.ResultWithRouteError, AventusSharp\"; }\n}\nRoutes.ResultWithRouteError.Namespace=`AventusSharp.Routes`;\r\nRoutes.ResultWithRouteError.$schema={...(Tools.ResultWithError?.$schema ?? {}), };\r\nAventus.Converter.register(Routes.ResultWithRouteError.Fullname, Routes.ResultWithRouteError);\r\n__as1(_.Routes, 'ResultWithRouteError', Routes.ResultWithRouteError);\r\n","dependances":[{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":true},{"fullName":"AventusSharp.Routes.RouteError","isStrong":false},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Routes.ResultWithRouteError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"Routes.VoidWithRouteError=class VoidWithRouteError extends Tools.VoidWithError {\n    static get Fullname() { return \"AventusSharp.Routes.VoidWithRouteError, AventusSharp\"; }\n}\nRoutes.VoidWithRouteError.Namespace=`AventusSharp.Routes`;\r\nRoutes.VoidWithRouteError.$schema={...(Tools.VoidWithError?.$schema ?? {}), };\r\nAventus.Converter.register(Routes.VoidWithRouteError.Fullname, Routes.VoidWithRouteError);\r\n__as1(_.Routes, 'VoidWithRouteError', Routes.VoidWithRouteError);\r\n","dependances":[{"fullName":"AventusSharp.Tools.VoidWithError","isStrong":true},{"fullName":"AventusSharp.Routes.RouteError","isStrong":false},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.Routes.VoidWithRouteError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"WebSocket.SocketError=class SocketError extends Aventus.GenericError {\n}\nWebSocket.SocketError.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'SocketError', WebSocket.SocketError);\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"AventusSharp.WebSocket.SocketErrorCode","isStrong":false}],"fullName":"AventusSharp.WebSocket.SocketError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.Connection=class Connection {\n    static Debug = false;\n    options;\n    waitingList = {};\n    memoryBeforeOpen = [];\n    socket;\n    actionGuard = new Aventus.ActionGuard();\n    /**\n     * Create a singleton\n     */\n    static getInstance() {\n        return Aventus.Instance.get(WebSocket.Connection);\n    }\n    constructor() {\n        this.options = this._configure(this.configure({}));\n        this._onOpen = this._onOpen.bind(this);\n        this._onClose = this._onClose.bind(this);\n        this._onError = this._onError.bind(this);\n        this.onMessage = this.onMessage.bind(this);\n        if (this.options.autoStart) {\n            this.open();\n        }\n    }\n    onOpen = new Aventus.Callback();\n    onClose = new Aventus.Callback();\n    onError = new Aventus.Callback();\n    /**\n     * Configure a new Websocket\n     */\n    _configure(options = {}) {\n        if (!options.host) {\n            options.host = window.location.hostname;\n        }\n        if (!options.hasOwnProperty('useHttps')) {\n            options.useHttps = window.location.protocol == \"https:\";\n        }\n        if (!options.port) {\n            if (window.location.port) {\n                options.port = parseInt(window.location.port);\n            }\n            else {\n                options.port = options.useHttps ? 443 : 80;\n            }\n        }\n        if (!options.routes) {\n            options.routes = {};\n        }\n        if (!options.socketName) {\n            options.socketName = \"\";\n        }\n        if (options.log === undefined) {\n            options.log = WebSocket.Connection.Debug;\n        }\n        if (options.autoStart === undefined) {\n            options.autoStart = true;\n        }\n        if (options.sendPing !== undefined && options.sendPing <= 0) {\n            options.sendPing = undefined;\n        }\n        if (options.logPrefix === undefined) {\n            options.logPrefix = \"\";\n        }\n        return options;\n    }\n    getUrl() {\n        let protocol = \"ws\";\n        if (this.options.useHttps) {\n            protocol = \"wss\";\n        }\n        let url = protocol + \"://\" + this.options.host + \":\" + this.options.port + this.options.socketName;\n        return url;\n    }\n    /**\n     * Add a new route to listen to the websocket\n     */\n    addRoute(newRoute) {\n        if (!this.options.routes.hasOwnProperty(newRoute.channel)) {\n            this.options.routes[newRoute.channel] = [];\n        }\n        for (let info of this.options.routes[newRoute.channel]) {\n            if (info.callback == newRoute.callback) {\n                return;\n            }\n        }\n        const { params, regex } = Aventus.Uri.prepare(newRoute.channel);\n        let prepared = {\n            callback: newRoute.callback,\n            channel: newRoute.channel,\n            regex,\n            params\n        };\n        this.options.routes[newRoute.channel].push(prepared);\n    }\n    /**\n     * The route to remove\n     * @param route - The route to remove\n     */\n    removeRoute(route) {\n        for (let i = 0; i < this.options.routes[route.channel].length; i++) {\n            let info = this.options.routes[route.channel][i];\n            if (info.callback == route.callback) {\n                this.options.routes[route.channel].splice(i, 1);\n                i--;\n            }\n        }\n    }\n    openCallback;\n    /**\n     * Try to open the websocket\n     */\n    open() {\n        return this.actionGuard.run([\"open\"], () => {\n            return new Promise((resolve) => {\n                try {\n                    let url = this.getUrl();\n                    this.log(\"Opening \" + url);\n                    this.openCallback = (isOpen) => {\n                        resolve(isOpen);\n                    };\n                    this.socket = _.WebSocket.Socket.getInstance(url, this);\n                    this.socket.onOpen.add(this._onOpen);\n                    this.socket.onClose.add(this._onClose);\n                    this.socket.onError.add(this._onError);\n                    this.socket.onMessage.add(this.onMessage);\n                    if (this.socket.isReady()) {\n                        this._onOpen();\n                    }\n                }\n                catch (e) {\n                    console.log(e);\n                    resolve(false);\n                }\n            });\n        });\n    }\n    jsonReplacer(key, value) {\n        if (this[key] instanceof Date) {\n            return Aventus.DateConverter.converter.toString(this[key]);\n        }\n        return value;\n    }\n    /**\n     * Send a message though the websocket\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param options the options to add to the message (typically the uid)\n     */\n    async sendMessage(options) {\n        let result = new Tools.VoidWithError();\n        if (!this.socket || this.socket.readyState != 1) {\n            let isOpen = await this.open();\n            if (!isOpen) {\n                result.errors.push(new _.WebSocket.SocketError(_.WebSocket.SocketErrorCode.socketClosed, \"Socket not ready ! Please ensure that it is open and ready to send message\"));\n                this.log('Socket not ready ! Please ensure that it is open and ready to send message');\n                if (this.options.allowSendBeforeOpen) {\n                    this.memoryBeforeOpen.push(options);\n                }\n                return result;\n            }\n        }\n        if (this.socket && this.socket.readyState == 1) {\n            try {\n                let message = {\n                    channel: options.channel,\n                };\n                if (options.uid) {\n                    message.uid = options.uid;\n                }\n                if (options.body) {\n                    message.data = options.body;\n                    this.log(message);\n                    if (typeof options.body != 'string') {\n                        message.data = JSON.stringify(options.body, this.jsonReplacer);\n                    }\n                }\n                else if (options.channel != \"/ping\") {\n                    this.log(message);\n                }\n                this.socket.send(JSON.stringify(message));\n            }\n            catch (e) {\n                result.errors.push(new _.WebSocket.SocketError(_.WebSocket.SocketErrorCode.unknow, e));\n            }\n        }\n        else {\n            result.errors.push(new _.WebSocket.SocketError(_.WebSocket.SocketErrorCode.socketClosed, \"Socket not ready ! Please ensure that it is open and ready to send message\"));\n            this.log('Socket not ready ! Please ensure that it is open and ready to send message');\n            if (this.options.allowSendBeforeOpen) {\n                this.memoryBeforeOpen.push(options);\n            }\n        }\n        return result;\n    }\n    /**\n     * Send a message though the websocket and wait one answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param body The data to send\n     * @param timeout The timeout before the request failed\n     */\n    sendMessageAndWait(options) {\n        return new Promise(async (resolve) => {\n            let result = new Aventus.ResultWithError();\n            try {\n                let _uid = options.uid ? options.uid : Aventus.uuidv4();\n                options.uid = _uid;\n                let timeoutInfo;\n                this.waitingList[_uid] = (channel, data) => {\n                    clearTimeout(timeoutInfo);\n                    if (channel.toLowerCase() != options.channel.toLowerCase()) {\n                        result.errors.push(new _.WebSocket.SocketError(_.WebSocket.SocketErrorCode.differentChannel, `We sent a message on ${options.channel} but we receive on ${channel}`));\n                        resolve(result);\n                    }\n                    else {\n                        if (data instanceof Aventus.VoidWithError) {\n                            for (let error of data.errors) {\n                                result.errors.push(error);\n                            }\n                            if (data instanceof Aventus.ResultWithError) {\n                                result.result = data.result;\n                            }\n                        }\n                        else {\n                            result.result = data;\n                        }\n                        resolve(result);\n                    }\n                };\n                if (options.timeout !== undefined) {\n                    timeoutInfo = setTimeout(() => {\n                        delete this.waitingList[_uid];\n                        result.errors.push(new _.WebSocket.SocketError(_.WebSocket.SocketErrorCode.timeout, \"No message received after \" + options.timeout + \"ms\"));\n                        resolve(result);\n                    }, options.timeout);\n                }\n                let sendMessageResult = await this.sendMessage(options);\n                if (!sendMessageResult.success) {\n                    for (let error of sendMessageResult.errors) {\n                        result.errors.push(error);\n                    }\n                    resolve(result);\n                }\n            }\n            catch (e) {\n                result.errors.push(new _.WebSocket.SocketError(_.WebSocket.SocketErrorCode.unknow, e));\n                resolve(result);\n            }\n        });\n    }\n    ;\n    /**\n     * Check if socket is ready\n     */\n    isReady() {\n        if (this.socket && this.socket.isReady()) {\n            return true;\n        }\n        return false;\n    }\n    sendPingTimeout = 0;\n    sendPing() {\n        this.sendMessage({\n            channel: \"/ping\",\n        });\n    }\n    startPing() {\n        clearInterval(this.sendPingTimeout);\n        this.sendPingTimeout = setInterval(() => {\n            this.sendPing();\n        }, 5000);\n    }\n    stopPing() {\n        clearInterval(this.sendPingTimeout);\n    }\n    _onOpen() {\n        if (this.socket?.isReady()) {\n            if (this.openCallback) {\n                this.openCallback(true);\n                this.openCallback = undefined;\n            }\n            let protocol = \"ws\";\n            if (this.options.useHttps) {\n                protocol = \"wss\";\n            }\n            this.log(`Connection successfully established to ${this.getUrl()}!`);\n            this.onOpen.trigger();\n            for (let i = 0; i < this.memoryBeforeOpen.length; i++) {\n                this.sendMessage(this.memoryBeforeOpen[i]);\n            }\n            this.memoryBeforeOpen = [];\n            if (this.options.sendPing) {\n                this.startPing();\n            }\n        }\n        else {\n            if (this.openCallback) {\n                this.openCallback(false);\n                this.openCallback = undefined;\n            }\n        }\n    }\n    errorOccur = false;\n    _onError(event) {\n        this.errorOccur = true;\n        if (this.openCallback) {\n            this.openCallback(false);\n            this.openCallback = undefined;\n            return;\n        }\n        this.log('An error has occured');\n        this.onError.trigger(event);\n    }\n    _onClose(event) {\n        this.stopPing();\n        if (this.errorOccur) {\n            this.errorOccur = false;\n            return;\n        }\n        this.log('Closing connection');\n        this.onClose.trigger(event);\n    }\n    /**\n     * Close the current connection\n     */\n    close() {\n        if (this.socket) {\n            this.socket.onOpen.remove(this._onOpen);\n            this.socket.onClose.remove(this._onClose);\n            this.socket.onError.remove(this._onError);\n            this.socket.onMessage.remove(this.onMessage);\n            this.socket.close(this);\n            delete this.socket;\n        }\n    }\n    onMessage(event) {\n        let response = JSON.parse(event.data);\n        this.log(response);\n        let data = {};\n        try {\n            data = Aventus.Converter.transform(JSON.parse(response.data));\n        }\n        catch (e) {\n            console.error(e);\n        }\n        for (let channel in this.options.routes) {\n            let current = this.options.routes[channel];\n            for (let info of current) {\n                let params = Aventus.Uri.getParams(info, response.channel);\n                if (params) {\n                    let valueCb = data;\n                    if (data instanceof Aventus.ResultWithError) {\n                        valueCb = data.result;\n                    }\n                    else if (data instanceof Aventus.VoidWithError) {\n                        valueCb = undefined;\n                    }\n                    info.callback(valueCb, params, response.uid);\n                }\n            }\n        }\n        if (response.uid) {\n            if (this.waitingList.hasOwnProperty(response.uid)) {\n                this.waitingList[response.uid](response.channel, data);\n                delete this.waitingList[response.uid];\n            }\n        }\n    }\n    /**\n     * Print a msg inside the console\n     */\n    log(message) {\n        if (this.options.log) {\n            const now = new Date();\n            const hours = (now.getHours()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const minutes = (now.getMinutes()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const seconds = (now.getSeconds()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const prefix = this.options.logPrefix ? `[${this.options.logPrefix}] ` : '';\n            if (message instanceof Object) {\n                let cloneMessage = JSON.parse(JSON.stringify(message, this.jsonReplacer));\n                if (cloneMessage.data && typeof cloneMessage.data == 'string') {\n                    cloneMessage.data = JSON.parse(cloneMessage.data);\n                }\n                console.log(`${prefix}[${hours}:${minutes}:${seconds}]: `, cloneMessage);\n            }\n            else {\n                console.log(`${prefix}[${hours}:${minutes}:${seconds}]: `, message);\n            }\n        }\n    }\n}\nWebSocket.Connection.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'Connection', WebSocket.Connection);\r\n","dependances":[{"fullName":"Required","isStrong":false},{"fullName":"AventusSharp.WebSocket.ConnectionOptions","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketSendMessageOptions","isStrong":false},{"fullName":"AventusSharp.WebSocket.Socket","isStrong":false},{"fullName":"Aventus.ActionGuard","isStrong":false},{"fullName":"AventusSharp.WebSocket.Connection","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Event","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketRoute","isStrong":false},{"fullName":"Aventus.Uri","isStrong":false},{"fullName":"AventusSharp.WebSocket.InternalSocketRoute","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Date","isStrong":false},{"fullName":"Aventus.DateConverter","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"AventusSharp.Tools.VoidWithError","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketError","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketErrorCode","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketMessage","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"Aventus.ExtractFromError","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.uuidv4","isStrong":false},{"fullName":"MessageEvent","isStrong":false},{"fullName":"Aventus.Converter","isStrong":false}],"fullName":"AventusSharp.WebSocket.Connection","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.EndPoint=class EndPoint extends _.WebSocket.Connection {\n    /**\n     * Create a singleton\n     */\n    static getInstance() {\n        return Aventus.Instance.get(WebSocket.EndPoint);\n    }\n    constructor() {\n        super();\n        this.register();\n    }\n    register() {\n    }\n    /**\n     * @inheritdoc\n     */\n    configure(options) {\n        options.socketName = this.path;\n        options.sendPing = 5000;\n        return options;\n    }\n    get path() {\n        return \"/ws\";\n    }\n    ;\n}\nWebSocket.EndPoint.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'EndPoint', WebSocket.EndPoint);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.Connection","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"AventusSharp.WebSocket.ConnectionOptions","isStrong":false}],"fullName":"AventusSharp.WebSocket.EndPoint","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.WsEvent=class WsEvent {\n    endpoint;\n    onTrigger = new Aventus.Callback();\n    routeInfo;\n    _listening = false;\n    get listening() {\n        return this._listening;\n    }\n    getPrefix;\n    constructor(endpoint, getPrefix) {\n        this.endpoint = endpoint ?? _.WebSocket.EndPoint.getInstance();\n        this.getPrefix = getPrefix ?? (() => \"\");\n        this.onEvent = this.onEvent.bind(this);\n    }\n    init() {\n        this.routeInfo = {\n            channel: this.path(),\n            callback: this.onEvent\n        };\n        if (this.listenOnBoot()) {\n            this.listen();\n        }\n    }\n    /**\n     * Override this method to tell that the event must listen when created\n     */\n    listenOnBoot() {\n        return false;\n    }\n    /**\n     * Add the event to the endpoint. After that, the on trigger event can be triggered\n     */\n    listen() {\n        if (!this._listening) {\n            this._listening = true;\n            if (!this.routeInfo) {\n                this.routeInfo = {\n                    channel: this.path(),\n                    callback: this.onEvent\n                };\n            }\n            this.endpoint.addRoute(this.routeInfo);\n        }\n    }\n    /**\n     * Remove the event from the endpoint. After that, the on trigger event won't be triggered\n     */\n    stop() {\n        if (this._listening) {\n            this._listening = false;\n            this.endpoint.removeRoute(this.routeInfo);\n        }\n    }\n    onEvent(data, params, uid) {\n        this.onTrigger.trigger(data, params, uid);\n    }\n}\nWebSocket.WsEvent.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'WsEvent', WebSocket.WsEvent);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Aventus.ExtractFromError","isStrong":false},{"fullName":"Aventus.UriParamsValue","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketRoute","isStrong":false}],"fullName":"AventusSharp.WebSocket.WsEvent","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRoute_DeleteMany=class StorableWsRoute_DeleteMany extends _.WebSocket.WsEvent {\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/DeleteMany`;\n    }\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName ?? (() => \"\");\n    }\n}\nWebSocket.StorableWsRoute_DeleteMany.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRoute_DeleteMany', WebSocket.StorableWsRoute_DeleteMany);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRoute_DeleteMany","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter_Delete=class StorableWsRouter_Delete extends _.WebSocket.WsEvent {\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName;\n    }\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/{id:number}/Delete`;\n    }\n}\nWebSocket.StorableWsRouter_Delete.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter_Delete', WebSocket.StorableWsRouter_Delete);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter_Delete","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRoute_UpdateMany=class StorableWsRoute_UpdateMany extends _.WebSocket.WsEvent {\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/UpdateMany`;\n    }\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName ?? (() => \"\");\n    }\n}\nWebSocket.StorableWsRoute_UpdateMany.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRoute_UpdateMany', WebSocket.StorableWsRoute_UpdateMany);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRoute_UpdateMany","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter_Update=class StorableWsRouter_Update extends _.WebSocket.WsEvent {\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName;\n    }\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/{id:number}/Update`;\n    }\n}\nWebSocket.StorableWsRouter_Update.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter_Update', WebSocket.StorableWsRouter_Update);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter_Update","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter_GetByIds=class StorableWsRouter_GetByIds extends _.WebSocket.WsEvent {\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName;\n    }\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/getbyids`;\n    }\n}\nWebSocket.StorableWsRouter_GetByIds.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter_GetByIds', WebSocket.StorableWsRouter_GetByIds);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetByIds","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter_GetById=class StorableWsRouter_GetById extends _.WebSocket.WsEvent {\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName;\n    }\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/{id:number}`;\n    }\n}\nWebSocket.StorableWsRouter_GetById.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter_GetById', WebSocket.StorableWsRouter_GetById);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetById","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRoute_CreateMany=class StorableWsRoute_CreateMany extends _.WebSocket.WsEvent {\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/CreateMany`;\n    }\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName ?? (() => \"\");\n    }\n}\nWebSocket.StorableWsRoute_CreateMany.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRoute_CreateMany', WebSocket.StorableWsRoute_CreateMany);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRoute_CreateMany","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter_Create=class StorableWsRouter_Create extends _.WebSocket.WsEvent {\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName;\n    }\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}/Create`;\n    }\n}\nWebSocket.StorableWsRouter_Create.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter_Create', WebSocket.StorableWsRouter_Create);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter_Create","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter_GetAll=class StorableWsRouter_GetAll extends _.WebSocket.WsEvent {\n    StorableName;\n    constructor(endpoint, getPrefix, StorableName) {\n        super(endpoint, getPrefix);\n        this.StorableName = StorableName;\n    }\n    /**\n     * @inheritdoc\n     */\n    path() {\n        return `${this.getPrefix()}/${this.StorableName()}`;\n    }\n}\nWebSocket.StorableWsRouter_GetAll.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter_GetAll', WebSocket.StorableWsRouter_GetAll);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":true},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetAll","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.Router=class Router {\n    endpoint;\n    events;\n    constructor(endpoint) {\n        this.endpoint = endpoint ?? _.WebSocket.EndPoint.getInstance();\n        this.events = this.defineEvents();\n        for (let key in this.events) {\n            this.events[key].init();\n        }\n    }\n    getPrefix() {\n        return \"\";\n    }\n    defineEvents() {\n        return {};\n    }\n}\nWebSocket.Router.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'Router', WebSocket.Router);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.RouterRoutes","isStrong":false},{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false},{"fullName":"Partial","isStrong":false}],"fullName":"AventusSharp.WebSocket.Router","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.StorableWsRouter=class StorableWsRouter extends _.WebSocket.Router {\n    defineEvents() {\n        return {\n            ...super.defineEvents(),\n            GetAll: new WebSocket.StorableWsRouter_GetAll(this.endpoint, this.getPrefix, this.StorableName),\n            Create: new WebSocket.StorableWsRouter_Create(this.endpoint, this.getPrefix, this.StorableName),\n            CreateMany: new WebSocket.StorableWsRoute_CreateMany(this.endpoint, this.getPrefix, this.StorableName),\n            GetById: new WebSocket.StorableWsRouter_GetById(this.endpoint, this.getPrefix, this.StorableName),\n            GetByIds: new WebSocket.StorableWsRouter_GetByIds(this.endpoint, this.getPrefix, this.StorableName),\n            Update: new WebSocket.StorableWsRouter_Update(this.endpoint, this.getPrefix, this.StorableName),\n            UpdateMany: new WebSocket.StorableWsRoute_UpdateMany(this.endpoint, this.getPrefix, this.StorableName),\n            Delete: new WebSocket.StorableWsRouter_Delete(this.endpoint, this.getPrefix, this.StorableName),\n            DeleteMany: new WebSocket.StorableWsRoute_DeleteMany(this.endpoint, this.getPrefix, this.StorableName),\n        };\n    }\n    async GetAll(options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}`,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async Create(body, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/Create`,\n            body: body,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async CreateMany(body, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/CreateMany`,\n            body: body,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async GetById(id, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/${id}`,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async GetByIds(body, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/getbyids`,\n            body: body,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async Update(id, body, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/${id}/Update`,\n            body: body,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async UpdateMany(body, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/UpdateMany`,\n            body: body,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async Delete(id, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/${id}/Delete`,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n    async DeleteMany(body, options = {}) {\n        const info = {\n            channel: `${this.getPrefix()}/${this.StorableName()}/DeleteMany`,\n            body: body,\n            ...options,\n        };\n        return await this.endpoint.sendMessageAndWait(info);\n    }\n}\nWebSocket.StorableWsRouter.Namespace=`AventusSharp.WebSocket`;\r\n__as1(_.WebSocket, 'StorableWsRouter', WebSocket.StorableWsRouter);\r\n","dependances":[{"fullName":"AventusSharp.WebSocket.Router","isStrong":true},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter__Routes","isStrong":false},{"fullName":"Partial","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetAll","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_Create","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRoute_CreateMany","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetById","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetByIds","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_Update","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRoute_UpdateMany","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_Delete","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRoute_DeleteMany","isStrong":false},{"fullName":"AventusSharp.WebSocket.WsRouteSendOptions","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"AventusSharp.ExtractResponse","isStrong":false},{"fullName":"AventusSharp.WebSocket.SocketSendMessageOptions","isStrong":false},{"fullName":"FormData","isStrong":false}],"fullName":"AventusSharp.WebSocket.StorableWsRouter","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"WebSocket.WsError=class WsError extends Aventus.GenericError {\n    static get Fullname() { return \"AventusSharp.WebSocket.WsError, AventusSharp\"; }\n}\nWebSocket.WsError.Namespace=`AventusSharp.WebSocket`;\r\nWebSocket.WsError.$schema={...(Aventus.GenericError?.$schema ?? {}), };\r\nAventus.Converter.register(WebSocket.WsError.Fullname, WebSocket.WsError);\r\n__as1(_.WebSocket, 'WsError', WebSocket.WsError);\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"AventusSharp.WebSocket.WsErrorCode","isStrong":true},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.WebSocket.WsError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"WebSocket.ResultWithWsError=class ResultWithWsError extends Tools.ResultWithError {\n    static get Fullname() { return \"AventusSharp.WebSocket.ResultWithWsError, AventusSharp\"; }\n}\nWebSocket.ResultWithWsError.Namespace=`AventusSharp.WebSocket`;\r\nWebSocket.ResultWithWsError.$schema={...(Tools.ResultWithError?.$schema ?? {}), };\r\nAventus.Converter.register(WebSocket.ResultWithWsError.Fullname, WebSocket.ResultWithWsError);\r\n__as1(_.WebSocket, 'ResultWithWsError', WebSocket.ResultWithWsError);\r\n","dependances":[{"fullName":"AventusSharp.Tools.ResultWithError","isStrong":true},{"fullName":"AventusSharp.WebSocket.WsError","isStrong":false},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.WebSocket.ResultWithWsError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"WebSocket.VoidWithWsError=class VoidWithWsError extends Tools.VoidWithError {\n    static get Fullname() { return \"AventusSharp.WebSocket.VoidWithWsError, AventusSharp\"; }\n}\nWebSocket.VoidWithWsError.Namespace=`AventusSharp.WebSocket`;\r\nWebSocket.VoidWithWsError.$schema={...(Tools.VoidWithError?.$schema ?? {}), };\r\nAventus.Converter.register(WebSocket.VoidWithWsError.Fullname, WebSocket.VoidWithWsError);\r\n__as1(_.WebSocket, 'VoidWithWsError', WebSocket.VoidWithWsError);\r\n","dependances":[{"fullName":"AventusSharp.Tools.VoidWithError","isStrong":true},{"fullName":"AventusSharp.WebSocket.WsError","isStrong":false},{"fullName":"Convertible","isStrong":false}],"fullName":"AventusSharp.WebSocket.VoidWithWsError","required":false,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"RAM.RamCompletor=class RamCompletor {\n    objects = [];\n    fields = [];\n    error;\n    constructor(objects, error) {\n        if (!objects) {\n            objects = [];\n        }\n        else if (!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        this.objects = objects;\n        this.error = error;\n    }\n    add(field) {\n        this.fields.push(field);\n        return this;\n    }\n    async run() {\n        const objects = this.objects;\n        const fields = this.fields;\n        const result = new Aventus.VoidWithError();\n        if (objects.length == 0)\n            return result;\n        const listIds = {};\n        const mapRecords = {};\n        for (let field of fields) {\n            let objKey = field.obj;\n            let idKey = field.id;\n            listIds[objKey] = [];\n            mapRecords[objKey] = {};\n            for (let value of objects) {\n                if (value[idKey]) {\n                    const listId = listIds[objKey];\n                    const mapRecord = mapRecords[objKey];\n                    if (value[objKey])\n                        continue;\n                    if (!listId.includes(value[idKey]))\n                        listId.push(value[idKey]);\n                    if (!mapRecord[value[idKey]]) {\n                        mapRecord[value[idKey]] = [];\n                    }\n                    mapRecord[value[idKey]].push(value);\n                }\n            }\n        }\n        for (let field of fields) {\n            let objKey = field.obj;\n            if (!listIds[objKey] || !mapRecords[objKey])\n                continue;\n            const listId = listIds[objKey];\n            const mapRecord = mapRecords[objKey];\n            if (listId.length > 0) {\n                const ram = Aventus.Instance.get(field.ram);\n                const query = await ram.getByIdsWithError(listId);\n                if (query.success && query.result) {\n                    for (let item of query.result) {\n                        if (mapRecord[item.Id]) {\n                            for (let record of mapRecord[item.Id]) {\n                                record[objKey] = item;\n                            }\n                        }\n                    }\n                }\n                else {\n                    result.errors = [...result.errors, ...query.errors];\n                    if (this.error) {\n                        this.error.errors = [...this.error.errors, ...query.errors];\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nRAM.RamCompletor.Namespace=`AventusSharp.RAM`;\r\n__as1(_.RAM, 'RamCompletor', RAM.RamCompletor);\r\n","dependances":[{"fullName":"AventusSharp.Data.Storable","isStrong":false},{"fullName":"AventusSharp.RAM.ItemField","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"AventusSharp.RAM.RamCompletor","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false}],"fullName":"AventusSharp.RAM.RamCompletor","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"RAM.RamHttp=class RamHttp extends Aventus.Ram {\n    getAllDone = false;\n    routes;\n    constructor() {\n        super();\n        this.routes = this.defineRoutes();\n    }\n    async beforeGetAll(result) {\n        if (!this.getAllDone) {\n            let response = await this.routes.GetAll();\n            if (response.success && response.result) {\n                for (let item of response.result) {\n                    let resultTemp = new Aventus.ResultRamWithError();\n                    await this.addOrUpdateData(item, resultTemp);\n                    if (!resultTemp.success) {\n                        result.errors = [...result.errors, ...resultTemp.errors];\n                    }\n                }\n                this.getAllDone = true;\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    async beforeGetById(id, result) {\n        if (this.records.has(id)) {\n            return;\n        }\n        else {\n            let response = await this.routes.GetById(id);\n            if (response.success && response.result) {\n                let resultTemp = new Aventus.ResultRamWithError();\n                await this.addOrUpdateData(response.result, resultTemp);\n                if (!resultTemp.success) {\n                    result.errors = [...result.errors, ...resultTemp.errors];\n                }\n                else {\n                    result.result = resultTemp.result;\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    async beforeGetByIds(ids, result) {\n        let missingIds = [];\n        for (let id of ids) {\n            if (!this.records.has(id)) {\n                missingIds.push(id);\n            }\n        }\n        if (missingIds.length > 0) {\n            result.result = [];\n            let response = await this.routes.GetByIds({ ids: missingIds });\n            if (response.success && response.result) {\n                for (let item of response.result) {\n                    let resultTemp = new Aventus.ResultRamWithError();\n                    await this.addOrUpdateData(item, resultTemp);\n                    if (!resultTemp.success || !resultTemp.result) {\n                        result.errors = [...result.errors, ...resultTemp.errors];\n                    }\n                    else if (!result.result.includes(resultTemp.result)) {\n                        result.result.push(resultTemp.result);\n                    }\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    complete(objects, error) {\n        return new _.RAM.RamCompletor(objects, error);\n    }\n    async beforeCreateItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let response = await this.routes.Create({ item });\n        if (response.success && response.result) {\n            result.result = this.getObjectForRam(response.result);\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async beforeCreateList(list, result) {\n        let response = await this.routes.CreateMany({ list });\n        if (response.success && response.result) {\n            result.result = [];\n            for (let element of response.result) {\n                result.result.push(this.getObjectForRam(element));\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async beforeUpdateItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let response = await this.routes.Update(item.Id, { item });\n        if (response.success && response.result) {\n            result.result = this.getObjectForRam(response.result);\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async beforeUpdateList(list, result) {\n        let response = await this.routes.UpdateMany({ list });\n        if (response.success && response.result) {\n            result.result = [];\n            for (let element of response.result) {\n                result.result.push(this.getObjectForRam(element));\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async beforeDeleteItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let response = await this.routes.Delete(item.Id);\n        if (!response.success) {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async beforeDeleteList(list, result) {\n        let response = await this.routes.DeleteMany({ ids: list.map(t => t.Id) });\n        if (!response.success) {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n}\nRAM.RamHttp.Namespace=`AventusSharp.RAM`;\r\n__as1(_.RAM, 'RamHttp', RAM.RamHttp);\r\n","dependances":[{"fullName":"Aventus.Ram","isStrong":true},{"fullName":"AventusSharp.Data.Storable","isStrong":false},{"fullName":"AventusSharp.Routes.StorableRouter","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"AventusSharp.RAM.RamCompletor","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false}],"fullName":"AventusSharp.RAM.RamHttp","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"RAM.RamWebSocket=class RamWebSocket extends Aventus.Ram {\n    getAllDone = false;\n    routes;\n    otherGetAllLocked = {};\n    otherGetByIdLocked = {};\n    otherCreateItemLocked = {};\n    otherCreateListLocked = {};\n    otherUpdateItemLocked = {};\n    otherUpdateListLocked = {};\n    otherDeleteItemLocked = {};\n    otherDeleteListLocked = {};\n    constructor() {\n        super();\n        this.routes = this.defineRoutes();\n        this.addEventsBindings();\n        this.otherGetAll = this.otherGetAll.bind(this);\n        this.otherGetById = this.otherGetById.bind(this);\n        this.otherCreateItem = this.otherCreateItem.bind(this);\n        this.otherCreateList = this.otherCreateList.bind(this);\n        this.otherUpdateItem = this.otherUpdateItem.bind(this);\n        this.otherUpdateList = this.otherUpdateList.bind(this);\n        this.otherDeleteItem = this.otherDeleteItem.bind(this);\n        this.otherDeleteList = this.otherDeleteList.bind(this);\n    }\n    addEventsBindings() {\n        const autoListen = this.listenOnStart();\n        this.routes.events.GetAll.onTrigger.add(this.otherGetAll, this);\n        if (autoListen.GetAll) {\n            this.routes.events.GetAll.listen();\n        }\n        else {\n            this.routes.events.GetAll.stop();\n        }\n        this.routes.events.GetById.onTrigger.add(this.otherGetById, this);\n        if (autoListen.GetById) {\n            this.routes.events.GetById.listen();\n        }\n        else {\n            this.routes.events.GetById.stop();\n        }\n        this.routes.events.Create.onTrigger.add(this.otherCreateItem, this);\n        if (autoListen.Create) {\n            this.routes.events.Create.listen();\n        }\n        else {\n            this.routes.events.Create.stop();\n        }\n        this.routes.events.CreateMany.onTrigger.add(this.otherCreateList, this);\n        if (autoListen.CreateMany) {\n            this.routes.events.CreateMany.listen();\n        }\n        else {\n            this.routes.events.CreateMany.stop();\n        }\n        this.routes.events.Update.onTrigger.add(this.otherUpdateItem, this);\n        if (autoListen.Update) {\n            this.routes.events.Update.listen();\n        }\n        else {\n            this.routes.events.Update.stop();\n        }\n        this.routes.events.UpdateMany.onTrigger.add(this.otherUpdateList, this);\n        if (autoListen.UpdateMany) {\n            this.routes.events.UpdateMany.listen();\n        }\n        else {\n            this.routes.events.UpdateMany.stop();\n        }\n        this.routes.events.Delete.onTrigger.add(this.otherDeleteItem, this);\n        if (autoListen.Delete) {\n            this.routes.events.Delete.listen();\n        }\n        else {\n            this.routes.events.Delete.stop();\n        }\n        this.routes.events.DeleteMany.onTrigger.add(this.otherDeleteList, this);\n        if (autoListen.DeleteMany) {\n            this.routes.events.DeleteMany.listen();\n        }\n        else {\n            this.routes.events.DeleteMany.stop();\n        }\n    }\n    listenOnStart() {\n        return {\n            GetAll: false,\n            GetById: false,\n            Create: true,\n            CreateMany: true,\n            Update: true,\n            UpdateMany: true,\n            Delete: true,\n            DeleteMany: true,\n        };\n    }\n    complete(objects, error) {\n        return new _.RAM.RamCompletor(objects, error);\n    }\n    async otherGetAll(items, params, uid) {\n        if (uid && this.otherGetAllLocked[uid])\n            return;\n        for (let item of items) {\n            let resultTemp = new Aventus.ResultRamWithError();\n            await this.addOrUpdateData(item, resultTemp);\n        }\n    }\n    async beforeGetAll(result) {\n        if (!this.getAllDone) {\n            let uid = Aventus.uuidv4();\n            this.otherGetAllLocked[uid] = true;\n            let response = await this.routes.GetAll({ uid });\n            delete this.otherGetAllLocked[uid];\n            if (!response)\n                return;\n            if (response.success && response.result) {\n                for (let item of response.result) {\n                    let resultTemp = new Aventus.ResultRamWithError();\n                    await this.addOrUpdateData(item, resultTemp);\n                    if (!resultTemp.success) {\n                        result.errors = [...result.errors, ...resultTemp.errors];\n                    }\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    async otherGetById(item, params, uid) {\n        if (uid && this.otherGetByIdLocked[uid])\n            return;\n        let resultTemp = new Aventus.ResultRamWithError();\n        await this.addOrUpdateData(item, resultTemp);\n    }\n    async beforeGetById(id, result) {\n        if (this.records.has(id)) {\n            return;\n        }\n        else {\n            let uid = Aventus.uuidv4();\n            this.otherGetByIdLocked[uid] = true;\n            let response = await this.routes.GetById(id, { uid });\n            delete this.otherGetByIdLocked[uid];\n            if (!response)\n                return;\n            if (response.success && response.result) {\n                let resultTemp = new Aventus.ResultRamWithError();\n                await this.addOrUpdateData(response.result, resultTemp);\n                if (!resultTemp.success) {\n                    result.errors = [...result.errors, ...resultTemp.errors];\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    async beforeGetByIds(ids, result) {\n        let missingIds = [];\n        for (let id of ids) {\n            if (!this.records.has(id)) {\n                missingIds.push(id);\n            }\n        }\n        if (missingIds.length > 0) {\n            let response = await this.routes.GetByIds({ ids: missingIds });\n            if (response.success && response.result) {\n                for (let item of response.result) {\n                    let resultTemp = new Aventus.ResultRamWithError();\n                    await this.addOrUpdateData(item, resultTemp);\n                    if (!resultTemp.success) {\n                        result.errors = [...result.errors, ...resultTemp.errors];\n                    }\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    async otherCreateItem(item, params, uid) {\n        if (uid && this.otherCreateItemLocked[uid])\n            return;\n        let resultTemp = new Aventus.ResultRamWithError();\n        await this.addOrUpdateData(item, resultTemp);\n        if (resultTemp.success && resultTemp.result) {\n            this.publish('created', resultTemp.result);\n        }\n    }\n    async beforeCreateItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let uid = Aventus.uuidv4();\n        this.otherCreateItemLocked[uid] = true;\n        let response = await this.routes.Create({ item }, { uid });\n        delete this.otherCreateItemLocked[uid];\n        if (response.success && response.result) {\n            result.result = this.getObjectForRam(response.result);\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async otherCreateList(items, params, uid) {\n        if (uid && this.otherCreateListLocked[uid])\n            return;\n        for (let item of items) {\n            let resultTemp = new Aventus.ResultRamWithError();\n            await this.addOrUpdateData(item, resultTemp);\n            if (resultTemp.success && resultTemp.result) {\n                this.publish('created', resultTemp.result);\n            }\n        }\n    }\n    async beforeCreateList(list, result) {\n        let uid = Aventus.uuidv4();\n        this.otherCreateListLocked[uid] = true;\n        let response = await this.routes.CreateMany({ list }, { uid });\n        delete this.otherCreateListLocked[uid];\n        if (response.success && response.result) {\n            result.result = [];\n            for (let element of response.result) {\n                result.result.push(this.getObjectForRam(element));\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async otherUpdateItem(item, params, uid) {\n        if (uid && this.otherUpdateItemLocked[uid])\n            return;\n        let resultTemp = new Aventus.ResultRamWithError();\n        await this.addOrUpdateData(item, resultTemp);\n        if (resultTemp.success && resultTemp.result) {\n            this.publish('updated', resultTemp.result);\n        }\n    }\n    async beforeUpdateItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let uid = Aventus.uuidv4();\n        this.otherUpdateItemLocked[uid] = true;\n        let response = await this.routes.Update(item.Id, { item }, { uid });\n        delete this.otherUpdateItemLocked[uid];\n        if (response.success && response.result) {\n            result.result = this.getObjectForRam(response.result);\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    async otherUpdateList(items, params, uid) {\n        if (uid && this.otherUpdateListLocked[uid])\n            return;\n        for (let item of items) {\n            let resultTemp = new Aventus.ResultRamWithError();\n            await this.addOrUpdateData(item, resultTemp);\n            if (resultTemp.success && resultTemp.result) {\n                this.publish('updated', resultTemp.result);\n            }\n        }\n    }\n    async beforeUpdateList(list, result) {\n        let uid = Aventus.uuidv4();\n        this.otherUpdateListLocked[uid] = true;\n        let response = await this.routes.UpdateMany({ list }, { uid });\n        delete this.otherUpdateListLocked[uid];\n        if (response.success && response.result) {\n            result.result = [];\n            for (let element of response.result) {\n                result.result.push(this.getObjectForRam(element));\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    otherDeleteItem(item, params, uid) {\n        if (uid && this.otherDeleteItemLocked[uid])\n            return;\n        let resultTemp = new Aventus.ResultRamWithError();\n        this.deleteData(item, resultTemp);\n        if (resultTemp.success && resultTemp.result) {\n            this.publish('deleted', resultTemp.result);\n            this.recordsSubscribers.delete(resultTemp.result.Id);\n        }\n    }\n    async beforeDeleteItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let uid = Aventus.uuidv4();\n        this.otherDeleteItemLocked[uid] = true;\n        let response = await this.routes.Delete(item.Id, { uid });\n        delete this.otherDeleteItemLocked[uid];\n        if (!response.success) {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    otherDeleteList(items, params, uid) {\n        if (uid && this.otherDeleteListLocked[uid])\n            return;\n        for (let item of items) {\n            let resultTemp = new Aventus.ResultRamWithError();\n            this.deleteData(item, resultTemp);\n            if (resultTemp.success && resultTemp.result) {\n                this.publish('deleted', resultTemp.result);\n                this.recordsSubscribers.delete(resultTemp.result.Id);\n            }\n        }\n    }\n    async beforeDeleteList(list, result) {\n        let uid = Aventus.uuidv4();\n        this.otherDeleteListLocked[uid] = true;\n        let response = await this.routes.DeleteMany({ ids: list.map(t => t.Id) }, { uid });\n        delete this.otherDeleteListLocked[uid];\n        if (!response.success) {\n            result.errors = [...result.errors, ...response.errors];\n        }\n    }\n    /**\n    * Delete element inside Ram without firing delete event\n    */\n    deleteData(item, result) {\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success && idWithError.result !== undefined) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    result.result = this.records.get(id);\n                    this.records.delete(id);\n                }\n                else {\n                    result.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"can't delete the item \" + id + \" because it wasn't found inside ram\"));\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n            }\n        }\n        catch (e) {\n            result.errors.push(new Aventus.RamError(Aventus.RamErrorCode.unknow, e));\n        }\n    }\n}\nRAM.RamWebSocket.Namespace=`AventusSharp.RAM`;\r\n__as1(_.RAM, 'RamWebSocket', RAM.RamWebSocket);\r\n","dependances":[{"fullName":"Aventus.Ram","isStrong":true},{"fullName":"AventusSharp.Data.Storable","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter","isStrong":false},{"fullName":"AventusSharp.RAM.RamWebSocketListenOnStart","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"AventusSharp.RAM.RamCompletor","isStrong":false},{"fullName":"BindThis","isStrong":false},{"fullName":"Aventus.ExtractFromError","isStrong":false},{"fullName":"Aventus.UriParams","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.uuidv4","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false}],"fullName":"AventusSharp.RAM.RamWebSocket","required":false,"type":1,"isExported":true,"convertibleName":""}],"existing":[{"fullName":"AventusSharp.WebSocket.WsRouterOptions","dependances":[]},{"fullName":"AventusSharp.RAM.RamWebSocketListenOnStart","dependances":[]},{"fullName":"AventusSharp.RAM.KeysOfType","dependances":[{"fullName":"T","isStrong":false},{"fullName":"NonNullable","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"K","isStrong":false}]},{"fullName":"AventusSharp.RAM.NumberKeys","dependances":[{"fullName":"T","isStrong":false},{"fullName":"K","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.WsRouteSendOptions","dependances":[]},{"fullName":"AventusSharp.WebSocket.SocketMessage","dependances":[]},{"fullName":"AventusSharp.WebSocket.SocketSendMessageOptions","dependances":[]},{"fullName":"AventusSharp.WebSocket.SocketRoute","dependances":[{"fullName":"Aventus.UriParamsValue","isStrong":false}]},{"fullName":"AventusSharp.Data.IStorableTimestamp","dependances":[{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Date","isStrong":false}]},{"fullName":"AventusSharp.Tools.IWithError","dependances":[{"fullName":"Aventus.GenericError","isStrong":false}]},{"fullName":"AventusSharp.Tools.IResultWithError","dependances":[{"fullName":"AventusSharp.Tools.IWithError","isStrong":true},{"fullName":"Aventus.GenericError","isStrong":false}]},{"fullName":"AventusSharp.RealDate","dependances":[{"fullName":"Date","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.InternalSocketRoute","dependances":[{"fullName":"AventusSharp.WebSocket.SocketRoute","isStrong":false},{"fullName":"Aventus.PreparedUri","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.ConnectionOptions","dependances":[{"fullName":"AventusSharp.WebSocket.InternalSocketRoute","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.WsEndPointType","dependances":[{"fullName":"AventusSharp.WebSocket.EndPoint","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.ExtractResultFrom","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"U","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.WsEventType","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":false}]},{"fullName":"AventusSharp.ExtractResponse","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"Aventus.ExtractFromError","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.RouterRoutes","dependances":[{"fullName":"AventusSharp.WebSocket.WsEvent","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.WsRouterType","dependances":[{"fullName":"AventusSharp.WebSocket.Router","isStrong":false}]},{"fullName":"AventusSharp.WebSocket.StorableWsRouter__Routes","dependances":[{"fullName":"Aventus.IData","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetAll","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_Create","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRoute_CreateMany","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetById","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_GetByIds","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_Update","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRoute_UpdateMany","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRouter_Delete","isStrong":false},{"fullName":"AventusSharp.WebSocket.StorableWsRoute_DeleteMany","isStrong":false}]},{"fullName":"AventusSharp.RAM.ItemField","dependances":[{"fullName":"Aventus.IData","isStrong":false},{"fullName":"AventusSharp.RAM.NumberKeys","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"AventusSharp.RAM.KeysOfType","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"Ram","isStrong":false}]}]}
//#endregion js src //
//#region css def //
{}
//#endregion css def //
//#region css //
{}
//#endregion css //
//#region html //
{}
//#endregion html //
//#region dependances //
{}
//#endregion dependances //
