// AventusPhp@Main:1.0.0
//#region js def //
declare global {

namespace AventusPhp{
@Required()
@Convertible()
class LaravelResult<T> extends Aventus.ResultWithError<T> {
    static get Fullname(): string;
}

enum LaraventusErrorEnum {
    AuthenticationError = 401,
    ValidationError = 422,
    UnknowError = 500
}

class IdsManyRequest {
    ids: any[];
}

class ItemsManyRequest<T extends Aventus.IData = Aventus.IData> {
    items: T[];
}

abstract class AventusFile<T = any> {
    static get Fullname(): string;
    uri: string;
    upload?: File;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    get $type(): string;
    /**
     * @inerhit
     */
    toJSON(): any;
}

abstract class AventusImage<T = any> extends AventusFile<T> {
    static get Fullname(): string;
}

@Required()
@Convertible()
class AventusError<T extends (number | Aventus.Enum) = any> extends Aventus.GenericError<T> {
    static get Fullname(): string;
}

abstract class ModelController<T extends Aventus.IData, U extends object = any, R extends object = any, S extends R = R> extends Aventus.HttpRoute {

    abstract getUri(): string;
    abstract getRequest(): new () => U;
    abstract getResource(): new () => R;
    getResourceDetails(): (new () => S) | undefined;
    @BindThis()
	index(): Promise<Aventus.ResultWithError<R[]>>;
    @BindThis()
	store(body: U): Promise<Aventus.ResultWithError<S>>;
    @BindThis()
	storeMany(body: U[]): Promise<Aventus.ResultWithError<S[]>>;
    @BindThis()
	show(id: string | number): Promise<Aventus.ResultWithError<S>>;
    @BindThis()
	showMany(ids: (string | number)[]): Promise<Aventus.ResultWithError<S[]>>;
    @BindThis()
	update(id: string | number, body: U): Promise<Aventus.ResultWithError<S>>;
    @BindThis()
	updateMany(body: U[]): Promise<Aventus.ResultWithError<S[]>>;
    @BindThis()
	destroy(id: string | number): Promise<Aventus.ResultWithError<boolean>>;
    @BindThis()
	destroyMany(ids: (string | number)[]): Promise<Aventus.ResultWithError<boolean>>;
    toRequest(resource: R | S): U;
}

type RamHttpResource<C> = C extends ModelController<any, any, infer Res, any> ? Res : never;

type RamHttpRequest<C> = C extends ModelController<any, infer Req, any, any> ? Req : never;

type RamHttpData<C> = C extends ModelController<infer D, any, any, any> ? D & {
    id: string | number;
} : never;

type RamHttpResourceDetails<C> = C extends ModelController<any, any, any, infer Res> ? Res : never;

class RamCompletor<T extends Aventus.IRamData> {
    protected objects: T[];
    protected fields: ___AventusPhp.ItemField<T, any>[];
    protected error?: Aventus.VoidWithError;
    constructor(objects?: T | T[], error?: Aventus.VoidWithError);
    add<U extends Aventus.IData>(field: ___AventusPhp.ItemField<T, U>): RamCompletor<T>;
    run(): Promise<Aventus.VoidWithError>;
}

abstract class GenericRamHttp<Index extends string | number, C extends ModelController<any, any, any, any>> implements Aventus.IRam {
    /**
     * The current namespace
     */
    static Namespace: string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    private subscribers;
    protected recordsSubscribers: Map<Index, ___AventusPhp.RamSubscribers<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    /**
     * List of stored item by index key
     */
    protected records: Map<Index, Aventus.RamItem<RamHttpResourceDetails<C>>>;
    protected actionGuard: Aventus.ActionGuard;
    protected routes: ModelController<RamHttpData<C>, RamHttpRequest<C>, RamHttpResource<C>, RamHttpResourceDetails<C>>;
    protected getAllDone: boolean;
    protected getByIdDone: Index[];
    protected hasDetails: boolean;
    protected constructor();
    abstract defineRoutes(): C;
    /**
     * Define the field where the index key is location
     * Example : 'id';
     */
    abstract defineIndexKey(): keyof RamHttpResourceDetails<C>;
    /**
     * Get item id
     */
    @BindThis()
	getIdWithError(item: Aventus.KeysObject<RamHttpResourceDetails<C>> | RamHttpResourceDetails<C>): Aventus.ResultRamWithError<Index>;
    /**
     * Get item id
     */
    @BindThis()
	getId(item: Aventus.KeysObject<RamHttpResourceDetails<C>> | RamHttpResourceDetails<C>): Index;
    private isResource;
    toRequest(resource: RamHttpResource<C> | RamHttpResourceDetails<C>): RamHttpRequest<C>;
    /**
     * Prevent adding Watch element
     */
    protected removeWatch<X>(element: X): X;
    /**
     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete
     */
    protected addRamAction<B extends (new (...args: any[]) => Aventus.IRamData) & {
        className?: string;
    }>(Base: B): {
        new (...args: any[]): Aventus.IRamData;
        readonly className: string;
    } & B;
    protected getTypeForData(objJson: Aventus.KeysObject<RamHttpResourceDetails<C>> | RamHttpResourceDetails<C>): new () => RamHttpResourceDetails<C>;
    /**
     * Transform the object into the object stored inside Ram
     */
    protected getObjectForRam(objJson: Aventus.KeysObject<RamHttpResourceDetails<C>> | RamHttpResourceDetails<C>): Aventus.RamItem<RamHttpResourceDetails<C>>;
    /**
     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced
     */
    protected addOrUpdateData(item: Aventus.KeysObject<RamHttpResourceDetails<C>>, result: Aventus.ResultWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>, options?: Aventus.JsonFromOptions): Promise<'created' | 'updated' | null>;
    /**
     * Merge object and create real instance of class
     */
    protected mergeObject(item: RamHttpResourceDetails<C> | undefined, objJson: Aventus.KeysObject<RamHttpResourceDetails<C>> | RamHttpResourceDetails<C>, options?: Aventus.JsonFromOptions): void;
    /**
     * Create or update the item
     */
    @BindThis()
	save(item: RamHttpRequest<C>, ...args: any[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
     * Create or update the item
     */
    @BindThis()
	saveWithError(item: RamHttpRequest<C>, ...args: any[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    protected beforeRecordSet(item: Aventus.RamItem<RamHttpResourceDetails<C>>): Promise<void>;
    protected afterRecordSet(item: Aventus.RamItem<RamHttpResourceDetails<C>>): Promise<void>;
    protected beforeRecordDelete(item: Aventus.RamItem<RamHttpResourceDetails<C>>): Promise<void>;
    protected afterRecordDelete(item: Aventus.RamItem<RamHttpResourceDetails<C>>): Promise<void>;
    protected publish(type: 'created' | 'updated' | 'deleted', data: Aventus.RamItem<RamHttpResourceDetails<C>>): void;
    private subscribe;
    private unsubscribe;
    /**
    * Add a callback that ll be triggered when a new item is stored
    */
    @BindThis()
	onCreated(cb: (item: Aventus.RamItem<RamHttpResourceDetails<C>>) => void): void;
    /**
     * Remove a created callback
     */
    @BindThis()
	offCreated(cb: (item: Aventus.RamItem<RamHttpResourceDetails<C>>) => void): void;
    /**
     * Add a callback that ll be triggered when an item is updated
     */
    @BindThis()
	onUpdated(cb: (item: Aventus.RamItem<RamHttpResourceDetails<C>>) => void): void;
    /**
     * Remove an updated callback
     */
    @BindThis()
	offUpdated(cb: (item: Aventus.RamItem<RamHttpResourceDetails<C>>) => void): void;
    /**
     * Add a callback that ll be triggered when an item is deleted
     */
    @BindThis()
	onDeleted(cb: (item: Aventus.RamItem<RamHttpResourceDetails<C>>) => void): void;
    /**
     * Remove an deleted callback
     */
    @BindThis()
	offDeleted(cb: (item: Aventus.RamItem<RamHttpResourceDetails<C>>) => void): void;
    /**
     * Get an item by id if exist (alias for getById)
     */
    @BindThis()
	get(id: Index): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
     * Get an item by id if exist (alias for getById)
     */
    @BindThis()
	getWithError(id: Index): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    /**
     * Get an item by id if exist
     */
    @BindThis()
	getById(id: Index): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
     * Get an item by id if exist
     */
    @BindThis()
	getByIdWithError(id: Index): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    protected queryGetById(id: Index, result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>): Promise<void>;
    /**
     * Trigger before getting an item by id
     */
    protected beforeGetById(id: Index, result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>): Promise<void>;
    /**
     * Trigger after getting an item by id
     */
    protected afterGetById(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>): Promise<void>;
    /**
     * Get multiple items by ids
     */
    @BindThis()
	getByIds(ids: Index[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>>[]>;
    /**
     * Get multiple items by ids
     */
    @BindThis()
	getByIdsWithError(ids: Index[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>>;
    protected queryGetByIds(ids: Index[], result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>): Promise<void>;
    /**
     * Trigger before getting a list of items by id
     */
    protected beforeGetByIds(ids: Index[], result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>): Promise<void>;
    /**
     * Trigger after getting a list of items by id
     */
    protected afterGetByIds(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>): Promise<void>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getAll(): Promise<Map<Index, Aventus.RamItem<RamHttpResource<C>>>>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getAllWithError(): Promise<Aventus.ResultRamWithError<Map<Index, Aventus.RamItem<RamHttpResource<C>>>>>;
    protected queryGetAll(result: Aventus.ResultRamWithError<Map<Index, Aventus.RamItem<RamHttpResource<C>>>>): any;
    /**
     * Trigger before getting all items inside Ram
     */
    protected beforeGetAll(result: Aventus.ResultRamWithError<Map<Index, Aventus.RamItem<RamHttpResource<C>>>>): Promise<void>;
    /**
     * Trigger after getting all items inside Ram
     */
    protected afterGetAll(result: Aventus.ResultRamWithError<Map<Index, Aventus.RamItem<RamHttpResource<C>>>>): Promise<void>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getList(): Promise<Aventus.RamItem<RamHttpResource<C>>[]>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getListWithError(): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResource<C>>[]>>;
    /**
     * Create a list of items inside ram
     */
    @BindThis()
	createList(list: RamHttpRequest<C>[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>>[]>;
    /**
     * Create a list of items inside ram
     */
    @BindThis()
	createListWithError(list: RamHttpRequest<C>[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>>;
    /**
     * Create an item inside ram
     */
    @BindThis()
	create(item: RamHttpRequest<C>, ...args: any[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
     * Create an item inside ram
     */
    @BindThis()
	createWithError(item: RamHttpRequest<C>, ...args: any[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    private _create;
    protected queryCreateList(list: RamHttpRequest<C>[], resultTemp: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpRequest<C>>[]>): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>>;
    /**
     * Trigger before creating a list of items
     */
    protected beforeCreateList(list: RamHttpRequest<C>[], result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpRequest<C>>[]>): Promise<void>;
    protected queryCreateItem(item: RamHttpRequest<C>, fromList: boolean, resultTemp: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpRequest<C>>>): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    /**
     * Trigger before creating an item
     */
    protected beforeCreateItem(item: RamHttpRequest<C> | RamHttpResourceDetails<C>, fromList: boolean, result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpRequest<C>>>): Promise<void>;
    /**
     * Trigger after creating an item
     */
    protected afterCreateItem(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after creating a list of items
     */
    protected afterCreateList(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>): Promise<void>;
    /**
     * Update a list of items inside ram
     */
    @BindThis()
	updateList(list: RamHttpRequest<C>[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>>[]>;
    /**
     * Update a list of items inside ram
     */
    @BindThis()
	updateListWithError(list: RamHttpRequest<C>[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>>;
    /**
     * Update an item inside ram
     */
    @BindThis()
	update(item: RamHttpRequest<C>, ...args: any[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
     * Update an item inside ram
     */
    @BindThis()
	updateWithError(item: RamHttpRequest<C>, ...args: any[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    private _update;
    protected queryUpdateList(list: RamHttpRequest<C>[], resultTemp: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpRequest<C>>[]>): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>>;
    /**
     * Trigger before updating a list of items
     */
    protected beforeUpdateList(list: RamHttpRequest<C>[], result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpRequest<C>>[]>): Promise<void>;
    protected queryUpdateItem(item: RamHttpRequest<C>, fromList: boolean, resultTemp: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    /**
    * Trigger before updating an item
    */
    protected beforeUpdateItem(item: RamHttpRequest<C> | RamHttpResourceDetails<C>, fromList: boolean, result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>): Promise<void>;
    /**
     * Trigger after updating an item
     */
    protected afterUpdateItem(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after updating a list of items
     */
    protected afterUpdateList(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>): Promise<void>;
    /**
     * Delete a list of items inside ram
     */
    @BindThis()
	deleteList(list: RamHttpResourceDetails<C>[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>>[]>;
    /**
     * Delete a list of items inside ram
     */
    @BindThis()
	deleteListWithError(list: RamHttpResourceDetails<C>[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>>;
    /**
     * Delete an item inside ram
     */
    @BindThis()
	delete(item: RamHttpResourceDetails<C>, ...args: any[]): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
    * Delete an item inside ram
    */
    @BindThis()
	deleteWithError(item: RamHttpResourceDetails<C>, ...args: any[]): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    /**
     * Delete an item by id inside ram
     */
    @BindThis()
	deleteById(id: Index): Promise<Aventus.RamItem<RamHttpResourceDetails<C>> | undefined>;
    /**
    * Delete an item by id inside ram
    */
    @BindThis()
	deleteByIdWithError(id: Index): Promise<Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>>;
    private _delete;
    protected queryDeleteList(list: RamHttpResourceDetails<C>[], result: Aventus.VoidWithError): Promise<void>;
    /**
     * Trigger before deleting a list of items
     */
    protected beforeDeleteList(list: RamHttpResourceDetails<C>[], result: Aventus.VoidWithError): Promise<void>;
    protected queryDeleteItem(item: RamHttpResourceDetails<C>, fromList: boolean, result: Aventus.VoidWithError): Promise<void>;
    /**
     * Trigger before deleting an item
     */
    protected beforeDeleteItem(item: RamHttpResourceDetails<C>, fromList: boolean, result: Aventus.VoidWithError): Promise<void>;
    /**
     * Trigger after deleting an item
     */
    protected afterDeleteItem(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after deleting a list of items
     */
    protected afterDeleteList(result: Aventus.ResultRamWithError<Aventus.RamItem<RamHttpResourceDetails<C>>[]>): Promise<void>;
}

abstract class RamHttp<C extends ModelController<any, any, any, any>> extends GenericRamHttp<number, C> {
}

	}
}
declare module ___AventusPhp {
interface RamSubscribers<T> {
    created: ((item: T) => void)[];
    updated: ((item: T) => void)[];
    deleted: ((item: T) => void)[];
}

type KeysOfType<T, U> = {
    [K in keyof T]: NonNullable<T[K]> extends U ? K : never;
}[keyof T];

type NumberKeys<T> = {
    [K in keyof T]: T[K] extends number ? K : never;
}[keyof T];

type ItemField<T extends Aventus.IRamData, U extends Aventus.IRamData> = {
    id: NumberKeys<T>;
    obj: KeysOfType<T, U>;
    ram: typeof Aventus.Ram<U>;
};
}//#endregion js def //
//#region js src //
{"namespace":"AventusPhp","available":[{"code":"let LaravelResult=class LaravelResult extends Aventus.ResultWithError {\n    static get Fullname() { return \"Aventus.Laraventus.Helpers.LaravelResult\"; }\n}\nLaravelResult.Namespace=`AventusPhp`;\r\nLaravelResult.$schema={...(Aventus.ResultWithError?.$schema ?? {}), };\r\nAventus.Converter.register(LaravelResult.Fullname, LaravelResult);\r\n__as1(_, 'LaravelResult', LaravelResult);\r\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"Convertible","isStrong":false},{"fullName":"Required","isStrong":false}],"fullName":"AventusPhp.LaravelResult","required":true,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"var LaraventusErrorEnum;\n(function (LaraventusErrorEnum) {\n    LaraventusErrorEnum[LaraventusErrorEnum[\"AuthenticationError\"] = 401] = \"AuthenticationError\";\n    LaraventusErrorEnum[LaraventusErrorEnum[\"ValidationError\"] = 422] = \"ValidationError\";\n    LaraventusErrorEnum[LaraventusErrorEnum[\"UnknowError\"] = 500] = \"UnknowError\";\n})(LaraventusErrorEnum || (LaraventusErrorEnum = {}));\n__as1(_, 'LaraventusErrorEnum', LaraventusErrorEnum);\r\n","dependances":[],"fullName":"AventusPhp.LaraventusErrorEnum","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"let IdsManyRequest=class IdsManyRequest {\n    ids = [];\n}\nIdsManyRequest.Namespace=`AventusPhp`;\r\n__as1(_, 'IdsManyRequest', IdsManyRequest);\r\n","dependances":[],"fullName":"AventusPhp.IdsManyRequest","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ItemsManyRequest=class ItemsManyRequest {\n    items;\n}\nItemsManyRequest.Namespace=`AventusPhp`;\r\n__as1(_, 'ItemsManyRequest', ItemsManyRequest);\r\n","dependances":[{"fullName":"Aventus.IData","isStrong":false}],"fullName":"AventusPhp.ItemsManyRequest","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let AventusFile=class AventusFile {\n    static get Fullname() { return \"Aventus.Laraventus.Models.AventusFile\"; }\n    uri;\n    upload;\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * @inerhit\n     */\n    toJSON() {\n        let toAvoid = ['className', 'namespace'];\n        return Aventus.Json.classToJson(this, {\n            isValidKey: (key) => !toAvoid.includes(key),\n            beforeEnd: (result) => {\n                let resultTemp = {};\n                if (result.$type) {\n                    resultTemp.$type = result.$type;\n                    for (let key in result) {\n                        if (key != '$type') {\n                            resultTemp[key] = result[key];\n                        }\n                    }\n                    return resultTemp;\n                }\n                return result;\n            }\n        });\n    }\n}\nAventusFile.Namespace=`AventusPhp`;\r\n__as1(_, 'AventusFile', AventusFile);\r\n","dependances":[{"fullName":"File","isStrong":false},{"fullName":"Aventus.Json","isStrong":false}],"fullName":"AventusPhp.AventusFile","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let AventusImage=class AventusImage extends AventusFile {\n    static get Fullname() { return \"Aventus.Laraventus.Models.AventusImage\"; }\n}\nAventusImage.Namespace=`AventusPhp`;\r\n__as1(_, 'AventusImage', AventusImage);\r\n","dependances":[{"fullName":"AventusPhp.AventusFile","isStrong":true}],"fullName":"AventusPhp.AventusImage","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let AventusError=class AventusError extends Aventus.GenericError {\n    static get Fullname() { return \"Aventus.Laraventus.Helpers.AventusError\"; }\n}\nAventusError.Namespace=`AventusPhp`;\r\nAventusError.$schema={...(Aventus.GenericError?.$schema ?? {}), };\r\nAventus.Converter.register(AventusError.Fullname, AventusError);\r\n__as1(_, 'AventusError', AventusError);\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Convertible","isStrong":false},{"fullName":"Required","isStrong":false},{"fullName":"Aventus.Enum","isStrong":false}],"fullName":"AventusPhp.AventusError","required":true,"type":1,"isExported":true,"convertibleName":"Fullname"},{"code":"let ModelController=class ModelController extends Aventus.HttpRoute {\n    constructor(router) {\n        super(router);\n        this.index = this.index.bind(this);\n        this.store = this.store.bind(this);\n        this.storeMany = this.storeMany.bind(this);\n        this.show = this.show.bind(this);\n        this.showMany = this.showMany.bind(this);\n        this.update = this.update.bind(this);\n        this.updateMany = this.updateMany.bind(this);\n        this.destroy = this.destroy.bind(this);\n        this.destroyMany = this.destroyMany.bind(this);\n    }\n    getResourceDetails() {\n        return undefined;\n    }\n    async index() {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}`, Aventus.HttpMethod.GET);\n        return await request.queryJSON(this.router);\n    }\n    async store(body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}`, Aventus.HttpMethod.POST);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async storeMany(body) {\n        const requestBody = new ItemsManyRequest();\n        requestBody.items = body;\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/many`, Aventus.HttpMethod.POST);\n        request.setBody(requestBody);\n        return await request.queryJSON(this.router);\n    }\n    async show(id) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/${id}`, Aventus.HttpMethod.GET);\n        return await request.queryJSON(this.router);\n    }\n    async showMany(ids) {\n        const requestBody = new IdsManyRequest();\n        requestBody.ids = ids;\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/show_many`, Aventus.HttpMethod.POST);\n        request.setBody(requestBody);\n        return await request.queryJSON(this.router);\n    }\n    async update(id, body) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/${id}`, Aventus.HttpMethod.PUT);\n        request.enableMethodSpoofing();\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async updateMany(body) {\n        const requestBody = new ItemsManyRequest();\n        requestBody.items = body;\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/many`, Aventus.HttpMethod.PUT);\n        request.enableMethodSpoofing();\n        request.setBody(requestBody);\n        return await request.queryJSON(this.router);\n    }\n    async destroy(id) {\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/${id}`, Aventus.HttpMethod.DELETE);\n        return await request.queryJSON(this.router);\n    }\n    async destroyMany(ids) {\n        const requestBody = new IdsManyRequest();\n        requestBody.ids = ids;\n        const request = new Aventus.HttpRequest(`${this.getPrefix()}/${this.getUri()}/many`, Aventus.HttpMethod.DELETE);\n        request.enableMethodSpoofing();\n        request.setBody(requestBody);\n        return await request.queryJSON(this.router);\n    }\n    toRequest(resource) {\n        const Request = this.getRequest();\n        const result = new Request();\n        Aventus.Json.classFromJson(result, resource, {\n            replaceUndefined: true\n        });\n        return result;\n    }\n}\nModelController.Namespace=`AventusPhp`;\r\n__as1(_, 'ModelController', ModelController);\r\n","dependances":[{"fullName":"Aventus.HttpRoute","isStrong":true},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"BindThis","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"Aventus.HttpRequest","isStrong":false},{"fullName":"Aventus.HttpMethod","isStrong":false},{"fullName":"AventusPhp.ItemsManyRequest","isStrong":false},{"fullName":"AventusPhp.IdsManyRequest","isStrong":false},{"fullName":"Aventus.Json","isStrong":false}],"fullName":"AventusPhp.ModelController","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let RamCompletor=class RamCompletor {\n    objects = [];\n    fields = [];\n    error;\n    constructor(objects, error) {\n        if (!objects) {\n            objects = [];\n        }\n        else if (!Array.isArray(objects)) {\n            objects = [objects];\n        }\n        this.objects = objects;\n        this.error = error;\n    }\n    add(field) {\n        this.fields.push(field);\n        return this;\n    }\n    async run() {\n        const objects = this.objects;\n        const fields = this.fields;\n        const result = new Aventus.VoidWithError();\n        if (objects.length == 0)\n            return result;\n        const listIds = {};\n        const mapRecords = {};\n        for (let field of fields) {\n            let objKey = field.obj;\n            let idKey = field.id;\n            listIds[objKey] = [];\n            mapRecords[objKey] = {};\n            for (let value of objects) {\n                if (value[idKey]) {\n                    const listId = listIds[objKey];\n                    const mapRecord = mapRecords[objKey];\n                    if (value[objKey])\n                        continue;\n                    if (!listId.includes(value[idKey]))\n                        listId.push(value[idKey]);\n                    if (!mapRecord[value[idKey]]) {\n                        mapRecord[value[idKey]] = [];\n                    }\n                    mapRecord[value[idKey]].push(value);\n                }\n            }\n        }\n        for (let field of fields) {\n            let objKey = field.obj;\n            if (!listIds[objKey] || !mapRecords[objKey])\n                continue;\n            const listId = listIds[objKey];\n            const mapRecord = mapRecords[objKey];\n            if (listId.length > 0) {\n                const ram = Aventus.Instance.get(field.ram);\n                const query = await ram.getByIdsWithError(listId);\n                if (query.success && query.result) {\n                    for (let item of query.result) {\n                        if (mapRecord[item.Id]) {\n                            for (let record of mapRecord[item.Id]) {\n                                record[objKey] = item;\n                            }\n                        }\n                    }\n                }\n                else {\n                    result.errors = [...result.errors, ...query.errors];\n                    if (this.error) {\n                        this.error.errors = [...this.error.errors, ...query.errors];\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nRamCompletor.Namespace=`AventusPhp`;\r\n__as1(_, 'RamCompletor', RamCompletor);\r\n","dependances":[{"fullName":"Aventus.IRamData","isStrong":false},{"fullName":"AventusPhp.ItemField","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false}],"fullName":"AventusPhp.RamCompletor","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let GenericRamHttp=class GenericRamHttp {\n    /**\n     * The current namespace\n     */\n    static Namespace = \"\";\n    // public static get Namespace(): string { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    subscribers = {\n        created: [],\n        updated: [],\n        deleted: [],\n    };\n    recordsSubscribers = new Map();\n    /**\n     * List of stored item by index key\n     */\n    records = new Map();\n    actionGuard = new Aventus.ActionGuard();\n    routes;\n    getAllDone = false;\n    getByIdDone = [];\n    hasDetails;\n    constructor() {\n        if (this.constructor == Aventus.GenericRam) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.routes = this.defineRoutes();\n        if (!this.routes.getResourceDetails()) {\n            this.hasDetails = false;\n        }\n        else {\n            this.hasDetails = this.routes.getResourceDetails() != this.routes.getResource();\n        }\n        this.getIdWithError = this.getIdWithError.bind(this);\n        this.getId = this.getId.bind(this);\n        this.save = this.save.bind(this);\n        this.saveWithError = this.saveWithError.bind(this);\n        this.onCreated = this.onCreated.bind(this);\n        this.offCreated = this.offCreated.bind(this);\n        this.onUpdated = this.onUpdated.bind(this);\n        this.offUpdated = this.offUpdated.bind(this);\n        this.onDeleted = this.onDeleted.bind(this);\n        this.offDeleted = this.offDeleted.bind(this);\n        this.get = this.get.bind(this);\n        this.getWithError = this.getWithError.bind(this);\n        this.getById = this.getById.bind(this);\n        this.getByIdWithError = this.getByIdWithError.bind(this);\n        this.getByIds = this.getByIds.bind(this);\n        this.getByIdsWithError = this.getByIdsWithError.bind(this);\n        this.getAll = this.getAll.bind(this);\n        this.getAllWithError = this.getAllWithError.bind(this);\n        this.getList = this.getList.bind(this);\n        this.getListWithError = this.getListWithError.bind(this);\n        this.createList = this.createList.bind(this);\n        this.createListWithError = this.createListWithError.bind(this);\n        this.create = this.create.bind(this);\n        this.createWithError = this.createWithError.bind(this);\n        this.updateList = this.updateList.bind(this);\n        this.updateListWithError = this.updateListWithError.bind(this);\n        this.update = this.update.bind(this);\n        this.updateWithError = this.updateWithError.bind(this);\n        this.deleteList = this.deleteList.bind(this);\n        this.deleteListWithError = this.deleteListWithError.bind(this);\n        this.delete = this.delete.bind(this);\n        this.deleteWithError = this.deleteWithError.bind(this);\n        this.deleteById = this.deleteById.bind(this);\n        this.deleteByIdWithError = this.deleteByIdWithError.bind(this);\n    }\n    /**\n     * Get item id\n     */\n    getIdWithError(item) {\n        let action = new Aventus.ResultRamWithError();\n        let idTemp = item[this.defineIndexKey()];\n        if (idTemp !== undefined) {\n            action.result = idTemp;\n        }\n        else {\n            action.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noId, \"no key found for item\"));\n        }\n        return action;\n    }\n    /**\n     * Get item id\n     */\n    getId(item) {\n        let result = this.getIdWithError(item);\n        if (result.success) {\n            return result.result;\n        }\n        throw 'no key found for item';\n    }\n    isResource(item) {\n        const ResourceType = this.routes.getResource();\n        const ResourceDetailsType = this.routes.getResourceDetails();\n        if (item instanceof ResourceType) {\n            return true;\n        }\n        if (ResourceDetailsType) {\n            return item instanceof ResourceDetailsType;\n        }\n        return false;\n    }\n    toRequest(resource) {\n        return this.routes.toRequest(resource);\n    }\n    /**\n     * Prevent adding Watch element\n     */\n    removeWatch(element) {\n        let byPass = element;\n        if (byPass.__isProxy) {\n            return byPass.getTarget();\n        }\n        return element;\n    }\n    /**\n     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete\n     */\n    addRamAction(Base) {\n        let that = this;\n        return class ActionClass extends Base {\n            static get className() {\n                return Base.className || Base.name;\n            }\n            get className() {\n                return Base.className || Base.name;\n            }\n            async update(newData) {\n                let id = that.getId(this);\n                let oldData = that.records.get(id);\n                if (oldData) {\n                    let result = await that.update(newData);\n                    return result;\n                }\n                return undefined;\n            }\n            async updateWithError(newData) {\n                const result = new Aventus.ResultRamWithError();\n                let queryId = that.getIdWithError(this);\n                if (!queryId.success || !queryId.result) {\n                    result.errors = queryId.errors;\n                    return result;\n                }\n                let oldData = that.records.get(queryId.result);\n                if (oldData) {\n                    let result = await that.updateWithError(newData);\n                    return result;\n                }\n                result.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"Can't find this item inside the ram\"));\n                return result;\n            }\n            onUpdate(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                let sub = that.recordsSubscribers.get(id);\n                if (sub && !sub.updated.includes(callback)) {\n                    sub.updated.push(callback);\n                }\n            }\n            offUpdate(callback) {\n                let id = that.getId(this);\n                let sub = that.recordsSubscribers.get(id);\n                if (sub) {\n                    let index = sub.updated.indexOf(callback);\n                    if (index != -1) {\n                        sub.updated.splice(index, 1);\n                    }\n                }\n            }\n            async delete() {\n                let id = that.getId(this);\n                await that.deleteById(id);\n            }\n            async deleteWithError() {\n                const result = new Aventus.VoidRamWithError();\n                let queryId = that.getIdWithError(this);\n                if (!queryId.success || !queryId.result) {\n                    result.errors = queryId.errors;\n                    return result;\n                }\n                const queryDelete = await that.deleteByIdWithError(queryId.result);\n                result.errors = queryDelete.errors;\n                return result;\n            }\n            onDelete(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                let sub = that.recordsSubscribers.get(id);\n                if (sub && !sub.deleted.includes(callback)) {\n                    sub.deleted.push(callback);\n                }\n            }\n            offDelete(callback) {\n                let id = that.getId(this);\n                let sub = that.recordsSubscribers.get(id);\n                if (sub) {\n                    let index = sub.deleted.indexOf(callback);\n                    if (index != -1) {\n                        sub.deleted.splice(index, 1);\n                    }\n                }\n            }\n        };\n    }\n    getTypeForData(objJson) {\n        return this.routes.getResourceDetails() ?? this.routes.getResource();\n    }\n    /**\n     * Transform the object into the object stored inside Ram\n     */\n    getObjectForRam(objJson) {\n        let T = this.addRamAction(this.getTypeForData(objJson));\n        let item = new T();\n        this.mergeObject(item, objJson);\n        return item;\n    }\n    /**\n     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced\n     */\n    async addOrUpdateData(item, result, options) {\n        let resultTemp = null;\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success && idWithError.result !== undefined) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    let uniqueRecord = this.records.get(id);\n                    await this.beforeRecordSet(uniqueRecord);\n                    this.mergeObject(uniqueRecord, item, options);\n                    await this.afterRecordSet(uniqueRecord);\n                    resultTemp = 'updated';\n                }\n                else {\n                    let realObject = this.getObjectForRam(item);\n                    await this.beforeRecordSet(realObject);\n                    this.records.set(id, realObject);\n                    await this.afterRecordSet(realObject);\n                    resultTemp = 'created';\n                }\n                result.result = this.records.get(id);\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n                resultTemp = null;\n            }\n        }\n        catch (e) {\n            result.errors.push(new Aventus.RamError(Aventus.RamErrorCode.unknow, e));\n            resultTemp = null;\n        }\n        return resultTemp;\n    }\n    /**\n     * Merge object and create real instance of class\n     */\n    mergeObject(item, objJson, options) {\n        if (!item) {\n            return;\n        }\n        if (!options) {\n            options = {\n                replaceUndefined: true\n            };\n        }\n        Aventus.Json.classFromJson(item, objJson, options);\n    }\n    /**\n     * Create or update the item\n     */\n    async save(item, ...args) {\n        let action = await this.saveWithError(item, ...args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create or update the item\n     */\n    async saveWithError(item, ...args) {\n        let action = new Aventus.ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success && resultTemp.result !== undefined) {\n            if (resultTemp.result) {\n                return this.updateWithError(item, ...args);\n            }\n            else {\n                return this.createWithError(item, ...args);\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    async beforeRecordSet(item) { }\n    async afterRecordSet(item) { }\n    async beforeRecordDelete(item) { }\n    async afterRecordDelete(item) { }\n    publish(type, data) {\n        let callbacks = [...this.subscribers[type]];\n        for (let callback of callbacks) {\n            callback(data);\n        }\n        let sub = this.recordsSubscribers.get(this.getId(data));\n        if (sub) {\n            let localCallbacks = [...sub[type]];\n            for (let localCallback of localCallbacks) {\n                localCallback(data);\n            }\n        }\n    }\n    subscribe(type, cb) {\n        if (!this.subscribers[type].includes(cb)) {\n            this.subscribers[type].push(cb);\n        }\n    }\n    unsubscribe(type, cb) {\n        let index = this.subscribers[type].indexOf(cb);\n        if (index != -1) {\n            this.subscribers[type].splice(index, 1);\n        }\n    }\n    /**\n    * Add a callback that ll be triggered when a new item is stored\n    */\n    onCreated(cb) {\n        this.subscribe('created', cb);\n    }\n    /**\n     * Remove a created callback\n     */\n    offCreated(cb) {\n        this.unsubscribe('created', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is updated\n     */\n    onUpdated(cb) {\n        this.subscribe('updated', cb);\n    }\n    /**\n     * Remove an updated callback\n     */\n    offUpdated(cb) {\n        this.unsubscribe('updated', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is deleted\n     */\n    onDeleted(cb) {\n        this.subscribe('deleted', cb);\n    }\n    /**\n     * Remove an deleted callback\n     */\n    offDeleted(cb) {\n        this.unsubscribe('deleted', cb);\n    }\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async get(id) {\n        return await this.getById(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async getWithError(id) {\n        return await this.getByIdWithError(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist\n     */\n    async getById(id) {\n        let action = await this.getByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Get an item by id if exist\n     */\n    async getByIdWithError(id) {\n        return this.actionGuard.run(['getByIdWithError', id], async () => {\n            let action = new Aventus.ResultRamWithError();\n            await this.beforeGetById(id, action);\n            await this.queryGetById(id, action);\n            if (action.success) {\n                if (this.records.has(id)) {\n                    action.result = this.records.get(id);\n                    await this.afterGetById(action);\n                }\n                else {\n                    action.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                }\n            }\n            return action;\n        });\n    }\n    async queryGetById(id, result) {\n        if (!this.hasDetails && this.records.has(id)) {\n            return;\n        }\n        if (this.hasDetails && this.getByIdDone.includes(id)) {\n            return;\n        }\n        else {\n            let response = await this.routes.show(id);\n            if (response.success && response.result) {\n                let resultTemp = new Aventus.ResultRamWithError();\n                await this.addOrUpdateData(response.result, resultTemp);\n                if (!resultTemp.success) {\n                    result.errors = [...result.errors, ...resultTemp.errors];\n                }\n                else {\n                    result.result = resultTemp.result;\n                    if (this.hasDetails) {\n                        this.getByIdDone.push(id);\n                    }\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    /**\n     * Trigger before getting an item by id\n     */\n    async beforeGetById(id, result) { }\n    ;\n    /**\n     * Trigger after getting an item by id\n     */\n    async afterGetById(result) { }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIds(ids) {\n        let result = await this.getByIdsWithError(ids);\n        if (result.success) {\n            return result.result ?? [];\n        }\n        return [];\n    }\n    /**\n     * Get multiple items by ids\n     */\n    async getByIdsWithError(ids) {\n        return this.actionGuard.run(['getByIdsWithError', ids], async () => {\n            let action = new Aventus.ResultRamWithError();\n            action.result = [];\n            await this.queryGetByIds(ids, action);\n            await this.beforeGetByIds(ids, action);\n            if (action.success) {\n                action.result = [];\n                for (let id of ids) {\n                    let rec = this.records.get(id);\n                    if (rec) {\n                        action.result.push(rec);\n                    }\n                    else {\n                        action.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                    }\n                }\n                if (action.success) {\n                    await this.afterGetByIds(action);\n                }\n            }\n            return action;\n        });\n    }\n    async queryGetByIds(ids, result) {\n        let missingIds = [];\n        if (this.hasDetails) {\n            for (let id of ids) {\n                if (!this.getByIdDone.includes(id)) {\n                    missingIds.push(id);\n                }\n            }\n        }\n        else {\n            for (let id of ids) {\n                if (!this.records.has(id)) {\n                    missingIds.push(id);\n                }\n            }\n        }\n        if (missingIds.length > 0) {\n            result.result = [];\n            let response = await this.routes.showMany(missingIds);\n            if (response.success && response.result) {\n                for (let item of response.result) {\n                    let resultTemp = new Aventus.ResultRamWithError();\n                    await this.addOrUpdateData(item, resultTemp);\n                    if (!resultTemp.success || !resultTemp.result) {\n                        result.errors = [...result.errors, ...resultTemp.errors];\n                    }\n                    else if (!result.result.includes(resultTemp.result)) {\n                        result.result.push(resultTemp.result);\n                    }\n                }\n                if (this.hasDetails) {\n                    for (let item of result.result) {\n                        this.getByIdDone.push(this.getId(item));\n                    }\n                }\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    /**\n     * Trigger before getting a list of items by id\n     */\n    async beforeGetByIds(ids, result) { }\n    ;\n    /**\n     * Trigger after getting a list of items by id\n     */\n    async afterGetByIds(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAll() {\n        let result = await this.getAllWithError();\n        if (result.success) {\n            return result.result ?? new Map();\n        }\n        return new Map();\n    }\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAllWithError() {\n        return this.actionGuard.run(['getAllWithError'], async () => {\n            let action = new Aventus.ResultRamWithError();\n            action.result = new Map();\n            await this.beforeGetAll(action);\n            await this.queryGetAll(action);\n            if (action.success) {\n                action.result = this.records;\n                await this.afterGetAll(action);\n            }\n            return action;\n        });\n    }\n    async queryGetAll(result) {\n        if (!this.getAllDone) {\n            let response = await this.routes.index();\n            if (response.success && response.result) {\n                for (let item of response.result) {\n                    let resultTemp = new Aventus.ResultRamWithError();\n                    await this.addOrUpdateData(item, resultTemp, { replaceUndefined: false });\n                    if (!resultTemp.success) {\n                        result.errors = [...result.errors, ...resultTemp.errors];\n                    }\n                }\n                this.getAllDone = true;\n            }\n            else {\n                result.errors = [...result.errors, ...response.errors];\n            }\n        }\n    }\n    /**\n     * Trigger before getting all items inside Ram\n     */\n    async beforeGetAll(result) { }\n    ;\n    /**\n     * Trigger after getting all items inside Ram\n     */\n    async afterGetAll(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getList() {\n        let data = await this.getAll();\n        return Array.from(data.values());\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getListWithError() {\n        let action = new Aventus.ResultRamWithError();\n        action.result = [];\n        let result = await this.getAllWithError();\n        if (result.success) {\n            if (result.result) {\n                action.result = Array.from(result.result.values());\n            }\n            else {\n                action.result = [];\n            }\n        }\n        else {\n            action.errors = result.errors;\n        }\n        return action;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createList(list) {\n        let result = await this.createListWithError(list);\n        return result.result ?? [];\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createListWithError(list) {\n        list = this.removeWatch(list);\n        let actionTemp = new Aventus.ResultRamWithError();\n        actionTemp.result = [];\n        await this.beforeCreateList(list, actionTemp);\n        let action = await this.queryCreateList(list, actionTemp);\n        if (!action.result) {\n            action.result = [];\n        }\n        if (action.success && action.result.length > 0) {\n            const resources = action.result;\n            action.result = [];\n            for (let resource of resources) {\n                let resultItem = await this._create(resource, true);\n                if (resultItem.success && resultItem.result) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterCreateList(action);\n            }\n        }\n        return action;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async create(item, ...args) {\n        let action = await this.createWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async createWithError(item, ...args) {\n        return await this._create(item, false);\n    }\n    async _create(item, fromList) {\n        item = this.removeWatch(item);\n        return this.actionGuard.run(['_create', item], async () => {\n            let actionTemp = new Aventus.ResultRamWithError();\n            let action;\n            await this.beforeCreateItem(item, fromList, actionTemp);\n            if (this.isResource(item)) {\n                action = new Aventus.ResultRamWithError();\n                action.errors = actionTemp.errors;\n            }\n            else {\n                action = await this.queryCreateItem(item, fromList, actionTemp);\n            }\n            if (action.success && action.result) {\n                const resource = action.result;\n                let resultTemp = this.getIdWithError(resource);\n                if (resultTemp.success) {\n                    await this.addOrUpdateData(resource, action);\n                    if (!action.success) {\n                        return action;\n                    }\n                    await this.afterCreateItem(action, fromList);\n                    if (!action.success) {\n                        action.result = undefined;\n                    }\n                    else if (action.result) {\n                        this.publish('created', resource);\n                    }\n                }\n                else {\n                    action.errors = resultTemp.errors;\n                }\n            }\n            return action;\n        });\n    }\n    async queryCreateList(list, resultTemp) {\n        const result = new Aventus.ResultRamWithError();\n        let response = await this.routes.storeMany(list);\n        if (response.success && response.result) {\n            result.result = [];\n            for (let element of response.result) {\n                result.result.push(this.getObjectForRam(element));\n            }\n            if (this.hasDetails) {\n                for (let element of result.result) {\n                    const id = this.getId(element);\n                    if (!this.getByIdDone.includes(id)) {\n                        this.getByIdDone.push(id);\n                    }\n                }\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n        return result;\n    }\n    /**\n     * Trigger before creating a list of items\n     */\n    async beforeCreateList(list, result) {\n    }\n    async queryCreateItem(item, fromList, resultTemp) {\n        const result = new Aventus.ResultRamWithError();\n        result.errors = resultTemp.errors;\n        if (fromList) {\n            return result;\n        }\n        let response = await this.routes.store(item);\n        if (response.success && response.result) {\n            result.result = this.getObjectForRam(response.result);\n            if (this.hasDetails && result.result) {\n                const id = this.getId(result.result);\n                if (!this.getByIdDone.includes(id)) {\n                    this.getByIdDone.push(id);\n                }\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n        return result;\n    }\n    /**\n     * Trigger before creating an item\n     */\n    async beforeCreateItem(item, fromList, result) {\n    }\n    /**\n     * Trigger after creating an item\n     */\n    async afterCreateItem(result, fromList) {\n    }\n    /**\n     * Trigger after creating a list of items\n     */\n    async afterCreateList(result) {\n    }\n    /**\n     * Update a list of items inside ram\n     */\n    async updateList(list) {\n        let result = await this.updateListWithError(list);\n        return result.result ?? [];\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateListWithError(list) {\n        list = this.removeWatch(list);\n        let actionTemp = new Aventus.ResultRamWithError();\n        actionTemp.result = [];\n        await this.beforeUpdateList(list, actionTemp);\n        let action = await this.queryUpdateList(list, actionTemp);\n        if (!action.result) {\n            action.result = [];\n        }\n        if (action.success && action.result.length > 0) {\n            const resources = action.result;\n            action.result = [];\n            for (let resource of resources) {\n                let resultItem = await this._update(resource, true);\n                if (resultItem.success && resultItem.result) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterUpdateList(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Update an item inside ram\n     */\n    async update(item, ...args) {\n        let action = await this.updateWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Update an item inside ram\n     */\n    async updateWithError(item, ...args) {\n        return await this._update(item, false);\n    }\n    async _update(item, fromList) {\n        item = this.removeWatch(item);\n        return this.actionGuard.run(['_update', item], async () => {\n            let actionTemp = new Aventus.ResultRamWithError();\n            let resultTemp = await this.getIdWithError(item);\n            let actionError = new Aventus.ResultRamWithError();\n            if (resultTemp.success && resultTemp.result !== undefined) {\n                let key = resultTemp.result;\n                if (this.records.has(key)) {\n                    if (this.records.get(key) == item) {\n                        console.warn(\"You are updating the same item. You should clone the object first to avoid weird effect\");\n                    }\n                    await this.beforeUpdateItem(item, fromList, actionTemp);\n                    let action;\n                    if (this.isResource(item)) {\n                        action = new Aventus.ResultRamWithError();\n                        action.errors = actionTemp.errors;\n                    }\n                    else {\n                        action = await this.queryUpdateItem(item, fromList, actionTemp);\n                    }\n                    if (!action.success) {\n                        return action;\n                    }\n                    if (action.result) {\n                        const resource = action.result;\n                        await this.addOrUpdateData(resource, action);\n                        if (!action.success) {\n                            return action;\n                        }\n                        await this.afterUpdateItem(action, fromList);\n                        if (!action.success) {\n                            action.result = undefined;\n                        }\n                        else if (action.result) {\n                            this.publish('updated', action.result);\n                        }\n                    }\n                    return action;\n                }\n                else {\n                    actionError.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n                }\n            }\n            else {\n                actionError.errors = resultTemp.errors;\n            }\n            return actionError;\n        });\n    }\n    async queryUpdateList(list, resultTemp) {\n        const result = new Aventus.ResultRamWithError();\n        result.errors = resultTemp.errors;\n        let response = await this.routes.updateMany(list);\n        if (response.success && response.result) {\n            result.result = [];\n            for (let element of response.result) {\n                result.result.push(this.getObjectForRam(element));\n            }\n            if (this.hasDetails) {\n                for (let element of result.result) {\n                    const id = this.getId(element);\n                    if (!this.getByIdDone.includes(id)) {\n                        this.getByIdDone.push(id);\n                    }\n                }\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n        return result;\n    }\n    /**\n     * Trigger before updating a list of items\n     */\n    async beforeUpdateList(list, result) {\n    }\n    async queryUpdateItem(item, fromList, resultTemp) {\n        const result = new Aventus.ResultRamWithError();\n        result.errors = resultTemp.errors;\n        if (fromList) {\n            return result;\n        }\n        let response = await this.routes.update(item.id, item);\n        if (response.success && response.result) {\n            result.result = this.getObjectForRam(response.result);\n            if (this.hasDetails && result.result) {\n                const id = this.getId(result.result);\n                if (!this.getByIdDone.includes(id)) {\n                    this.getByIdDone.push(id);\n                }\n            }\n        }\n        else {\n            result.errors = [...result.errors, ...response.errors];\n        }\n        return result;\n    }\n    /**\n    * Trigger before updating an item\n    */\n    async beforeUpdateItem(item, fromList, result) {\n    }\n    /**\n     * Trigger after updating an item\n     */\n    async afterUpdateItem(result, fromList) {\n    }\n    /**\n     * Trigger after updating a list of items\n     */\n    async afterUpdateList(result) {\n    }\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteList(list) {\n        let result = await this.deleteListWithError(list);\n        return result.result ?? [];\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteListWithError(list) {\n        list = this.removeWatch(list);\n        let action = new Aventus.ResultRamWithError();\n        action.result = [];\n        let deleteResult = new Aventus.VoidWithError();\n        await this.beforeDeleteList(list, deleteResult);\n        await this.queryDeleteList(list, deleteResult);\n        if (!deleteResult.success) {\n            action.errors = deleteResult.errors;\n        }\n        for (let item of list) {\n            let resultItem = await this._delete(item, true);\n            if (resultItem.success && resultItem.result) {\n                action.result.push(resultItem.result);\n            }\n            else {\n                action.errors = [...action.errors, ...resultItem.errors];\n            }\n        }\n        if (action.success) {\n            await this.afterDeleteList(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Delete an item inside ram\n     */\n    async delete(item, ...args) {\n        let action = await this.deleteWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    ;\n    /**\n    * Delete an item inside ram\n    */\n    async deleteWithError(item, ...args) {\n        return await this._delete(item, false);\n    }\n    ;\n    /**\n     * Delete an item by id inside ram\n     */\n    async deleteById(id) {\n        let action = await this.deleteByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n    * Delete an item by id inside ram\n    */\n    async deleteByIdWithError(id) {\n        let item = this.records.get(id);\n        if (item) {\n            return await this._delete(item, false);\n        }\n        let result = new Aventus.ResultRamWithError();\n        result.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"can't delete the item \" + id + \" because it wasn't found inside ram\"));\n        return result;\n    }\n    async _delete(item, fromList) {\n        item = this.removeWatch(item);\n        return this.actionGuard.run(['_delete', item], async () => {\n            let action = new Aventus.ResultRamWithError();\n            let resultTemp = await this.getIdWithError(item);\n            if (resultTemp.success && resultTemp.result) {\n                let key = resultTemp.result;\n                let oldItem = this.records.get(key);\n                if (oldItem) {\n                    let deleteResult = new Aventus.VoidWithError();\n                    await this.beforeDeleteItem(oldItem, fromList, deleteResult);\n                    if (!deleteResult.success) {\n                        action.errors = deleteResult.errors;\n                        return action;\n                    }\n                    await this.queryDeleteItem(oldItem, fromList, deleteResult);\n                    this.beforeRecordDelete(oldItem);\n                    this.records.delete(key);\n                    this.afterRecordDelete(oldItem);\n                    action.result = oldItem;\n                    await this.afterDeleteItem(action, fromList);\n                    if (!action.success) {\n                        action.result = undefined;\n                    }\n                    else {\n                        this.publish('deleted', action.result);\n                    }\n                    this.recordsSubscribers.delete(key);\n                }\n                else {\n                    action.errors.push(new Aventus.RamError(Aventus.RamErrorCode.noItemInsideRam, \"can't delete the item \" + key + \" because it wasn't found inside ram\"));\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n            return action;\n        });\n    }\n    async queryDeleteList(list, result) {\n        let response = await this.routes.destroyMany(list.map(t => t.id));\n        if (!response.success) {\n            result.errors = [...result.errors, ...response.errors];\n        }\n        else if (this.hasDetails) {\n            for (let item of list) {\n                const id = this.getId(item);\n                const index = this.getByIdDone.indexOf(id);\n                if (index != -1) {\n                    this.getByIdDone.splice(index, 1);\n                }\n            }\n        }\n    }\n    /**\n     * Trigger before deleting a list of items\n     */\n    async beforeDeleteList(list, result) { }\n    async queryDeleteItem(item, fromList, result) {\n        if (fromList) {\n            return;\n        }\n        let response = await this.routes.destroy(item.id);\n        if (!response.success) {\n            result.errors = [...result.errors, ...response.errors];\n        }\n        else if (this.hasDetails) {\n            const id = this.getId(item);\n            const index = this.getByIdDone.indexOf(id);\n            if (index != -1) {\n                this.getByIdDone.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Trigger before deleting an item\n     */\n    async beforeDeleteItem(item, fromList, result) { }\n    /**\n     * Trigger after deleting an item\n     */\n    async afterDeleteItem(result, fromList) { }\n    /**\n     * Trigger after deleting a list of items\n     */\n    async afterDeleteList(result) { }\n}\nGenericRamHttp.Namespace=`AventusPhp`;\r\n__as1(_, 'GenericRamHttp', GenericRamHttp);\r\n","dependances":[{"fullName":"Aventus.IRam","isStrong":true},{"fullName":"AventusPhp.ModelController","isStrong":false},{"fullName":"AventusPhp.RamSubscribers","isStrong":false},{"fullName":"AventusPhp.RamHttpResourceDetails","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Aventus.ActionGuard","isStrong":false},{"fullName":"AventusPhp.RamHttpData","isStrong":false},{"fullName":"AventusPhp.RamHttpRequest","isStrong":false},{"fullName":"AventusPhp.RamHttpResource","isStrong":false},{"fullName":"Aventus.GenericRam","isStrong":false},{"fullName":"BindThis","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"X","isStrong":false},{"fullName":"Aventus.IRamData","isStrong":false},{"fullName":"B","isStrong":false},{"fullName":"Base","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.VoidRamWithError","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"Aventus.JsonFromOptions","isStrong":false},{"fullName":"Aventus.Json","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false}],"fullName":"AventusPhp.GenericRamHttp","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let RamHttp=class RamHttp extends GenericRamHttp {\n}\nRamHttp.Namespace=`AventusPhp`;\r\n__as1(_, 'RamHttp', RamHttp);\r\n","dependances":[{"fullName":"AventusPhp.GenericRamHttp","isStrong":true},{"fullName":"AventusPhp.ModelController","isStrong":false}],"fullName":"AventusPhp.RamHttp","required":false,"type":1,"isExported":true,"convertibleName":""}],"existing":[{"fullName":"AventusPhp.RamSubscribers","dependances":[]},{"fullName":"AventusPhp.KeysOfType","dependances":[{"fullName":"T","isStrong":false},{"fullName":"NonNullable","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"K","isStrong":false}]},{"fullName":"AventusPhp.NumberKeys","dependances":[{"fullName":"T","isStrong":false},{"fullName":"K","isStrong":false}]},{"fullName":"AventusPhp.RamHttpResource","dependances":[{"fullName":"C","isStrong":false},{"fullName":"AventusPhp.ModelController","isStrong":false},{"fullName":"Res","isStrong":false}]},{"fullName":"AventusPhp.RamHttpRequest","dependances":[{"fullName":"C","isStrong":false},{"fullName":"AventusPhp.ModelController","isStrong":false},{"fullName":"Req","isStrong":false}]},{"fullName":"AventusPhp.RamHttpData","dependances":[{"fullName":"C","isStrong":false},{"fullName":"AventusPhp.ModelController","isStrong":false},{"fullName":"D","isStrong":false}]},{"fullName":"AventusPhp.RamHttpResourceDetails","dependances":[{"fullName":"C","isStrong":false},{"fullName":"AventusPhp.ModelController","isStrong":false},{"fullName":"Res","isStrong":false}]},{"fullName":"AventusPhp.ItemField","dependances":[{"fullName":"Aventus.IRamData","isStrong":false},{"fullName":"AventusPhp.NumberKeys","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"AventusPhp.KeysOfType","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"Ram","isStrong":false}]}]}
//#endregion js src //
//#region css def //
{}
//#endregion css def //
//#region css //
{}
//#endregion css //
//#region html //
{}
//#endregion html //
//#region dependances //
{}
//#endregion dependances //
