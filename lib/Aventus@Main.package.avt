// Aventus@Main:1.0.0
//#region js def //
declare global {
	declare namespace Aventus{
type Loop = {
    data: string;
    item: string;
    index: string;
    anchorId: string;
    template: WebComponentTemplate;
};

type ActionEventCallback = (c: WebComponentTemplateContext, ...args: any) => void;

type ActionEventListener = (e: Event, c: WebComponentTemplateContext) => void;

class WebComponentTemplateInstance {
    private context;
    content: HTMLElement;
    private actions;
    private component;
    private _components;
    private firstRenderUniqueCb;
    private firstRenderCb;
    private fctsToRemove;
    private loopRegisteries;
    firstChild: HTMLElement;
    lastChild: HTMLElement;
    private loops;
    constructor(context: WebComponentTemplateContext, content: HTMLElement, actions: Actions, component: WebComponent, loops: Loop[]);
    render(): void;
    destructor(): void;
    private selectElements;
    private bindEvents;
    private bindEvent;
    private bindPressEvent;
    private transformActionsListening;
    private transformChangeAction;
    private transformInjectionAction;
    private transformBindigAction;
    private renderSubTemplate;
    private renderLoop;
    private registerLoopWatchEvent;
}

type ActionBindings = {
    id: string;
    valueName: string;
    eventNames: string[];
    isCallback?: boolean;
    path?: string;
};

type ActionInjection = {
    id: string;
    injectionName: string;
    inject: (c: ContextValues) => any;
    path?: string;
};

type ActionChange = {
    id: string;
    attrName: string | '@HTML';
    render: (c: ContextValues) => string;
    isBool?: boolean;
    path?: string;
};

type ActionEvent = {
    id: string;
    eventName: string;
    isCallback?: boolean;
    fct: ActionEventListener & ActionEventCallback;
};

class WebComponentTemplate {
    static setValueToItem(path: string, obj: any, value: any): void;
    static getValueFromItem(path: string, obj: any): any;
    static validatePath(path: string, pathToCheck: string): boolean;
    private htmlParts;
    setHTML(data: WebComponentTemplateHTML): void;
    generateTemplate(): void;
    setTemplate(template: string): void;
    private contextSchema;
    template: HTMLTemplateElement;
    actions: Actions;
    loops: Loop[];
    setActions(actions: Actions): void;
    setSchema(contextSchema: ContextSchema): void;
    createInstance(component: WebComponent): any;
    addLoop(loop: Loop): void;
}

class WebComponentTemplateContext {
    private __changes;
    private component;
    private fctsToRemove;
    c: ContextValues;
    isRendered: boolean;
    schema: ContextSchema;
    constructor(component: WebComponent, schema: ContextSchema, locals: {
        name: string;
        value: any;
    }[]);
    destructor(): void;
    private buildSchema;
    private createGlobal;
    private createLoop;
    private createLocal;
    addChange(on: string, fct: (path: string) => void): void;
}

type ContextValues = {
    [name: string]: any;
};

@Dependances([{
    type: WebComponentInstance,
    strong: true
}])
abstract class WebComponent extends HTMLElement implements DefaultComponent {
    /**
     * Add attributes informations
     */
    static get observedAttributes(): string[];
    private _first;
    private _isReady;
    /**
     * Determine if the component is ready (postCreation done)
     */
    get isReady(): boolean;
    /**
     * The current namespace
     */
    static get Namespace(): string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    /**
     * The current namespace
     */
    get namespace(): string;
    /**
     * Get the name of the component class
     */
    getClassName(): string;
    /**
    * Get the unique type for the data. Define it as the namespace + class name
    */
    get $type(): string;
    private __onChangeFct;
    private __watch;
    private __watchActions;
    private __watchActionsCb;
    private __pressManagers;
    private __isDefaultState;
    private __defaultActiveState;
    private __defaultInactiveState;
    private __statesList;
    constructor();
    /**
     * Remove all listeners
     * State + press
     */
    destructor(): void;
    private __addWatchesActions;
    private __registerWatchesActions;
    private __addPropertyActions;
    private __registerPropertiesActions;
    private static __style;
    private static __template;
    private __templateInstance;
    protected styleBefore(): string[];
    protected styleAfter(): string[];
    private __getStyle;
    private __getHtml;
    private __getStatic;
    private static __styleSheets;
    private __renderStyles;
    private __renderTemplate;
    private __registerTemplateAction;
    private connectedCallback;
    private __defaultValues;
    private __upgradeAttributes;
    private __listBoolProps;
    private __upgradeProperty;
    private __getStateManager;
    private __addActiveDefState;
    private __addInactiveDefState;
    private __addActiveState;
    private __addInactiveState;
    private __addAskChangeState;
    private __createStates;
    private __createStatesList;
    private __inactiveDefaultState;
    private __activeDefaultState;
    private __subscribeState;
    private __stateCleared;
    private __unsubscribeState;
    protected dateToString(d: Date): string | null;
    protected dateTimeToString(dt: Date): string | null;
    protected stringToDate(s: string): Date;
    protected stringToDateTime(s: string): Date;
    protected getBoolean(val: any): boolean;
    private attributeChangedCallback;
    remove(): void;
    /**
     * Function triggered when the component is removed from the DOM
     */
    protected postDestruction(): void;
    /**
     * Function triggered the first time the component is rendering inside DOM
     */
    protected postCreation(): void;
    /**
     * Find a parent by tagname if exist
     */
    findParentByTag<T>(tagname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by class name if exist
     */
    findParentByClass<T>(classname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by type if exist
     */
    findParentByType<T>(type: {
        prototype: T;
    }, untilNode?: Element): T | null;
    /**
     * Find list of parents by tagname
     */
    findParents<T>(tagname: string | string[], untilNode?: Element): T[];
    /**
     * Check if element contains a child
     */
    containsChild(el: Element): boolean;
    /**
     * Get element inside slot
     */
    getElementsInSlot(slotName?: string): any;
}

type Actions = {
    elements?: {
        name: string;
        ids: string[];
        isArray?: boolean;
    }[];
    content?: {
        [contextProp: string]: ActionChange[];
    };
    injection?: {
        [contextProp: string]: ActionInjection[];
    };
    bindings?: {
        [contextProp: string]: ActionBindings[];
    };
    events?: ActionEvent[];
    pressEvents?: PressManagerOptions[];
};

type ContextSchema = {
    globals: string[];
    loops: {
        item: string;
        index: string;
        data: string;
    }[];
    locals: {
        name: string;
        value: any;
    }[];
};

type WebComponentTemplateHTML = {
    slots: {
        [name: string]: string;
    };
    blocks: {
        [name: string]: string;
    };
};

class WebComponentInstance {
    private static __allDefinitions;
    private static __allInstances;
    /**
     * Last definition insert datetime
     */
    static lastDefinition: number;
    private static registerDefinition;
    /**
     * Get all sub classes of type
     */
    static getAllClassesOf<T>(type: typeof WebComponent): (new () => WebComponent)[];
    /**
     * Get all registered definitions
     */
    static getAllDefinitions(): (new () => WebComponent)[];
    static addInstance(instance: WebComponent): void;
    static removeInstance(instance: WebComponent): void;
    static getAllInstances(type: new () => WebComponent): {};
}

interface DefaultComponent {
    [key: string]: any;
}

interface DebuggerConfig {
    writeCompiled?: boolean;
}

class Style {
    private static instance;
    private static defaultStyleSheets;
    static store(name: string, content: string): void;
    static get(name: string): CSSStyleSheet;
    static load(name: string, url: string): Promise<void>;
    private static getInstance;
    private constructor();
    private stylesheets;
    load(name: string, url: string): Promise<void>;
    store(name: string, content: string): void;
    get(name: string): CSSStyleSheet;
}

class ElementExtension {
    /**
     * Find a parent by tagname if exist Static.findParentByTag(this, "av-img")
     */
    static findParentByTag<T>(element: Element, tagname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by class name if exist Static.findParentByClass(this, "my-class-img") = querySelector('.my-class-img')
     */
    static findParentByClass<T>(element: Element, classname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by type if exist Static.findParentyType(this, Aventus.Img)
     */
    static findParentByType<T>(element: Element, type: {
        prototype: T;
    }, untilNode?: Element): T | null;
    /**
     * Find list of parents by tagname
     */
    static findParents<T>(element: Element, tagname: string | string[], untilNode?: Element): T[];
    /**
     * Check if element contains a child
     */
    static containsChild(element: Element, child: Element): boolean;
    /**
     * Get element inside slot
     */
    static getElementsInSlot(element: Element, slotName?: string): HTMLElement[];
    /**
     * Get deeper element inside dom at the position X and Y
     */
    static getElementAtPosition(x: number, y: number, startFrom?: Element): any;
}

function uuidv4(): string;

function sleep(ms: number): Promise<void>;

function mergeObject<T>(item: T, objJson: KeysObject<T> | T): void;

function compareObject(obj1: any, obj2: any): boolean;

type Subscriber = {
    regex: RegExp;
    params: {
        name: string;
        type: "number" | "string";
        position: number;
    }[];
    isActive: boolean;
    callbacks: {
        active: StateActivationFct[];
        inactive: StateInactivationFct[];
        askChange: StateAskChangeFct[];
    };
};

type StateAskChangeFct = (state: State, nextState: State, slugs: StateSlug) => Promise<boolean>;

type StateInactivationFct = (state: State, nextState: State, slugs: StateSlug) => void;

type StateActivationFct = (state: State, slugs: StateSlug) => void;

@Dependances([{ type: EmptyState, strong: false }])
abstract class StateManager {
    protected subscribers: {
        [statePattern: string]: Subscriber;
    };
    static canBeActivate(statePattern: string, stateName: string): boolean;
    protected activeState: State;
    protected changeStateMutex: Mutex;
    private afterStateChanged;
    /**
     * Subscribe actions for a state or a state list
     */
    subscribe(statePatterns: string | string[], callbacks: StateAction): void;
    /**
     * Unsubscribe actions for a state or a state list
     */
    unsubscribe(statePatterns: string | string[], callbacks: StateAction): void;
    onAfterStateChanged(cb: () => void): void;
    offAfterStateChanged(cb: () => void): void;
    protected static prepareStateString(stateName: string): {
        regex: any;
        params: {};
    };
    /**
     * Activate a current state
     */
    setState(state: State | string): Promise<boolean>;
    getState(): State | undefined;
    protected getInternalStateSlugs(subscriber: Subscriber, stateName: string): any;
    /**
     * Check if a state is in the subscribers and active, return true if it is, false otherwise
     */
    isStateActive(statePattern: string): boolean;
    /**
     * Get slugs information for the current state, return null if state isn't active
     */
    getStateSlugs(statePattern: string): any;
    protected logLevel(): number;
    protected _log(msg: string, type: "error" | "warning" | "info"): void;
}

type StateSlug = {
    [slugName: string]: string | number;
};

interface StateAction {
    active?: StateActivationFct | StateActivationFct[];
    inactive?: StateInactivationFct | StateInactivationFct[];
    askChange?: StateAskChangeFct | StateAskChangeFct[];
}

class Mutex {
    private waitingList;
    private isLocked;
    /**
     * Wait the mutex to be free then get it
     */
    waitOne(): any;
    /**
     * Release the mutex
     */
    release(): void;
    /**
     * Release the mutex
     */
    releaseOnlyLast(): void;
    /**
     * Clear mutex
     */
    dispose(): void;
    safeRun<T = void>(cb: () => T): Promise<T | null>;
    safeRunAsync<T = void>(cb: () => Promise<T>): Promise<T | null>;
    safeRunLast<T = void>(cb: () => T): Promise<T | null>;
    safeRunLastAsync<T = void>(cb: () => Promise<T>): Promise<T | null>;
}

abstract class State {
    /**
     * Activate a custom state inside a specific manager
     * It ll be a generic state with no information inside exept name
     */
    static activate(stateName: string, manager: StateManager): Promise<boolean>;
    abstract get name(): string;
    /**
     * Activate this state inside a specific manager
     */
    activate(manager: StateManager): Promise<boolean>;
    onActivate(): void;
    onInactivate(nextState: State): void;
    askChange(state: State, nextState: State): Promise<boolean>;
}

class EmptyState extends State {
    private localName;
    constructor(stateName: string);
    /**
     * @inheritdoc
     */
    get name(): string;
}

interface SocketMessage {
    channel: string;
    data?: any;
}

interface SocketRoute {
    channel: string;
    callback: (data: any) => void;
}

interface SocketOptions {
    log?: boolean;
    host?: string;
    port?: number;
    useHttps?: boolean;
    routes?: {
        [key: string]: SocketRoute[];
    };
    /**
     * Define the name for the websocket
     * It ll open the ws connection on /ws/${socketName}
     */
    socketName?: string;
}

interface ISocket {
    addRoute(newRoute: SocketRoute): any;
    /**
     * The route to remove
     * @param route - The route to remove
     */
    removeRoute(route: SocketRoute): any;
    open(done: () => void, error: () => void): any;
    /**
     *
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param options the options to add to the message (typically the uid)
     */
    sendMessage<T>(channelName: string, data: T, options: any): any;
    /**
     *
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param callbacks The callbacks to call. With the channel as key and the callback function as value
     */
    sendMessageAndWait<T>(channelName: string, data: T, callbacks: {
        [key: string]: (data: any) => void;
    }): any;
    /**
     *
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param callbacks The callbacks to call. With the channel as key and the callback function as value
     */
    sendMessageAndWaitMultiple(channelName: string, data: {}, callbacks: {}): any;
    isReady(): boolean;
}

interface RamWsCallback<T> {
    channel: string;
    callback: (response: {
        data?: KeysObject<T>[];
    }) => void;
}

interface RamWsRoute {
    request: string;
    multiple: string;
    success: string;
    error: string;
}

interface RamWsRoutes {
    get: RamWsRoute;
    getAll: RamWsRoute;
    create: RamWsRoute;
    created: RamWsRoute;
    update: RamWsRoute;
    updated: RamWsRoute;
    delete: RamWsRoute;
    deleted: RamWsRoute;
}

type KeysObject<T> = {
    [Key in keyof T]?: any;
};

type RamItem<T extends IData> = T & IRamAction<T>;

interface RamSubscribers<T> {
    created: ((item: T) => void)[];
    updated: ((item: T) => void)[];
    deleted: ((item: T) => void)[];
}

interface IRamAction<T> {
    update(newData: KeysObject<T>): Promise<this>;
    onUpdate(callback: (item: this) => void): any;
    offUpdate(callback: (item: this) => void): any;
    delete(): Promise<void>;
    onDelete(callback: (item: this) => void): any;
    offDelete(callback: (item: this) => void): any;
}

interface IRam {
}

abstract class GenericRam<Index, T extends IData> implements IRam {
    /**
     * The current namespace
     */
    static get Namespace(): string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    private subscribers;
    private recordsSubscribers;
    /**
     * List of stored item by index key
     */
    protected records: Map<Index, RamItem<T>>;
    protected constructor();
    /**
     * Define the field where the index key is location
     * Example : 'id';
     */
    abstract defineIndexKey(): keyof T;
    /**
     * Get item id
     */
    getIdWithError(item: KeysObject<T> | T): ResultRamWithError<Index>;
    /**
     * Get item id
     */
    getId(item: KeysObject<T> | T): Index | null;
    /**
     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete
     */
    protected addRamAction<B extends new (...args: any[]) => IData>(Base: B): any;
    protected abstract getTypeForData(objJson: KeysObject<T> | T): new () => T;
    /**
     * Transform the object into the object stored inside Ram
     */
    protected getObjectForRam(objJson: KeysObject<T> | T): RamItem<T>;
    /**
     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced
     */
    protected addOrUpdateData(item: KeysObject<T>, result: ResultRamWithError<RamItem<T>>): void;
    /**
     * Merge object and create real instance of class
     */
    protected mergeObject(item: T, objJson: KeysObject<T> | T): void;
    protected publish(type: 'created' | 'updated' | 'deleted', data: RamItem<T>): void;
    private subscribe;
    private unsubscribe;
    /**
    * Add a callback that ll be triggered when a new item is stored
    */
    onCreated(cb: (item: RamItem<T>) => void): void;
    /**
     * Remove a created callback
     */
    offCreated(cb: (item: RamItem<T>) => void): void;
    /**
     * Add a callback that ll be triggered when an item is updated
     */
    onUpdated(cb: (item: RamItem<T>) => void): void;
    /**
     * Remove an updated callback
     */
    offUpdated(cb: (item: RamItem<T>) => void): void;
    /**
     * Add a callback that ll be triggered when an item is deleted
     */
    onDeleted(cb: (item: RamItem<T>) => void): void;
    /**
     * Remove an deleted callback
     */
    offDeleted(cb: (item: RamItem<T>) => void): void;
    /**
     * Get an item by id if exist (alias for getById)
     */
    get(id: Index): Promise<RamItem<T> | undefined>;
    /**
     * Get an item by id if exist (alias for getById)
     */
    getWithError(id: Index): Promise<ResultRamWithError<RamItem<T>>>;
    /**
     * Get an item by id if exist
     */
    getById(id: Index): Promise<RamItem<T> | undefined>;
    /**
     * Get an item by id if exist
     */
    getByIdWithError(id: Index): Promise<ResultRamWithError<RamItem<T>>>;
    /**
     * Trigger before getting an item by id
     */
    protected beforeGetById(id: Index, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    /**
     * Trigger after getting an item by id
     */
    protected afterGetById(result: ResultRamWithError<RamItem<T>>): Promise<void>;
    /**
     * Get multiple items by ids
     */
    getByIds(ids: Index[]): Promise<RamItem<T>[]>;
    /**
     * Get multiple items by ids
     */
    getByIdsWithError(ids: Index[]): Promise<ResultRamWithError<RamItem<T>[]>>;
    /**
     * Trigger before getting a list of items by id
     */
    protected beforeGetByIds(ids: Index[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
     * Trigger after getting a list of items by id
     */
    protected afterGetByIds(result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
     * Get all elements inside the Ram
     */
    getAll(): Promise<Map<Index, RamItem<T>>>;
    /**
     * Get all elements inside the Ram
     */
    getAllWithError(): Promise<ResultRamWithError<Map<Index, RamItem<T>>>>;
    /**
     * Trigger before getting all items inside Ram
     */
    protected beforeGetAll(result: ResultRamWithError<Map<Index, RamItem<T>>>): Promise<void>;
    /**
     * Trigger after getting all items inside Ram
     */
    protected afterGetAll(result: ResultRamWithError<Map<Index, RamItem<T>>>): Promise<void>;
    /**
     * Get all elements inside the Ram
     */
    getList(): Promise<RamItem<T>[]>;
    /**
     * Get all elements inside the Ram
     */
    getListWithError(): Promise<ResultRamWithError<RamItem<T>[]>>;
    /**
     * Create a list of items inside ram
     */
    createList(list: T[]): Promise<RamItem<T>[]>;
    /**
     * Create a list of items inside ram
     */
    createListWithError(list: T[]): Promise<ResultRamWithError<RamItem<T>[]>>;
    /**
     * Create an item inside ram
     */
    create(item: T, ...args: any[]): Promise<RamItem<T> | undefined>;
    /**
     * Create an item inside ram
     */
    createWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<T>>>;
    private _create;
    /**
     * Trigger before creating a list of items
     */
    protected beforeCreateList(list: T[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
     * Trigger before creating an item
     */
    protected beforeCreateItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    /**
     * Trigger after creating an item
     */
    protected afterCreateItem(result: ResultRamWithError<RamItem<T>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after creating a list of items
     */
    protected afterCreateList(result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
     * Update a list of items inside ram
     */
    updateList(list: T[]): Promise<RamItem<T>[]>;
    /**
     * Update a list of items inside ram
     */
    updateListWithError(list: T[]): Promise<ResultRamWithError<RamItem<T>[]>>;
    /**
     * Update an item inside ram
     */
    update(item: T, ...args: any[]): Promise<RamItem<T> | undefined>;
    /**
     * Update an item inside ram
     */
    updateWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<T>>>;
    private _update;
    /**
     * Trigger before updating a list of items
     */
    protected beforeUpdateList(list: T[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
    * Trigger before updating an item
    */
    protected beforeUpdateItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    /**
     * Trigger after updating an item
     */
    protected afterUpdateItem(result: ResultRamWithError<RamItem<T>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after updating a list of items
     */
    protected afterUpdateList(result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
     * Delete a list of items inside ram
     */
    deleteList(list: T[]): Promise<RamItem<T>[]>;
    /**
     * Delete a list of items inside ram
     */
    deleteListWithError(list: T[]): Promise<ResultRamWithError<RamItem<T>[]>>;
    /**
     * Delete an item inside ram
     */
    delete(item: T, ...args: any[]): Promise<RamItem<T> | undefined>;
    /**
    * Delete an item inside ram
    */
    deleteWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<T>>>;
    /**
     * Delete an item by id inside ram
     */
    deleteById(id: Index): Promise<RamItem<T> | undefined>;
    /**
    * Delete an item by id inside ram
    */
    deleteByIdWithError(id: Index): Promise<ResultRamWithError<RamItem<T>>>;
    private _delete;
    /**
     * Trigger before deleting a list of items
     */
    protected beforeDeleteList(list: T[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    /**
     * Trigger before deleting an item
     */
    protected beforeDeleteItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    /**
     * Trigger after deleting an item
     */
    protected afterDeleteItem(result: ResultRamWithError<RamItem<T>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after deleting a list of items
     */
    protected afterDeleteList(result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
}

abstract class Ram<T extends IData> extends GenericRam<number, T> {
}

abstract class GenericRamWs<Index, T extends IData> extends GenericRam<Index, T> {
    private wsRoutes;
    private ws;
    private getAllDone;
    protected constructor();
    /**
     * Get the socket within the RAM is binded
     */
    protected abstract getWebSocket(): Socket;
    /**
     * Get the object name to create all messages
     * This name **should not** end with a /
     */
    protected abstract getWebSocketRoute(): string;
    protected init(): void;
    protected createRoutes(): void;
    protected addSocketCallback(): void;
    /**
     * Send a msg through the websocket
     */
    protected sendMsg(route: string, params: {
        [key: string]: any;
    }, callbacks: {
        [key: string]: (data: any) => void;
    }): void;
    private uniqueMsgWaiting;
    /**
     * Send a unique msg through the websocket and wait answer
     */
    protected sendUniqueMsg(route: string, params: {
        [key: string]: any;
    }, callbacks: {
        [key: string]: (data: any) => void;
    }): void;
    private addRoute;
    protected beforeGetById(id: Index, result: ResultRamWithError<T>): Promise<void>;
    protected beforeGetByIds(ids: Index[], result: ResultRamWithError<T[]>): Promise<void>;
    protected beforeGetAll(result: ResultRamWithError<Map<Index, RamItem<T>>>): Promise<void>;
    protected beforeCreateItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    protected beforeCreateList(list: T[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    protected beforeUpdateItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    protected beforeUpdateList(list: T[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
    protected beforeDeleteItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<T>>): Promise<void>;
    protected beforeDeleteList(list: T[], result: ResultRamWithError<RamItem<T>[]>): Promise<void>;
}

abstract class RamWs<T extends IData> extends GenericRamWs<number, T> {
}

class ResultWithError<T extends GenericError<any>, U> {
    /**
     * Determine if the action is a success
     */
    get success(): boolean;
    /**
     * Result
     */
    result: U | undefined;
    /**
     * List of errors
     */
    errors: T[];
}

enum RamErrorCode {
    unknow = 0,
    noId = 1,
    noItemInsideRam = 2
}

class GenericError<T extends number> {
    /**
     * Code for the error
     */
    code: T;
    /**
     * Description of the error
     */
    message: string;
    details: any[];
    constructor(code: T, message: string);
}

class Watcher {
    private static __maxProxyData;
    /**
     * Transform object into a watcher
     */
    static get(obj: object, onDataChanged: (action: WatchAction, path: string, value: any) => void): any;
}

enum WatchAction {
    CREATED = 0,
    UPDATED = 1,
    DELETED = 2
}

class ResourceLoader {
    private static headerLoaded;
    private static headerWaiting;
    /**
     * Load the resource inside the head tag
     */
    static loadInHead(options: ResourceLoaderHeadOptions | string): Promise<boolean>;
    private static loadTag;
    private static releaseAwaitFctHead;
    private static awaitFctHead;
    private static requestLoaded;
    private static requestWaiting;
    /**
     *
    */
    static load(options: ResourceLoaderOptions | string): Promise<string>;
    private static releaseAwaitFct;
    private static awaitFct;
    private static fetching;
    private static readFile;
    private static imgExtensions;
    private static prepareOptions;
}

interface ResourceLoaderHeadOptions {
    url: string;
    type: 'js' | 'css';
}

interface ResourceLoaderOptions {
    url: string;
    type: 'js' | 'css' | 'img' | 'svg';
}

class ResizeObserver {
    private callback;
    private targets;
    private fpsInterval;
    private nextFrame;
    private entriesChangedEvent;
    private willTrigger;
    private static resizeObserverClassByObject;
    private static uniqueInstance;
    private static getUniqueInstance;
    constructor(options: ResizeObserverOptions | CallableFunction);
    /**
     * Observe size changing for the element
     */
    observe(target: Element): void;
    /**
     * Stop observing size changing for the element
     */
    unobserve(target: Element): void;
    /**
     * Destroy the resize observer
     */
    disconnect(): void;
    private entryChanged;
    private triggerCb;
    private _triggerCb;
}

type WindowResizeObserver = globalThis.ResizeObserver;

interface ResizeObserverOptions {
    callback: CallableFunction;
    fps?: number;
}

interface Pointer {
    id: number;
    constructor(nativePointer: Touch | PointerEvent): any;
}

class Instance {
    private static elements;
    static get<X>(type: Function & {
        prototype: X;
    }): X;
    static set<X>(el: X): boolean;
    static destroy<X>(el: X): boolean;
}

class HttpRequest {
    private options;
    private url;
    /**
     * Get the right http method inside enum
     */
    static getMethod(method: string): HttpRequestMethod;
    /**
     * Get http method in string
     */
    private getMethod;
    constructor(options: HttpRequestOptions);
    private recuFillFormData;
    /**
     * Send the http request
     */
    send(): Promise<Response>;
    /**
     * Send a get request
     */
    static get(url: string): Promise<Response>;
    /**
     * Send a post request and wait a result in JSON format
     */
    static post<T>(url: string, data: {}): Promise<T>;
}

enum HttpRequestMethod {
    GET = 0,
    POST = 1,
    DELETE = 2,
    PUT = 3,
    OPTION = 4
}

interface HttpRequestOptions {
    url: string;
    method?: HttpRequestMethod;
    data?: {
        [key: string]: any;
    } | FormData;
    useJSON?: boolean;
}

class DefaultHttpRequestOptions implements HttpRequestOptions {
    url: string;
    method: HttpRequestMethod;
    useJSON: boolean;
}

class DragAndDrop {
    /**
     * Default offset before drag element
     */
    static defaultOffsetDrag: number;
    private pressManager;
    private options;
    private startCursorPosition;
    private startElementPosition;
    private isEnable;
    constructor(options: DragAndDropOptions);
    private getDefaultOptions;
    private mergeProperties;
    private mergeFunctions;
    private defaultMerge;
    private init;
    private draggableElement;
    private positionShadowRelativeToElement;
    private onPressStart;
    private onPressEnd;
    private onDragStart;
    private onDrag;
    private onDragEnd;
    private setPosition;
    /**
     * Get targets within the current element position is matching
     */
    getMatchingTargets(): HTMLElement[];
    /**
     * Get element currently dragging
     */
    getElementDrag(): HTMLElement;
    /**
     * Set targets where to drop
     */
    setTargets(targets: HTMLElement[]): void;
    /**
     * Destroy the current drag&drop instance
     */
    destroy(): void;
}

class PressManager {
    private options;
    private element;
    private subPressManager;
    private delayDblPress;
    private delayLongPress;
    private nbPress;
    private offsetDrag;
    private state;
    private startPosition;
    private customFcts;
    private timeoutDblPress;
    private timeoutLongPress;
    private downEventSaved;
    private actionsName;
    private useDblPress;
    private functionsBinded;
    /**
     * @param {*} options - The options
     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage
     */
    constructor(options: PressManagerOptions);
    /**
     * Get the current element focused by the PressManager
     */
    getElement(): Element;
    private checkDragConstraint;
    private assignValueOption;
    private bindAllFunction;
    private init;
    private downAction;
    private upAction;
    private moveAction;
    private triggerEventToParent;
    private childPressStart;
    private childPressEnd;
    private childPress;
    private childDblPress;
    private childLongPress;
    private childDragStart;
    private emitTriggerFunction;
    /**
     * Destroy the Press instance byremoving all events
     */
    destroy(): void;
}

interface InternalPointerEvent extends Event {
    detail: {
        state: PressManagerState;
        customFcts: InternalCustomFunction;
        realEvent: PointerEvent;
    };
}

interface InternalCustomFunction {
    src?: PressManager;
    onDrag?: (e: PointerEvent, self: PressManager) => void;
    onDragEnd?: (e: PointerEvent, self: PressManager) => void;
    offsetDrag?: number;
}

interface PressManagerState {
    oneActionTriggered: boolean;
    isMoving: boolean;
}

interface PressManagerOptions {
    element: Element | Element[];
    onPress?: (e: PointerEvent, self: PressManager) => void;
    onPressStart?: (e: PointerEvent, self: PressManager) => void;
    onPressEnd?: (e: PointerEvent, self: PressManager) => void;
    onLongPress?: (e: PointerEvent, self: PressManager) => void;
    onDblPress?: (e: PointerEvent, self: PressManager) => void;
    onDrag?: (e: PointerEvent, self: PressManager) => void;
    onDragStart?: (e: PointerEvent, self: PressManager) => void;
    onDragEnd?: (e: PointerEvent, self: PressManager) => void;
    offsetDrag?: number;
    delayDblPress?: number;
    delayLongPress?: number;
    forceDblPress?: boolean;
}

interface Coordinate {
    x: number;
    y: number;
}

interface DragAndDropOptions {
    applyDrag?: boolean;
    element: HTMLElement;
    elementTrigger?: HTMLElement;
    offsetDrag?: number;
    shadow?: {
        enable: boolean;
        container?: HTMLElement;
        removeOnStop?: boolean;
        transform?: (el: HTMLElement) => void;
    };
    strict?: boolean;
    targets?: HTMLElement[];
    usePercent?: boolean;
    isDragEnable?: () => boolean;
    getZoom?: () => number;
    getOffsetX?: () => number;
    getOffsetY?: () => number;
    onPointerDown?: (e: PointerEvent) => void;
    onPointerUp?: (e: PointerEvent) => void;
    onStart?: (e: PointerEvent) => void;
    onMove?: (e: PointerEvent, position: Coordinate) => void;
    onStop?: (e: PointerEvent) => void;
    onDrop?: (element: HTMLElement, targets: HTMLElement[]) => void;
}

class Callback<U extends (...args: any) => T, T = void> {
    private callbacks;
    /**
     * Clear all callbacks
     */
    clear(): void;
    /**
     * Add a callback
     */
    add(cb: U): void;
    /**
     * Remove a callback
     */
    remove(cb: U): void;
    /**
     * Trigger all callbacks
     */
    trigger(args: Parameters<U>): T[];
}

class CallbackGroup<U extends (...args: any) => void> {
    private callbacks;
    /**
     * Clear all callbacks
     */
    clearAll(): void;
    /**
     * Clear all callbacks for a specific group
     */
    clear(group: string | number): void;
    /**
     * Add a callback for a group
     */
    add(group: string | number, cb: U): void;
    /**
     * Remove a callback for a group
     */
    remove(group: string | number, cb: U): void;
    /**
     * Trigger all callbacks inside a group
     */
    trigger(group: string | number, args: Parameters<U>): void;
}

class Animation {
    /**
     * Default FPS for all Animation if not set inside options
     */
    static FPS_DEFAULT: number;
    private options;
    private nextFrame;
    private fpsInterval;
    private continueAnimation;
    constructor(options: AnimationOptions);
    private animate;
    /**
     * Start the of animation
     */
    start(): void;
    /**
     * Stop the animation
     */
    stop(): void;
    /**
     * Get the FPS
     */
    getFPS(): number;
    /**
     * Set the FPS
     */
    setFPS(fps: number): void;
    /**
     * Get the animation status (true if animation is running)
     */
    isStarted(): boolean;
}

interface AnimationOptions {
    animate?: Function;
    stopped?: Function;
    fps?: number;
}

interface IData {
    /**
     * Get the unique type for the data. Define it as the fullnamespace + class name
     */
    get $type(): string;
}

class DataManager {
    private static info;
    /**
     * Register a unique string type for a data
     */
    static register($type: string, cst: new () => Data): void;
    /**
     * Get the contructor for the unique string type
     */
    static getConstructor($type: string): (new () => Data | null);
    /**
     * Clone the object to keep real type
     */
    static clone<T>(data: T): T;
    /**
     * Create an object with the type management
     * Usefull to convert object from JSON into Js class
     */
    static createObject(data: any, transfromToDate?: boolean): any;
}

@Dependances([{
    type: DataManager,
    strong: true
}])
abstract class Data implements IData {
    /**
     * The schema for the class
     */
    static get $schema(): {
        [prop: string]: string;
    };
    /**
     * The current namespace
     */
    static get Namespace(): string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    /**
     * The current namespace
     */
    get namespace(): string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    get $type(): string;
    /**
     * Get the name of the class
     */
    get className(): string;
    /**
     * Get a JSON for the current object
     */
    toJSON(): {
        $type: string;
    };
}

class RamError extends GenericError<RamErrorCode> {
}

class ResultRamWithError<T> extends ResultWithError<RamError, T> {
}

abstract class Socket implements ISocket {
    private options;
    private waitingList;
    private multipltWaitingList;
    private timeoutError;
    private memoryBeforeOpen;
    private socket;
    protected constructor();
    /**
     * Define the configuration for your websocket
     */
    protected abstract configure(options: SocketOptions): SocketOptions;
    /**
     * Configure a new Websocket
     */
    private _configure;
    /**
     * Add a new route to listen to the websocket
     */
    addRoute(newRoute: SocketRoute): void;
    /**
     * The route to remove
     * @param route - The route to remove
     */
    removeRoute(route: SocketRoute): void;
    private openCallback;
    /**
     * Try to open the websocket
     */
    open(): Promise<boolean>;
    private jsonReplacer;
    /**
     * Send a message though the websocket
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param options the options to add to the message (typically the uid)
     */
    sendMessage<T>(channelName: string, data?: T, options?: {}): void;
    /**
     * Send a message though the websocket and wait one answer give in parameters callbacks
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param callbacks The callbacks to call. With the channel as key and the callback function as value
     */
    sendMessageAndWait<T>(channelName: string, data: T, callbacks: {
        [key: string]: (data: any) => void;
    }): void;
    /**
     * Send a message though the websocket and wait answer give in parameters callbacks
     * @param channelName The channel on which the message is sent
     * @param data The data to send
     * @param callbacks The callbacks to call. With the channel as key and the callback function as value
     */
    sendMessageAndWaitMultiple<T>(channelName: string, data: T[], callbacks: {
        [key: string]: (data: any) => void;
    }): void;
    /**
     * Check if socket is ready
     */
    isReady(): boolean;
    /**
     * Callback when the websocket connection is open
     */
    protected onOpen(): void;
    private _onOpen;
    private errorOccur;
    /**
     * Callback called when the socket as an error
     */
    protected onError(event: Event): void;
    private _onError;
    /**
     * Callback called when the connection closed without calling the close function
     * By default the socket will try to reconnect each 5000ms
     */
    onClose(event: Event): void;
    private _onClose;
    /**
     * Close the current connection
     */
    close(): void;
    private onMessage;
    /**
     * Print a msg inside the console
     */
    protected log(message: {} | string): void;
}

	}

    var AvInstance: typeof Aventus.Instance;


    type ConstructorConstraint<T> = Function & { prototype: T; };

    interface DebuggerConfig {
        /** Write the compiled file inside ./compiled.js */
        writeCompiled?: boolean,
        /** Enable history for watch property and add a function getWatchHistory on this component*/
        enableWatchHistory?: boolean,
    }

    interface OverrideViewConfig {
        /** if set the component ll do a query selector else the component is the one loaded on first render */
        removeViewVariables?: string[];
    }

    interface ViewElementConfig {
        /** if set the component ll do a query selector else the component is the one loaded on first render */
        useLive?: boolean;
    }

    interface DependanceConfig {
        /** The type to load */
        type: any,
        /** The type must be loaded before the current class */
        strong?: boolean;
    }

    /**
     * Add an attribute inside on your component
     */
    function Attribute();
    /**
     * Add an attribute inside on your component with changes analyze
     */
    function Property();
    /**
     * Add an attribute inside on your component with changes analyze
     */
    function Property<T>(onChange: (component: T) => void);
    /**
     * Add a property inside a watcher to be notify of changing
     */
    function Watch();
    /**
     * Add a property inside a watcher to be notify of changing
     */
    function Watch<T>(onChange: (component: T, action: Aventus.WatchAction, path: string, value: any) => void);
    /**
     * Signal that this variable is a link to your shadowroot
     */
    function ViewElement(config?: ViewElementConfig);
    /**
     * Add foreign key reference
     */
    function ForeignKey(ref: ConstructorConstraint<Aventus.IData>);

    function StateActive(stateName: string, manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<((state: Aventus.State, slugs: Aventus.StateSlug) => void)>) => void;
    function DefaultStateActive(manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager);
    function StateInactive(stateName: string, manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<((state: Aventus.State, nextState: Aventus.State, slugs: Aventus.StateSlug) => void)>) => void;
    function DefaultStateInactive(manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager);
    function StateChange(stateName: string, manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<((state: Aventus.State, nextState: Aventus.State, slugs: Aventus.StateSlug) => boolean | Promise<boolean>)>) => void;

    /**
     * Clear parent view and use your
     */
    function OverrideView(config?: OverrideViewConfig): (<T extends ConstructorConstraint<Aventus.WebComponent>> (ConstructorConstraint: T) => T);
    /**
     * use a custom TagName
     */
    function TagName(name: string): (<T extends ConstructorConstraint<Aventus.WebComponent>> (ConstructorConstraint: T) => T);
    /**
     * Force to be required inside export
     */
    function Required(): (ConstructorConstraint: Function) => void;
    /**
     * Add debbuger action function for your component
     */
    function Debugger(config: DebuggerConfig): (ConstructorConstraint: Function) => void;


    function Dependances(info: DependanceConfig[]): (ConstructorConstraint: Function) => void;

}
//#endregion js def //
//#region js src //
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
{"namespace":"Aventus","available":[{"code":"Object.defineProperty(window, \"AvInstance\", {\r\n\tget() {return Aventus.Instance;}\r\n})","dependances":[],"fullName":"!staticClass_53b9de16-d367-4878-b684-b087ab45ff59","required":true,"noNamespace":"before"},{"code":" ","dependances":[],"fullName":"!staticClass_52024c29-ce4c-455a-a7d7-3a9e951b7e0b","required":true,"noNamespace":"before"},{"code":"class WebComponentTemplateInstance {\n    context;\n    content;\n    actions;\n    component;\n    _components;\n    firstRenderUniqueCb = {};\n    firstRenderCb = [];\n    fctsToRemove = [];\n    loopRegisteries = {};\n    firstChild;\n    lastChild;\n    loops = [];\n    constructor(context, content, actions, component, loops) {\n        this.context = context;\n        this.content = content;\n        this.actions = actions;\n        this.component = component;\n        this.loops = loops;\n        this.firstChild = content.firstChild;\n        this.lastChild = content.lastChild;\n        this.transformActionsListening();\n        this.selectElements();\n        this.bindEvents();\n    }\n    render() {\n        for (let cb of this.firstRenderCb) {\n            cb();\n        }\n        for (let key in this.firstRenderUniqueCb) {\n            this.firstRenderUniqueCb[key]();\n        }\n        this.renderSubTemplate();\n        this.context.isRendered = true;\n    }\n    destructor() {\n        this.firstChild.remove();\n        this.context.destructor();\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__watchActions'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__watchActions'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    selectElements() {\n        this._components = {};\n        let idEls = Array.from(this.content.querySelectorAll('[_id]'));\n        for (let idEl of idEls) {\n            let id = idEl.attributes['_id'].value;\n            if (!this._components[id]) {\n                this._components[id] = [];\n            }\n            this._components[id].push(idEl);\n        }\n        if (this.actions.elements) {\n            for (let element of this.actions.elements) {\n                let components = [];\n                for (let id of element.ids) {\n                    if (this._components[id]) {\n                        components = [...components, ...this._components[id]];\n                    }\n                }\n                if (element.isArray) {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components);\n                }\n                else {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components[0]);\n                }\n            }\n        }\n    }\n    bindEvents() {\n        if (this.actions.events) {\n            for (let event of this.actions.events) {\n                this.bindEvent(event);\n            }\n        }\n        if (this.actions.pressEvents) {\n            for (let event of this.actions.pressEvents) {\n                this.bindPressEvent(event);\n            }\n        }\n    }\n    bindEvent(event) {\n        if (event.isCallback) {\n            for (let el of this._components[event.id]) {\n                let cb = WebComponentTemplate.getValueFromItem(event.eventName, el);\n                cb?.add((...args) => {\n                    event.fct(this.context, args);\n                });\n            }\n        }\n        else {\n            for (let el of this._components[event.id]) {\n                el.addEventListener(event.eventName, (e) => { event.fct(e, this.context); });\n            }\n        }\n    }\n    bindPressEvent(event) {\n        let id = event['id'];\n        if (id) {\n            let clone = {};\n            for (let temp in event) {\n                if (temp != 'id') {\n                    if (event[temp] instanceof Function) {\n                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };\n                    }\n                    else {\n                        clone[temp] = event[temp];\n                    }\n                }\n            }\n            clone.element = this._components[id];\n            new PressManager(clone);\n        }\n    }\n    transformActionsListening() {\n        if (this.actions.content) {\n            for (let name in this.actions.content) {\n                for (let change of this.actions.content[name]) {\n                    this.transformChangeAction(name, change);\n                }\n            }\n        }\n        if (this.actions.injection) {\n            for (let name in this.actions.injection) {\n                for (let injection of this.actions.injection[name]) {\n                    this.transformInjectionAction(name, injection);\n                }\n            }\n        }\n        if (this.actions.bindings) {\n            for (let name in this.actions.bindings) {\n                for (let binding of this.actions.bindings[name]) {\n                    this.transformBindigAction(name, binding);\n                }\n            }\n        }\n    }\n    transformChangeAction(name, change) {\n        let key = change.id + \"_\" + change.attrName;\n        if (change.attrName == \"@HTML\") {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.innerHTML = change.render(this.context.c);\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                };\n            }\n        }\n        else if (change.isBool) {\n            this.context.addChange(name, () => {\n                for (const el of this._components[change.id]) {\n                    if (this.context.c[name]) {\n                        el.setAttribute(change.attrName, \"true\");\n                    }\n                    else {\n                        el.removeAttribute(change.attrName);\n                    }\n                }\n            });\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        if (this.context.c[name]) {\n                            el.setAttribute(change.attrName, \"true\");\n                        }\n                        else {\n                            el.removeAttribute(change.attrName);\n                        }\n                    }\n                };\n            }\n        }\n        else {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.setAttribute(change.attrName, change.render(this.context.c));\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                };\n            }\n        }\n    }\n    transformInjectionAction(name, injection) {\n        if (injection.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, injection.path)) {\n                    for (const el of this._components[injection.id]) {\n                        el[injection.injectionName] = injection.inject(this.context.c);\n                    }\n                }\n            });\n        }\n        else {\n            this.context.addChange(name, (path) => {\n                for (const el of this._components[injection.id]) {\n                    el[injection.injectionName] = injection.inject(this.context.c);\n                }\n            });\n        }\n        this.firstRenderCb.push(() => {\n            for (const el of this._components[injection.id]) {\n                el[injection.injectionName] = injection.inject(this.context.c);\n            }\n        });\n    }\n    transformBindigAction(name, binding) {\n        if (binding.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, binding.path)) {\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    for (const el of this._components[binding.id]) {\n                        WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                    }\n                }\n            });\n        }\n        else {\n            binding.path = name;\n            this.context.addChange(name, (path) => {\n                let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                for (const el of this._components[binding.id]) {\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        if (binding.isCallback) {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        let cb = WebComponentTemplate.getValueFromItem(fct, el);\n                        cb?.add((value) => {\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, value);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        else {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        el.addEventListener(fct, (e) => {\n                            let valueToSet = WebComponentTemplate.getValueFromItem(binding.valueName, e.target);\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, valueToSet);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n    }\n    renderSubTemplate() {\n        for (let loop of this.loops) {\n            let localContext = JSON.parse(JSON.stringify(this.context.schema));\n            localContext.loops.push({\n                data: loop.data,\n                index: loop.index,\n                item: loop.item\n            });\n            this.renderLoop(loop, localContext);\n            this.registerLoopWatchEvent(loop, localContext);\n        }\n    }\n    renderLoop(loop, localContext) {\n        if (this.loopRegisteries[loop.anchorId]) {\n            for (let item of this.loopRegisteries[loop.anchorId]) {\n                item.destructor();\n            }\n        }\n        this.loopRegisteries[loop.anchorId] = [];\n        let result = WebComponentTemplate.getValueFromItem(loop.data, this.context.c);\n        let anchor = this._components[loop.anchorId][0];\n        for (let i = 0; i < result.length; i++) {\n            let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: i }]);\n            let content = loop.template.template.content.cloneNode(true);\n            let actions = loop.template.actions;\n            let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n            instance.render();\n            anchor.parentNode.insertBefore(instance.content, anchor);\n            this.loopRegisteries[loop.anchorId].push(instance);\n        }\n    }\n    registerLoopWatchEvent(loop, localContext) {\n        let fullPath = loop.data;\n        let watchName = fullPath.split(\".\")[0];\n        if (!this.component['__watchActions'][watchName]) {\n            this.component['__watchActions'][watchName] = [];\n        }\n        let regex = new RegExp(fullPath.replace(/\\./g, \"\\\\.\") + \"\\\\[(\\\\d+?)\\\\]$\");\n        this.component['__watchActions'][watchName].push((element, action, path, value) => {\n            if (path == fullPath) {\n                this.renderLoop(loop, localContext);\n                return;\n            }\n            regex.lastIndex = 0;\n            let result = regex.exec(path);\n            if (result) {\n                let registry = this.loopRegisteries[loop.anchorId];\n                let index = Number(result[1]);\n                if (action == WatchAction.CREATED) {\n                    let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: index }]);\n                    let content = loop.template.template.content.cloneNode(true);\n                    let actions = loop.template.actions;\n                    let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n                    instance.render();\n                    let anchor;\n                    if (index < registry.length) {\n                        anchor = registry[index].firstChild;\n                    }\n                    else {\n                        anchor = this._components[loop.anchorId][0];\n                    }\n                    anchor.parentNode.insertBefore(instance.content, anchor);\n                    registry.splice(index, 0, instance);\n                    for (let i = index + 1; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] + 1;\n                    }\n                }\n                else if (action == WatchAction.UPDATED) {\n                    registry[index].render();\n                }\n                else if (action == WatchAction.DELETED) {\n                    registry[index].destructor();\n                    registry.splice(index, 1);\n                    for (let i = index; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] - 1;\n                    }\n                }\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.ActionEvent","isStrong":false},{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Aventus.ActionChange","isStrong":false},{"fullName":"Aventus.ActionInjection","isStrong":false},{"fullName":"Aventus.ActionBindings","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateInstance","required":false},{"code":"class WebComponentTemplateContext {\n    __changes = {};\n    component;\n    fctsToRemove = [];\n    c = {};\n    isRendered = false;\n    schema;\n    constructor(component, schema, locals) {\n        this.component = component;\n        this.schema = { ...schema };\n        this.schema.locals = [...this.schema.locals, ...locals];\n        5;\n        this.buildSchema();\n    }\n    destructor() {\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__onChangeFct'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__onChangeFct'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    buildSchema() {\n        for (let global of this.schema.globals) {\n            this.createGlobal(global);\n        }\n        for (let loop of this.schema.loops) {\n            this.createLoop(loop);\n        }\n        for (let local of this.schema.locals) {\n            this.createLocal(local);\n        }\n    }\n    createGlobal(global) {\n        let comp = this.component;\n        Object.defineProperty(this.c, global, {\n            get() {\n                return WebComponentTemplate.getValueFromItem(global, comp);\n            },\n            set(value) {\n                WebComponentTemplate.setValueToItem(global, comp, value);\n            }\n        });\n        let name = global.split(\".\")[0];\n        this.__changes[name] = [];\n        if (!this.component['__onChangeFct'][name]) {\n            this.component['__onChangeFct'][name] = [];\n        }\n        let fct = (path) => {\n            if (this.isRendered) {\n                for (let change of this.__changes[name]) {\n                    change(path);\n                }\n            }\n        };\n        this.fctsToRemove.push({ name, fct });\n        this.component['__onChangeFct'][name].push(fct);\n    }\n    createLoop(loop) {\n        Object.defineProperty(this.c, loop.item, {\n            get() {\n                let indexValue = this[loop.index];\n                return WebComponentTemplate.getValueFromItem(loop.data, this)[indexValue];\n            }\n        });\n        let name = loop.data.split(\".\")[0];\n        this.__changes[loop.item] = [];\n        this.__changes[name].push((path) => {\n            if (this.isRendered) {\n                let currentPath = `${loop.data}[${this.c[loop.index]}]`;\n                if (path.startsWith(currentPath)) {\n                    let localPath = path.replace(currentPath, loop.item);\n                    for (let change of this.__changes[loop.item]) {\n                        change(localPath);\n                    }\n                }\n            }\n        });\n    }\n    createLocal(local) {\n        let localValue = local.value;\n        let changes = this.__changes;\n        Object.defineProperty(this.c, local.name, {\n            get() {\n                return localValue;\n            },\n            set(value) {\n                localValue = value;\n                if (changes[local.name]) {\n                    for (let change of changes[local.name]) {\n                        change(local.name);\n                    }\n                }\n            }\n        });\n    }\n    addChange(on, fct) {\n        if (!this.__changes[on]) {\n            this.__changes[on] = [];\n        }\n        this.__changes[on].push(fct);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.ContextValues","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateContext","required":false},{"code":"class WebComponentTemplate {\n    static setValueToItem(path, obj, value) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (!obj[split]) {\n                obj[split] = {};\n            }\n            obj = obj[split];\n        }\n        obj[splitted[splitted.length - 1]] = value;\n    }\n    static getValueFromItem(path, obj) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (typeof obj[split] !== 'object') {\n                return undefined;\n            }\n            obj = obj[split];\n        }\n        return obj[splitted[splitted.length - 1]];\n    }\n    static validatePath(path, pathToCheck) {\n        if (path.startsWith(pathToCheck)) {\n            return true;\n        }\n        return false;\n    }\n    htmlParts = [];\n    setHTML(data) {\n        this.htmlParts.push(data);\n    }\n    generateTemplate() {\n        this.template = document.createElement('template');\n        let currentHTML = \"<slot></slot>\";\n        let previousSlots = {\n            default: '<slot></slot>'\n        };\n        for (let htmlPart of this.htmlParts) {\n            for (let blockName in htmlPart.blocks) {\n                if (!previousSlots.hasOwnProperty(blockName)) {\n                    throw \"can't found slot with name \" + blockName;\n                }\n                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);\n            }\n            for (let slotName in htmlPart.slots) {\n                previousSlots[slotName] = htmlPart.slots[slotName];\n            }\n        }\n        this.template.innerHTML = currentHTML;\n    }\n    setTemplate(template) {\n        this.template = document.createElement('template');\n        this.template.innerHTML = template;\n    }\n    contextSchema = {\n        globals: [],\n        locals: [],\n        loops: []\n    };\n    template;\n    actions = {};\n    loops = [];\n    setActions(actions) {\n        if (!this.actions) {\n            this.actions = actions;\n        }\n        else {\n            if (actions.elements) {\n                if (!this.actions.elements) {\n                    this.actions.elements = [];\n                }\n                this.actions.elements = [...actions.elements, ...this.actions.elements];\n            }\n            if (actions.events) {\n                if (!this.actions.events) {\n                    this.actions.events = [];\n                }\n                this.actions.events = [...actions.events, ...this.actions.events];\n            }\n            if (actions.pressEvents) {\n                if (!this.actions.pressEvents) {\n                    this.actions.pressEvents = [];\n                }\n                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];\n            }\n            if (actions.content) {\n                if (!this.actions.content) {\n                    this.actions.content = actions.content;\n                }\n                else {\n                    for (let contextProp in actions.content) {\n                        if (!this.actions.content[contextProp]) {\n                            this.actions.content[contextProp] = actions.content[contextProp];\n                        }\n                        else {\n                            this.actions.content[contextProp] = { ...actions.content[contextProp], ...this.actions.content[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.injection) {\n                if (!this.actions.injection) {\n                    this.actions.injection = actions.injection;\n                }\n                else {\n                    for (let contextProp in actions.injection) {\n                        if (!this.actions.injection[contextProp]) {\n                            this.actions.injection[contextProp] = actions.injection[contextProp];\n                        }\n                        else {\n                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.bindings) {\n                if (!this.actions.bindings) {\n                    this.actions.bindings = actions.bindings;\n                }\n                else {\n                    for (let contextProp in actions.bindings) {\n                        if (!this.actions.bindings[contextProp]) {\n                            this.actions.bindings[contextProp] = actions.bindings[contextProp];\n                        }\n                        else {\n                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };\n                        }\n                    }\n                }\n            }\n        }\n    }\n    setSchema(contextSchema) {\n        if (contextSchema.globals) {\n            this.contextSchema.globals = [...this.contextSchema.globals, ...contextSchema.globals];\n        }\n        if (contextSchema.locals) {\n            this.contextSchema.locals = [...this.contextSchema.locals, ...contextSchema.locals];\n        }\n        if (contextSchema.loops) {\n            this.contextSchema.loops = [...this.contextSchema.loops, ...contextSchema.loops];\n        }\n    }\n    createInstance(component) {\n        let context = new WebComponentTemplateContext(component, this.contextSchema, []);\n        let content = this.template.content.cloneNode(true);\n        let actions = this.actions;\n        let instance = new WebComponentTemplateInstance(context, content, actions, component, this.loops);\n        return instance;\n    }\n    addLoop(loop) {\n        this.loops.push(loop);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateHTML","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false},{"fullName":"HTMLTemplateElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"HTMLElement","isStrong":false}],"fullName":"Aventus.WebComponentTemplate","required":false},{"code":"class WebComponent extends HTMLElement {\n    /**\n     * Add attributes informations\n     */\n    static get observedAttributes() {\n        return [];\n    }\n    _first;\n    _isReady;\n    /**\n     * Determine if the component is ready (postCreation done)\n     */\n    get isReady() {\n        return this._isReady;\n    }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the name of the component class\n     */\n    getClassName() {\n        return this.constructor.name;\n    }\n    /**\n    * Get the unique type for the data. Define it as the namespace + class name\n    */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    __onChangeFct = {};\n    __watch;\n    __watchActions = {};\n    __watchActionsCb = {};\n    __pressManagers = [];\n    __isDefaultState = true;\n    __defaultActiveState = new Map();\n    __defaultInactiveState = new Map();\n    __statesList = {};\n    constructor() {\n        super();\n        if (this.constructor == WebComponent) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this._first = true;\n        this._isReady = false;\n        this.__renderTemplate();\n        this.__registerWatchesActions();\n        this.__registerPropertiesActions();\n        this.__createStates();\n        this.__subscribeState();\n    }\n    /**\n     * Remove all listeners\n     * State + press\n     */\n    destructor() {\n        WebComponentInstance.removeInstance(this);\n        this.__unsubscribeState();\n        for (let press of this.__pressManagers) {\n            press.destroy();\n        }\n        // TODO add missing info for destructor();\n    }\n    __addWatchesActions(name, fct) {\n        if (!this.__watchActions[name]) {\n            this.__watchActions[name] = [];\n            this.__watchActionsCb[name] = (action, path, value) => {\n                for (let fct of this.__watchActions[name]) {\n                    fct(this, action, path, value);\n                }\n                if (this.__onChangeFct[name]) {\n                    for (let fct of this.__onChangeFct[name]) {\n                        fct(path);\n                    }\n                }\n            };\n        }\n        if (fct) {\n            this.__watchActions[name].push(fct);\n        }\n    }\n    __registerWatchesActions() {\n        if (Object.keys(this.__watchActions).length > 0) {\n            if (!this.__watch) {\n                this.__watch = Watcher.get({}, (type, path, element) => {\n                    let action = this.__watchActionsCb[path.split(\".\")[0]] || this.__watchActionsCb[path.split(\"[\")[0]];\n                    action(type, path, element);\n                });\n            }\n        }\n    }\n    __addPropertyActions(name, fct) {\n        if (!this.__onChangeFct[name]) {\n            this.__onChangeFct[name] = [];\n        }\n        if (fct) {\n            this.__onChangeFct[name].push(() => {\n                fct(this);\n            });\n        }\n    }\n    __registerPropertiesActions() { }\n    static __style = ``;\n    static __template;\n    __templateInstance;\n    styleBefore() {\n        return [\"@general\"];\n    }\n    styleAfter() {\n        return [];\n    }\n    __getStyle() {\n        return [WebComponent.__style];\n    }\n    __getHtml() { }\n    __getStatic() {\n        return WebComponent;\n    }\n    static __styleSheets = {};\n    __renderStyles() {\n        let sheets = {};\n        let befores = this.styleBefore();\n        for (let before of befores) {\n            let sheet = Style.get(before);\n            if (sheet) {\n                sheets[before] = sheet;\n            }\n        }\n        let localStyle = new CSSStyleSheet();\n        let styleTxt = this.__getStyle().join(\"\\r\\n\");\n        if (styleTxt.length > 0) {\n            localStyle.replace(styleTxt);\n            sheets['@local'] = localStyle;\n        }\n        let afters = this.styleAfter();\n        for (let after of afters) {\n            let sheet = Style.get(after);\n            if (sheet) {\n                sheets[after] = sheet;\n            }\n        }\n        return sheets;\n    }\n    __renderTemplate() {\n        let staticInstance = this.__getStatic();\n        if (!staticInstance.__template) {\n            staticInstance.__template = new WebComponentTemplate();\n            this.__getHtml();\n            this.__registerTemplateAction();\n            staticInstance.__template.generateTemplate();\n            staticInstance.__styleSheets = this.__renderStyles();\n        }\n        this.__templateInstance = staticInstance.__template.createInstance(this);\n        let shadowRoot = this.attachShadow({ mode: 'open' });\n        shadowRoot.adoptedStyleSheets = Object.values(staticInstance.__styleSheets);\n        this.shadowRoot.appendChild(this.__templateInstance.content);\n        customElements.upgrade(this.shadowRoot);\n    }\n    __registerTemplateAction() {\n    }\n    connectedCallback() {\n        if (this._first) {\n            WebComponentInstance.addInstance(this);\n            this._first = false;\n            this.__defaultValues();\n            this.__upgradeAttributes();\n            this.__templateInstance.render();\n            setTimeout(() => {\n                this.postCreation();\n                this._isReady = true;\n                this.dispatchEvent(new CustomEvent('postCreationDone'));\n            });\n        }\n    }\n    __defaultValues() { }\n    __upgradeAttributes() { }\n    __listBoolProps() {\n        return [];\n    }\n    __upgradeProperty(prop) {\n        let boolProps = this.__listBoolProps();\n        if (boolProps.indexOf(prop) != -1) {\n            if (this.hasAttribute(prop) && (this.getAttribute(prop) === \"true\" || this.getAttribute(prop) === \"\")) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n            else {\n                this.removeAttribute(prop);\n                this[prop] = false;\n            }\n        }\n        else {\n            if (this.hasAttribute(prop)) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n        }\n    }\n    __getStateManager(managerClass) {\n        let mClass;\n        if (managerClass instanceof StateManager) {\n            mClass = managerClass;\n        }\n        else {\n            mClass = Instance.get(managerClass);\n        }\n        return mClass;\n    }\n    __addActiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultActiveState.has(mClass)) {\n            this.__defaultActiveState.set(mClass, []);\n        }\n        this.__defaultActiveState.get(mClass).push(cb);\n    }\n    __addInactiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultInactiveState.has(mClass)) {\n            this.__defaultInactiveState.set(mClass, []);\n        }\n        this.__defaultInactiveState.get(mClass).push(cb);\n    }\n    __addActiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).active.push(cb);\n    }\n    __addInactiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).inactive.push(cb);\n    }\n    __addAskChangeState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).askChange.push(cb);\n    }\n    __createStates() { }\n    __createStatesList(statePattern, managerClass) {\n        if (!this.__statesList[statePattern]) {\n            this.__statesList[statePattern] = new Map();\n        }\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__statesList[statePattern].has(mClass)) {\n            this.__statesList[statePattern].set(mClass, {\n                active: [],\n                inactive: [],\n                askChange: []\n            });\n        }\n    }\n    __inactiveDefaultState(managerClass) {\n        if (this.__isDefaultState) {\n            this.__isDefaultState = false;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultInactiveState.has(mClass)) {\n                let fcts = this.__defaultInactiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __activeDefaultState(nextStep, managerClass) {\n        if (!this.__isDefaultState) {\n            for (let pattern in this.__statesList) {\n                if (StateManager.canBeActivate(pattern, nextStep)) {\n                    let mClass = this.__getStateManager(managerClass);\n                    if (this.__statesList[pattern].has(mClass)) {\n                        return;\n                    }\n                }\n            }\n            this.__isDefaultState = true;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultActiveState.has(mClass)) {\n                let fcts = this.__defaultActiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __subscribeState() {\n        if (!this.isReady && this.__stateCleared) {\n            return;\n        }\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.subscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n    }\n    __stateCleared;\n    __unsubscribeState() {\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.unsubscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n        this.__stateCleared = true;\n    }\n    dateToString(d) {\n        if (d instanceof Date) {\n            return new Date(d.getTime() - (d.getTimezoneOffset() * 60000)).toISOString().split(\"T\")[0];\n        }\n        return null;\n    }\n    dateTimeToString(dt) {\n        if (dt instanceof Date) {\n            return new Date(dt.getTime() - (dt.getTimezoneOffset() * 60000)).toISOString().slice(0, -1);\n        }\n        return null;\n    }\n    stringToDate(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    stringToDateTime(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    getBoolean(val) {\n        if (val === true || val === 1 || val === 'true' || val === '') {\n            return true;\n        }\n        else if (val === false || val === 0 || val === 'false' || val === null || val === undefined) {\n            return false;\n        }\n        console.error(\"error parsing boolean value \" + val);\n        return false;\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue !== newValue || !this.isReady) {\n            if (this.__onChangeFct.hasOwnProperty(name)) {\n                for (let fct of this.__onChangeFct[name]) {\n                    fct('');\n                }\n            }\n        }\n    }\n    remove() {\n        super.remove();\n        this.postDestruction();\n    }\n    /**\n     * Function triggered when the component is removed from the DOM\n     */\n    postDestruction() { }\n    /**\n     * Function triggered the first time the component is rendering inside DOM\n     */\n    postCreation() { }\n    /**\n     * Find a parent by tagname if exist\n     */\n    findParentByTag(tagname, untilNode) {\n        return ElementExtension.findParentByTag(this, tagname, untilNode);\n    }\n    /**\n     * Find a parent by class name if exist\n     */\n    findParentByClass(classname, untilNode) {\n        return ElementExtension.findParentByClass(this, classname, untilNode);\n    }\n    /**\n     * Find a parent by type if exist\n     */\n    findParentByType(type, untilNode) {\n        return ElementExtension.findParentByType(this, type, untilNode);\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    findParents(tagname, untilNode) {\n        return ElementExtension.findParents(this, tagname, untilNode);\n    }\n    /**\n     * Check if element contains a child\n     */\n    containsChild(el) {\n        return ElementExtension.containsChild(this, el);\n    }\n    /**\n     * Get element inside slot\n     */\n    getElementsInSlot(slotName = null) {\n        return ElementExtension.getElementsInSlot(this, slotName);\n    }\n}\n","dependances":[{"fullName":"HTMLElement","isStrong":true},{"fullName":"Aventus.DefaultComponent","isStrong":true},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.WebComponentTemplate","isStrong":false},{"fullName":"Aventus.WebComponentTemplateInstance","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false},{"fullName":"Aventus.Style","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"Date","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.ElementExtension","isStrong":false},{"fullName":"Aventus.WebComponentInstance","isStrong":true}],"fullName":"Aventus.WebComponent","required":false},{"code":"class WebComponentInstance {\n    static __allDefinitions = [];\n    static __allInstances = [];\n    /**\n     * Last definition insert datetime\n     */\n    static lastDefinition = 0;\n    static registerDefinition(def) {\n        WebComponentInstance.lastDefinition = Date.now();\n        WebComponentInstance.__allDefinitions.push(def);\n    }\n    /**\n     * Get all sub classes of type\n     */\n    static getAllClassesOf(type) {\n        let result = [];\n        for (let def of WebComponentInstance.__allDefinitions) {\n            if (def.prototype instanceof type) {\n                result.push(def);\n            }\n        }\n        return result;\n    }\n    /**\n     * Get all registered definitions\n     */\n    static getAllDefinitions() {\n        return WebComponentInstance.__allDefinitions;\n    }\n    static addInstance(instance) {\n        this.__allInstances.push(instance);\n    }\n    static removeInstance(instance) {\n        let index = this.__allInstances.indexOf(instance);\n        if (index > -1) {\n            this.__allInstances.splice(index, 1);\n        }\n    }\n    static getAllInstances(type) {\n        let result = [];\n        for (let instance of this.__allInstances) {\n            if (instance instanceof type) {\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"WebComponent","isStrong":false}],"fullName":"Aventus.WebComponentInstance","required":false},{"code":"class Style {\n    static instance;\n    static defaultStyleSheets = {\n        \"@general\": `:host{display:inline-block;box-sizing:border-box}:host *{box-sizing:border-box}`\n    };\n    static store(name, content) {\n        this.getInstance().store(name, content);\n    }\n    static get(name) {\n        return this.getInstance().get(name);\n    }\n    static load(name, url) {\n        return this.getInstance().load(name, url);\n    }\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new Style();\n        }\n        return this.instance;\n    }\n    constructor() {\n        for (let name in Style.defaultStyleSheets) {\n            this.store(name, Style.defaultStyleSheets[name]);\n        }\n    }\n    stylesheets = new Map();\n    async load(name, url) {\n        try {\n            if (!this.stylesheets.has(name) || this.stylesheets.get(name).cssRules.length == 0) {\n                let txt = await (await fetch(url)).text();\n                this.store(name, txt);\n            }\n        }\n        catch (e) {\n        }\n    }\n    store(name, content) {\n        if (!this.stylesheets.has(name)) {\n            const sheet = new CSSStyleSheet();\n            sheet.replaceSync(content);\n            this.stylesheets.set(name, sheet);\n        }\n        else {\n            this.stylesheets.get(name).replaceSync(content);\n        }\n    }\n    get(name) {\n        if (!this.stylesheets.has(name)) {\n            this.store(name, \"\");\n        }\n        return this.stylesheets.get(name);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false}],"fullName":"Aventus.Style","required":false},{"code":"class ElementExtension {\n    /**\n     * Find a parent by tagname if exist Static.findParentByTag(this, \"av-img\")\n     */\n    static findParentByTag(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let checkFunc = (el) => {\n            return tagname.indexOf((el.nodeName || el.tagName).toLowerCase()) != -1;\n        };\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by class name if exist Static.findParentByClass(this, \"my-class-img\") = querySelector('.my-class-img')\n     */\n    static findParentByClass(element, classname, untilNode) {\n        let el = element;\n        if (!Array.isArray(classname)) {\n            classname = [classname];\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            for (let classnameTemp of classname) {\n                if (el['classList'] && el['classList'].contains(classnameTemp)) {\n                    return el;\n                }\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by type if exist Static.findParentyType(this, Aventus.Img)\n     */\n    static findParentByType(element, type, untilNode) {\n        let el = element;\n        let checkFunc = (el) => {\n            return false;\n        };\n        if (typeof type == \"function\" && type['prototype']['constructor']) {\n            checkFunc = (el) => {\n                if (el instanceof type) {\n                    return true;\n                }\n                return false;\n            };\n        }\n        else {\n            console.error(\"you must provide a class inside this function\");\n            return null;\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    static findParents(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let result = [];\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (tagname.indexOf((el.nodeName || el['tagName']).toLowerCase()) != -1) {\n                result.push(el);\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Check if element contains a child\n     */\n    static containsChild(element, child) {\n        var rootScope = element.getRootNode();\n        var elScope = child.getRootNode();\n        while (elScope != rootScope) {\n            if (!elScope['host']) {\n                return false;\n            }\n            child = elScope['host'];\n            elScope = elScope['host'].getRootNode();\n        }\n        return element.contains(child);\n    }\n    /**\n     * Get element inside slot\n     */\n    static getElementsInSlot(element, slotName = null) {\n        if (element.shadowRoot) {\n            let slotEl;\n            if (slotName) {\n                slotEl = element.shadowRoot.querySelector('slot[name=\"' + slotName + '\"]');\n            }\n            else {\n                slotEl = element.shadowRoot.querySelector(\"slot\");\n            }\n            while (true) {\n                if (!slotEl) {\n                    return [];\n                }\n                var listChild = Array.from(slotEl.assignedElements());\n                if (!listChild) {\n                    return [];\n                }\n                let slotFound = false;\n                for (let i = 0; i < listChild.length; i++) {\n                    if (listChild[i].nodeName == \"SLOT\") {\n                        slotEl = listChild[i];\n                        slotFound = true;\n                        break;\n                    }\n                }\n                if (!slotFound) {\n                    return listChild;\n                }\n            }\n        }\n        return [];\n    }\n    /**\n     * Get deeper element inside dom at the position X and Y\n     */\n    static getElementAtPosition(x, y, startFrom = null) {\n        var _realTarget = (el, i = 0) => {\n            if (i == 50) {\n                debugger;\n            }\n            if (el.shadowRoot && x !== undefined && y !== undefined) {\n                var newEl = el.shadowRoot.elementFromPoint(x, y);\n                if (newEl && newEl != el) {\n                    return _realTarget(newEl, i + 1);\n                }\n            }\n            return el;\n        };\n        if (startFrom == null) {\n            startFrom = document.body;\n        }\n        return _realTarget(startFrom);\n    }\n}\n","dependances":[{"fullName":"Element","isStrong":false},{"fullName":"ShadowRoot","isStrong":false},{"fullName":"HTMLSlotElement","isStrong":false},{"fullName":"HTMLElement","isStrong":false}],"fullName":"Aventus.ElementExtension","required":false},{"code":"function uuidv4() {\n    let uid = '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));\n    return uid;\n}\n","dependances":[],"fullName":"Aventus.uuidv4","required":false},{"code":"function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","dependances":[],"fullName":"Aventus.sleep","required":false},{"code":"function mergeObject(item, objJson) {\n    let props = Object.getOwnPropertyNames(item);\n    for (let prop of props) {\n        if (objJson[prop] !== undefined) {\n            let propInfo = Object.getOwnPropertyDescriptor(item, prop);\n            if (propInfo.writable) {\n                item[prop] = objJson[prop];\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"T","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false}],"fullName":"Aventus.mergeObject","required":false},{"code":"function compareObject(obj1, obj2) {\n    if (Array.isArray(obj1)) {\n        if (!obj2) {\n            obj2 = [];\n        }\n        else {\n            obj2 = obj2.slice();\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            let foundElement = false;\n            for (let j = 0; j < obj2.length; j++) {\n                if (compareObject(obj1[i], obj2[j])) {\n                    obj2.splice(j, 1);\n                    foundElement = true;\n                    break;\n                }\n            }\n            if (!foundElement) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (obj1 instanceof Date) {\n        return obj1.toString() === obj2.toString();\n    }\n    else if (typeof obj1 == 'object') {\n        if (!obj2) {\n            obj2 = {};\n        }\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (let key in obj1) {\n            if (!(key in obj2)) {\n                return false;\n            }\n            if (!compareObject(obj1[key], obj2[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return obj1 == obj2;\n    }\n}\n","dependances":[],"fullName":"Aventus.compareObject","required":false},{"code":"class StateManager {\n    subscribers = {};\n    static canBeActivate(statePattern, stateName) {\n        let stateInfo = this.prepareStateString(statePattern);\n        return stateInfo.regex.test(stateName);\n    }\n    activeState;\n    changeStateMutex = new Mutex();\n    afterStateChanged = new Callback();\n    /**\n     * Subscribe actions for a state or a state list\n     */\n    subscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to subscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (!this.subscribers.hasOwnProperty(statePattern)) {\n                let res = StateManager.prepareStateString(statePattern);\n                let isActive = this.activeState !== undefined && res.regex.test(this.activeState.name);\n                this.subscribers[statePattern] = {\n                    \"regex\": res.regex,\n                    \"params\": res.params,\n                    \"callbacks\": {\n                        \"active\": [],\n                        \"inactive\": [],\n                        \"askChange\": [],\n                    },\n                    \"isActive\": isActive,\n                };\n            }\n            if (callbacks.active) {\n                if (!Array.isArray(callbacks.active)) {\n                    callbacks.active = [callbacks.active];\n                }\n                for (let activeFct of callbacks.active) {\n                    this.subscribers[statePattern].callbacks.active.push(activeFct);\n                    if (this.subscribers[statePattern].isActive) {\n                        let slugs = this.getInternalStateSlugs(this.subscribers[statePattern], this.activeState.name);\n                        activeFct(this.activeState, slugs);\n                    }\n                }\n            }\n            if (callbacks.inactive) {\n                if (!Array.isArray(callbacks.inactive)) {\n                    callbacks.inactive = [callbacks.inactive];\n                }\n                for (let inactiveFct of callbacks.inactive) {\n                    this.subscribers[statePattern].callbacks.inactive.push(inactiveFct);\n                }\n            }\n            if (callbacks.askChange) {\n                if (!Array.isArray(callbacks.askChange)) {\n                    callbacks.askChange = [callbacks.askChange];\n                }\n                for (let askChangeFct of callbacks.askChange) {\n                    this.subscribers[statePattern].callbacks.askChange.push(askChangeFct);\n                }\n            }\n        }\n    }\n    /**\n     * Unsubscribe actions for a state or a state list\n     */\n    unsubscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to unsubscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (this.subscribers[statePattern]) {\n                if (callbacks.active) {\n                    if (!Array.isArray(callbacks.active)) {\n                        callbacks.active = [callbacks.active];\n                    }\n                    for (let activeFct of callbacks.active) {\n                        let index = this.subscribers[statePattern].callbacks.active.indexOf(activeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.active.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.inactive) {\n                    if (!Array.isArray(callbacks.inactive)) {\n                        callbacks.inactive = [callbacks.inactive];\n                    }\n                    for (let inactiveFct of callbacks.inactive) {\n                        let index = this.subscribers[statePattern].callbacks.inactive.indexOf(inactiveFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.inactive.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.askChange) {\n                    if (!Array.isArray(callbacks.askChange)) {\n                        callbacks.askChange = [callbacks.askChange];\n                    }\n                    for (let askChangeFct of callbacks.askChange) {\n                        let index = this.subscribers[statePattern].callbacks.askChange.indexOf(askChangeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.askChange.splice(index, 1);\n                        }\n                    }\n                }\n                if (this.subscribers[statePattern].callbacks.active.length === 0 &&\n                    this.subscribers[statePattern].callbacks.inactive.length === 0 &&\n                    this.subscribers[statePattern].callbacks.askChange.length === 0) {\n                    delete this.subscribers[statePattern];\n                }\n            }\n        }\n    }\n    onAfterStateChanged(cb) {\n        this.afterStateChanged.add(cb);\n    }\n    offAfterStateChanged(cb) {\n        this.afterStateChanged.remove(cb);\n    }\n    static prepareStateString(stateName) {\n        let params = [];\n        let i = 0;\n        let regexState = stateName.replace(/{.*?}/g, (group, position) => {\n            group = group.slice(1, -1);\n            let splitted = group.split(\":\");\n            let name = splitted[0].trim();\n            let type = \"string\";\n            let result = \"([^\\\\/]+)\";\n            i++;\n            if (splitted.length > 1) {\n                if (splitted[1].trim() == \"number\") {\n                    result = \"([0-9]+)\";\n                    type = \"number\";\n                }\n            }\n            params.push({\n                name,\n                type,\n                position: i\n            });\n            return result;\n        });\n        regexState = regexState.replace(/\\*/g, \".*?\");\n        regexState = \"^\" + regexState + '$';\n        return {\n            regex: new RegExp(regexState),\n            params\n        };\n    }\n    /**\n     * Activate a current state\n     */\n    async setState(state) {\n        return await this.changeStateMutex.safeRunLastAsync(async () => {\n            let stateToUse;\n            if (typeof state == \"string\") {\n                stateToUse = new EmptyState(state);\n            }\n            else {\n                stateToUse = state;\n            }\n            if (!stateToUse) {\n                this._log(\"state is undefined\", \"error\");\n                this.changeStateMutex.release();\n                return false;\n            }\n            let canChange = true;\n            if (this.activeState) {\n                let activeToInactive = [];\n                let inactiveToActive = [];\n                let triggerActive = [];\n                canChange = await this.activeState.askChange(this.activeState, stateToUse);\n                if (canChange) {\n                    for (let statePattern in this.subscribers) {\n                        let subscriber = this.subscribers[statePattern];\n                        if (subscriber.isActive) {\n                            let clone = [...subscriber.callbacks.askChange];\n                            let currentSlug = this.getInternalStateSlugs(subscriber, this.activeState.name);\n                            for (let i = 0; i < clone.length; i++) {\n                                let askChange = clone[i];\n                                if (!await askChange(this.activeState, stateToUse, currentSlug)) {\n                                    canChange = false;\n                                    break;\n                                }\n                            }\n                            let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                            if (slugs === null) {\n                                activeToInactive.push(subscriber);\n                            }\n                            else {\n                                triggerActive.push({\n                                    subscriber: subscriber,\n                                    params: slugs\n                                });\n                            }\n                        }\n                        else {\n                            let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                            if (slugs) {\n                                inactiveToActive.push({\n                                    subscriber,\n                                    params: slugs\n                                });\n                            }\n                        }\n                        if (!canChange) {\n                            break;\n                        }\n                    }\n                }\n                if (canChange) {\n                    const oldState = this.activeState;\n                    this.activeState = stateToUse;\n                    oldState.onInactivate(stateToUse);\n                    for (let subscriber of activeToInactive) {\n                        subscriber.isActive = false;\n                        let oldSlug = this.getInternalStateSlugs(subscriber, oldState.name);\n                        [...subscriber.callbacks.inactive].forEach(callback => {\n                            callback(oldState, stateToUse, oldSlug);\n                        });\n                    }\n                    for (let trigger of triggerActive) {\n                        [...trigger.subscriber.callbacks.active].forEach(callback => {\n                            callback(stateToUse, trigger.params);\n                        });\n                    }\n                    for (let trigger of inactiveToActive) {\n                        trigger.subscriber.isActive = true;\n                        [...trigger.subscriber.callbacks.active].forEach(callback => {\n                            callback(stateToUse, trigger.params);\n                        });\n                    }\n                    stateToUse.onActivate();\n                }\n            }\n            else {\n                this.activeState = stateToUse;\n                for (let key in this.subscribers) {\n                    let slugs = this.getInternalStateSlugs(this.subscribers[key], stateToUse.name);\n                    if (slugs) {\n                        this.subscribers[key].isActive = true;\n                        [...this.subscribers[key].callbacks.active].forEach(callback => {\n                            callback(stateToUse, slugs);\n                        });\n                    }\n                }\n                stateToUse.onActivate();\n            }\n            this.afterStateChanged.trigger([]);\n            return true;\n        });\n    }\n    getState() {\n        return this.activeState;\n    }\n    getInternalStateSlugs(subscriber, stateName) {\n        let matches = subscriber.regex.exec(stateName);\n        if (matches) {\n            let slugs = {};\n            for (let param of subscriber.params) {\n                if (param.type == \"number\") {\n                    slugs[param.name] = Number(matches[param.position]);\n                }\n                else {\n                    slugs[param.name] = matches[param.position];\n                }\n            }\n            return slugs;\n        }\n        return null;\n    }\n    /**\n     * Check if a state is in the subscribers and active, return true if it is, false otherwise\n     */\n    isStateActive(statePattern) {\n        return StateManager.prepareStateString(statePattern).regex.test(this.activeState.name);\n    }\n    /**\n     * Get slugs information for the current state, return null if state isn't active\n     */\n    getStateSlugs(statePattern) {\n        let prepared = StateManager.prepareStateString(statePattern);\n        return this.getInternalStateSlugs({\n            regex: prepared.regex,\n            params: prepared.params,\n            isActive: false,\n            callbacks: {\n                active: [],\n                inactive: [],\n                askChange: [],\n            }\n        }, this.activeState.name);\n    }\n    // 0 = error only / 1 = errors and warning / 2 = error, warning and logs (not implemented)\n    logLevel() {\n        return 0;\n    }\n    _log(msg, type) {\n        if (type === \"error\") {\n            console.error(msg);\n        }\n        else if (type === \"warning\" && this.logLevel() > 0) {\n            console.warn(msg);\n        }\n        else if (type === \"info\" && this.logLevel() > 1) {\n            console.log(msg);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.Subscriber","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.Mutex","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Aventus.StateAction","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Aventus.EmptyState","isStrong":false}],"fullName":"Aventus.StateManager","required":false},{"code":"class Mutex {\n    waitingList = [];\n    isLocked = false;\n    /**\n     * Wait the mutex to be free then get it\n     */\n    waitOne() {\n        return new Promise((resolve) => {\n            if (this.isLocked) {\n                this.waitingList.push((run) => {\n                    resolve(run);\n                });\n            }\n            else {\n                this.isLocked = true;\n                resolve(true);\n            }\n        });\n    }\n    /**\n     * Release the mutex\n     */\n    release() {\n        let nextFct = this.waitingList.shift();\n        if (nextFct) {\n            nextFct(true);\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Release the mutex\n     */\n    releaseOnlyLast() {\n        if (this.waitingList.length > 0) {\n            let lastFct = this.waitingList.pop();\n            for (let fct of this.waitingList) {\n                fct(false);\n            }\n            this.waitingList = [];\n            lastFct(true);\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Clear mutex\n     */\n    dispose() {\n        this.waitingList = [];\n        this.isLocked = false;\n    }\n    async safeRun(cb) {\n        let result = null;\n        await this.waitOne();\n        try {\n            result = cb.apply(null, []);\n        }\n        catch (e) {\n        }\n        await this.release();\n        return result;\n    }\n    async safeRunAsync(cb) {\n        let result = null;\n        await this.waitOne();\n        try {\n            result = await cb.apply(null, []);\n        }\n        catch (e) {\n        }\n        await this.release();\n        return result;\n    }\n    async safeRunLast(cb) {\n        let result = null;\n        if (await this.waitOne()) {\n            try {\n                result = cb.apply(null, []);\n            }\n            catch (e) {\n            }\n            await this.releaseOnlyLast();\n        }\n        return result;\n    }\n    async safeRunLastAsync(cb) {\n        let result = null;\n        if (await this.waitOne()) {\n            try {\n                result = await cb.apply(null, []);\n            }\n            catch (e) {\n            }\n            await this.releaseOnlyLast();\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Promise","isStrong":false}],"fullName":"Aventus.Mutex","required":false},{"code":"class State {\n    /**\n     * Activate a custom state inside a specific manager\n     * It ll be a generic state with no information inside exept name\n     */\n    static async activate(stateName, manager) {\n        return await new EmptyState(stateName).activate(manager);\n    }\n    /**\n     * Activate this state inside a specific manager\n     */\n    async activate(manager) {\n        return await manager.setState(this);\n    }\n    onActivate() {\n    }\n    onInactivate(nextState) {\n    }\n    async askChange(state, nextState) {\n        return true;\n    }\n}\n","dependances":[{"fullName":"Aventus.StateManager","isStrong":false}],"fullName":"Aventus.State","required":false},{"code":"class EmptyState extends State {\n    localName;\n    constructor(stateName) {\n        super();\n        this.localName = stateName;\n    }\n    /**\n     * @inheritdoc\n     */\n    get name() {\n        return this.localName;\n    }\n}\n","dependances":[{"fullName":"Aventus.State","isStrong":true}],"fullName":"Aventus.EmptyState","required":false},{"code":"class GenericRam {\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    subscribers = {\n        created: [],\n        updated: [],\n        deleted: [],\n    };\n    recordsSubscribers = new Map();\n    /**\n     * List of stored item by index key\n     */\n    records = new Map();\n    constructor() {\n        if (this.constructor == GenericRam) {\n            throw \"can't instanciate an abstract class\";\n        }\n    }\n    /**\n     * Get item id\n     */\n    getIdWithError(item) {\n        let action = new ResultRamWithError();\n        let idTemp = item[this.defineIndexKey()];\n        if (idTemp !== undefined) {\n            action.result = idTemp;\n        }\n        else {\n            action.errors.push(new RamError(RamErrorCode.noId, \"no key found for item\"));\n        }\n        return action;\n    }\n    /**\n     * Get item id\n     */\n    getId(item) {\n        let result = this.getIdWithError(item);\n        if (result.success) {\n            return result.result;\n        }\n        return null;\n    }\n    /**\n     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete\n     */\n    addRamAction(Base) {\n        let that = this;\n        return class ActionClass extends Base {\n            async update(newData = {}) {\n                let id = that.getId(this);\n                let oldData = that.records.get(id);\n                if (oldData) {\n                    that.mergeObject(oldData, newData);\n                    let result = await that.update(oldData);\n                    return result;\n                }\n                return undefined;\n            }\n            onUpdate(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).updated.includes(callback)) {\n                    that.recordsSubscribers.get(id).updated.push(callback);\n                }\n            }\n            offUpdate(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).updated.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).updated.splice(index, 1);\n                    }\n                }\n            }\n            async delete() {\n                let id = that.getId(this);\n                await that.deleteById(id);\n            }\n            onDelete(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).deleted.includes(callback)) {\n                    that.recordsSubscribers.get(id).deleted.push(callback);\n                }\n            }\n            offDelete(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).deleted.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).deleted.splice(index, 1);\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Transform the object into the object stored inside Ram\n     */\n    getObjectForRam(objJson) {\n        let T = this.addRamAction(this.getTypeForData(objJson));\n        let item = new T();\n        this.mergeObject(item, objJson);\n        return item;\n    }\n    /**\n     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced\n     */\n    addOrUpdateData(item, result) {\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    this.mergeObject(this.records.get(id), item);\n                }\n                else {\n                    let realObject = this.getObjectForRam(item);\n                    this.records.set(id, realObject);\n                }\n                result.result = this.records.get(id);\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n            }\n        }\n        catch (e) {\n            result.errors.push(new RamError(RamErrorCode.unknow, e));\n        }\n    }\n    /**\n     * Merge object and create real instance of class\n     */\n    mergeObject(item, objJson) {\n        let realObject = DataManager.createObject(objJson);\n        let props = Object.getOwnPropertyNames(item);\n        for (let prop of props) {\n            if (realObject[prop] !== undefined) {\n                let propInfo = Object.getOwnPropertyDescriptor(item, prop);\n                if (propInfo.writable) {\n                    item[prop] = realObject[prop];\n                }\n            }\n        }\n    }\n    publish(type, data) {\n        [...this.subscribers[type]].forEach(callback => callback(data));\n        if (this.recordsSubscribers.has(this.getId(data))) {\n            [...this.recordsSubscribers.get(this.getId(data))[type]].forEach(callback => callback(data));\n        }\n    }\n    subscribe(type, cb) {\n        if (!this.subscribers[type].includes(cb)) {\n            this.subscribers[type].push(cb);\n        }\n    }\n    unsubscribe(type, cb) {\n        let index = this.subscribers[type].indexOf(cb);\n        if (index != -1) {\n            this.subscribers[type].splice(index, 1);\n        }\n    }\n    /**\n    * Add a callback that ll be triggered when a new item is stored\n    */\n    onCreated(cb) {\n        this.subscribe('created', cb);\n    }\n    /**\n     * Remove a created callback\n     */\n    offCreated(cb) {\n        this.unsubscribe('created', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is updated\n     */\n    onUpdated(cb) {\n        this.subscribe('updated', cb);\n    }\n    /**\n     * Remove an updated callback\n     */\n    offUpdated(cb) {\n        this.unsubscribe('updated', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is deleted\n     */\n    onDeleted(cb) {\n        this.subscribe('deleted', cb);\n    }\n    /**\n     * Remove an deleted callback\n     */\n    offDeleted(cb) {\n        this.unsubscribe('deleted', cb);\n    }\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async get(id) {\n        return await this.getById(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async getWithError(id) {\n        return await this.getByIdWithError(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist\n     */\n    async getById(id) {\n        let action = await this.getByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Get an item by id if exist\n     */\n    async getByIdWithError(id) {\n        let action = new ResultRamWithError();\n        await this.beforeGetById(id, action);\n        if (action.success) {\n            if (this.records.has(id)) {\n                action.result = this.records.get(id);\n                await this.afterGetById(action);\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before getting an item by id\n     */\n    async beforeGetById(id, result) { }\n    ;\n    /**\n     * Trigger after getting an item by id\n     */\n    async afterGetById(result) { }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIds(ids) {\n        let result = await this.getByIdsWithError(ids);\n        if (result.success) {\n            return result.result;\n        }\n        return [];\n    }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIdsWithError(ids) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeGetByIds(ids, action);\n        if (action.success) {\n            for (let id of ids) {\n                if (this.records.has(id)) {\n                    action.result.push(this.records.get(id));\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                }\n            }\n            if (action.success) {\n                await this.afterGetByIds(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting a list of items by id\n     */\n    async beforeGetByIds(ids, result) { }\n    ;\n    /**\n     * Trigger after getting a list of items by id\n     */\n    async afterGetByIds(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAll() {\n        let result = await this.getAllWithError();\n        if (result.success) {\n            return result.result;\n        }\n        return new Map();\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAllWithError() {\n        let action = new ResultRamWithError();\n        action.result = new Map();\n        await this.beforeGetAll(action);\n        if (action.success) {\n            action.result = this.records;\n            await this.afterGetAll(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting all items inside Ram\n     */\n    async beforeGetAll(result) { }\n    ;\n    /**\n     * Trigger after getting all items inside Ram\n     */\n    async afterGetAll(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getList() {\n        let data = await this.getAll();\n        return Array.from(data.values());\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getListWithError() {\n        let action = new ResultRamWithError();\n        action.result = [];\n        let result = await this.getAllWithError();\n        if (result.success) {\n            action.result = Object.values(result.result);\n        }\n        else {\n            action.errors = result.errors;\n        }\n        return action;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createList(list) {\n        let result = await this.createListWithError(list);\n        return result.result;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeCreateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._create(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterCreateList(action);\n            }\n        }\n        return action;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async create(item, ...args) {\n        let action = await this.createWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async createWithError(item, ...args) {\n        return await this._create(item, false);\n    }\n    async _create(item, fromList) {\n        let action = new ResultRamWithError();\n        await this.beforeCreateItem(item, fromList, action);\n        if (action.success) {\n            if (action.result) {\n                item = action.result;\n            }\n            let resultTemp = this.getIdWithError(item);\n            if (resultTemp.success) {\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterCreateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('created', action.result);\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before creating a list of items\n     */\n    async beforeCreateList(list, result) {\n    }\n    ;\n    /**\n     * Trigger before creating an item\n     */\n    async beforeCreateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after creating an item\n     */\n    async afterCreateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after creating a list of items\n     */\n    async afterCreateList(result) {\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateList(list) {\n        let result = await this.updateListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeUpdateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._update(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterUpdateList(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Update an item inside ram\n     */\n    async update(item, ...args) {\n        let action = await this.updateWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Update an item inside ram\n     */\n    async updateWithError(item, ...args) {\n        return await this._update(item, false);\n    }\n    async _update(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                await this.beforeUpdateItem(item, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                if (action.result) {\n                    item = action.result;\n                }\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterUpdateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('updated', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before updating a list of items\n     */\n    async beforeUpdateList(list, result) {\n    }\n    ;\n    /**\n    * Trigger before updating an item\n    */\n    async beforeUpdateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after updating an item\n     */\n    async afterUpdateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after updating a list of items\n     */\n    async afterUpdateList(result) {\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteList(list) {\n        let result = await this.deleteListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeDeleteList(list, action);\n        for (let item of list) {\n            let resultItem = await this._delete(item, true);\n            if (resultItem.success) {\n                action.result.push(resultItem.result);\n            }\n            else {\n                action.errors = [...action.errors, ...resultItem.errors];\n            }\n        }\n        if (action.success) {\n            await this.afterDeleteList(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Delete an item inside ram\n     */\n    async delete(item, ...args) {\n        let action = await this.deleteWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    ;\n    /**\n    * Delete an item inside ram\n    */\n    async deleteWithError(item, ...args) {\n        return await this._delete(item, false);\n    }\n    ;\n    /**\n     * Delete an item by id inside ram\n     */\n    async deleteById(id) {\n        let action = await this.deleteByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n    * Delete an item by id inside ram\n    */\n    async deleteByIdWithError(id) {\n        if (this.records.has(id)) {\n            let item = this.records.get(id);\n            return await this._delete(item, false);\n        }\n        let result = new ResultRamWithError();\n        result.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + id + \" because it wasn't found inside ram\"));\n        return result;\n    }\n    async _delete(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                let oldItem = this.records.get(key);\n                await this.beforeDeleteItem(oldItem, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                this.records.delete(key);\n                action.result = oldItem;\n                await this.afterDeleteItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('deleted', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    /**\n     * Trigger before deleting a list of items\n     */\n    async beforeDeleteList(list, result) { }\n    ;\n    /**\n     * Trigger before deleting an item\n     */\n    async beforeDeleteItem(item, fromList, result) { }\n    ;\n    /**\n     * Trigger after deleting an item\n     */\n    async afterDeleteItem(result, fromList) { }\n    ;\n    /**\n     * Trigger after deleting a list of items\n     */\n    async afterDeleteList(result) { }\n}\n","dependances":[{"fullName":"Aventus.IRam","isStrong":true},{"fullName":"Aventus.RamSubscribers","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Base","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.DataManager","isStrong":false}],"fullName":"Aventus.GenericRam","required":false},{"code":"class Ram extends GenericRam {\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true}],"fullName":"Aventus.Ram","required":false},{"code":"class GenericRamWs extends GenericRam {\n    wsRoutes;\n    ws;\n    getAllDone = false;\n    constructor() {\n        super();\n        if (this.constructor == GenericRamWs) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.init();\n    }\n    init() {\n        this.ws = this.getWebSocket();\n        this.createRoutes();\n        this.addSocketCallback();\n    }\n    createRoutes() {\n        const socketActions = {\n            get: \"get\",\n            getAll: \"get/all\",\n            create: \"create\",\n            created: \"created\",\n            update: \"update\",\n            updated: \"updated\",\n            delete: \"delete\",\n            deleted: \"deleted\"\n        };\n        let temp = {};\n        let wsRouteBase = this.getWebSocketRoute();\n        if (wsRouteBase.endsWith(\"/\")) {\n            wsRouteBase = wsRouteBase.slice(0, -1);\n        }\n        for (const [key, name] of Object.entries(socketActions)) {\n            temp[key] = {\n                request: `${wsRouteBase}/${name}`,\n                multiple: `${wsRouteBase}/${name}/multiple`,\n                success: `${wsRouteBase}/${name}/success`,\n                error: `${wsRouteBase}/${name}/error`,\n            };\n        }\n        this.wsRoutes = temp;\n    }\n    addSocketCallback() {\n        let createdRoute = {\n            channel: this.wsRoutes.created.request,\n            callback: response => {\n                if (response.data) {\n                    for (let obj of response.data) {\n                        let id = this.getId(obj);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            this.addOrUpdateData(obj, result);\n                            if (result.success) {\n                                this.publish('created', this.records.get(id));\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(createdRoute);\n        let updatedRoute = {\n            channel: this.wsRoutes.updated.request,\n            callback: response => {\n                if (response.data) {\n                    for (let newData of response.data) {\n                        let id = this.getId(newData);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            if (this.records.has(id)) {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('updated', this.records.get(id));\n                                }\n                            }\n                            else {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('created', this.records.get(id));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(updatedRoute);\n        let deletedRoute = {\n            channel: this.wsRoutes.deleted.request,\n            callback: response => {\n                if (response.data) {\n                    for (let data of response.data) {\n                        let id = this.getId(data);\n                        if (this.records.has(id)) {\n                            let oldData = this.records.get(id);\n                            this.records.delete(id);\n                            this.publish('deleted', oldData);\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(deletedRoute);\n    }\n    /**\n     * Send a msg through the websocket\n     */\n    sendMsg(route, params, callbacks) {\n        this.ws.sendMessageAndWait(route, params, callbacks);\n    }\n    uniqueMsgWaiting = {};\n    /**\n     * Send a unique msg through the websocket and wait answer\n     */\n    sendUniqueMsg(route, params, callbacks) {\n        let uniqueKey = route + JSON.stringify(params);\n        if (this.uniqueMsgWaiting[uniqueKey]) {\n            for (let name in callbacks) {\n                if (this.uniqueMsgWaiting[uniqueKey][name]) {\n                    this.uniqueMsgWaiting[uniqueKey][name].push(callbacks[name]);\n                }\n                else {\n                    this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n                }\n            }\n        }\n        else {\n            let callbacksToAdd = {};\n            const createCallback = (name) => {\n                callbacksToAdd[name] = (data) => {\n                    for (let fct of this.uniqueMsgWaiting[uniqueKey][name]) {\n                        fct(data);\n                    }\n                    delete this.uniqueMsgWaiting[uniqueKey];\n                };\n            };\n            this.uniqueMsgWaiting[uniqueKey] = {};\n            for (let name in callbacks) {\n                createCallback(name);\n                this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n            }\n            this.ws.sendMessageAndWait(route, params, callbacksToAdd);\n        }\n    }\n    addRoute(newRoute) {\n        this.ws.addRoute(newRoute);\n    }\n    beforeGetById(id, result) {\n        return new Promise((resolve, reject) => {\n            if (this.records.has(id)) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.get.request, {\n                    [this.defineIndexKey()]: id\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            let resultTemp = new ResultRamWithError();\n                            this.addOrUpdateData(response.data, resultTemp);\n                            if (!resultTemp.success) {\n                                result.errors = [...result.errors, ...resultTemp.errors];\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeGetByIds(ids, result) {\n        return new Promise((resolve, reject) => {\n            let missingIds = [];\n            for (let id of ids) {\n                if (!this.records.has(id)) {\n                    missingIds.push(id);\n                }\n            }\n            if (missingIds.length > 0) {\n                this.sendUniqueMsg(this.wsRoutes.get.multiple, {\n                    [this.defineIndexKey()]: ids\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeGetAll(result) {\n        return new Promise((resolve, reject) => {\n            if (this.getAllDone) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.getAll.request, {}, {\n                    [this.wsRoutes.getAll.success]: (response) => {\n                        if (response.data) {\n                            this.getAllDone = true;\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.getAll.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeCreateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.create.request, item, {\n                    [this.wsRoutes.create.success]: (response) => {\n                        let element = response.created[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.create.error]: (response) => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeCreateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.create.multiple, list, {\n                [this.wsRoutes.create.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.created) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.create.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeUpdateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.update.request, item, {\n                    [this.wsRoutes.update.success]: (response) => {\n                        let element = response.updated[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.update.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeUpdateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.update.multiple, list, {\n                [this.wsRoutes.update.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.updated) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.update.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeDeleteItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.delete.request, item, {\n                    [this.wsRoutes.delete.success]: (response) => {\n                        resolve();\n                    },\n                    [this.wsRoutes.delete.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeDeleteList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.delete.multiple, list, {\n                [this.wsRoutes.delete.success]: (response) => {\n                    resolve();\n                },\n                [this.wsRoutes.delete.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true},{"fullName":"Aventus.RamWsRoutes","isStrong":false},{"fullName":"Aventus.Socket","isStrong":false},{"fullName":"Aventus.RamWsCallback","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Map","isStrong":false}],"fullName":"Aventus.GenericRamWs","required":false},{"code":"class RamWs extends GenericRamWs {\n}\n","dependances":[{"fullName":"Aventus.GenericRamWs","isStrong":true}],"fullName":"Aventus.RamWs","required":false},{"code":"class ResultWithError {\n    /**\n     * Determine if the action is a success\n     */\n    get success() {\n        return this.errors.length == 0;\n    }\n    /**\n     * Result\n     */\n    result;\n    /**\n     * List of errors\n     */\n    errors = [];\n}\n","dependances":[],"fullName":"Aventus.ResultWithError","required":false},{"code":"var RamErrorCode;\n(function (RamErrorCode) {\n    RamErrorCode[RamErrorCode[\"unknow\"] = 0] = \"unknow\";\n    RamErrorCode[RamErrorCode[\"noId\"] = 1] = \"noId\";\n    RamErrorCode[RamErrorCode[\"noItemInsideRam\"] = 2] = \"noItemInsideRam\";\n})(RamErrorCode || (RamErrorCode = {}));\n","dependances":[],"fullName":"Aventus.RamErrorCode","required":false},{"code":"class GenericError {\n    /**\n     * Code for the error\n     */\n    code;\n    /**\n     * Description of the error\n     */\n    message;\n    details = [];\n    constructor(code, message) {\n        this.code = code;\n        this.message = message;\n    }\n}\n","dependances":[],"fullName":"Aventus.GenericError","required":false},{"code":"class Watcher {\n    static __maxProxyData = 0;\n    /**\n     * Transform object into a watcher\n     */\n    static get(obj, onDataChanged) {\n        if (obj == undefined) {\n            console.error(\"You must define an objet / array for your proxy\");\n            return;\n        }\n        if (obj.__isProxy) {\n            obj.__subscribe(onDataChanged);\n            return obj;\n        }\n        Watcher.__maxProxyData++;\n        let setProxyPath = (newProxy, newPath) => {\n            if (newProxy instanceof Object && newProxy.__isProxy) {\n                newProxy.__path = newPath;\n                if (!newProxy.__proxyData) {\n                    newProxy.__proxyData = {};\n                }\n                if (!newProxy.__proxyData[newPath]) {\n                    newProxy.__proxyData[newPath] = [];\n                }\n                if (newProxy.__proxyData[newPath].indexOf(proxyData) == -1) {\n                    newProxy.__proxyData[newPath].push(proxyData);\n                }\n            }\n        };\n        let removeProxyPath = (oldValue, pathToDelete, recursive = true) => {\n            if (oldValue instanceof Object && oldValue.__isProxy) {\n                let allProxies = oldValue.__proxyData;\n                for (let triggerPath in allProxies) {\n                    if (triggerPath == pathToDelete) {\n                        for (let i = 0; i < allProxies[triggerPath].length; i++) {\n                            if (allProxies[triggerPath][i] == proxyData) {\n                                allProxies[triggerPath].splice(i, 1);\n                                i--;\n                            }\n                        }\n                        if (allProxies[triggerPath].length == 0) {\n                            delete allProxies[triggerPath];\n                            if (Object.keys(allProxies).length == 0) {\n                                delete oldValue.__proxyData;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        let jsonReplacer = (key, value) => {\n            if (key == \"__path\")\n                return undefined;\n            else if (key == \"__proxyData\")\n                return undefined;\n            else\n                return value;\n        };\n        let currentTrace = new Error().stack.split(\"\\n\");\n        currentTrace.shift();\n        currentTrace.shift();\n        let onlyDuringInit = true;\n        let proxyData = {\n            baseData: {},\n            id: Watcher.__maxProxyData,\n            callbacks: [onDataChanged],\n            avoidUpdate: [],\n            pathToRemove: [],\n            history: [{\n                    object: JSON.parse(JSON.stringify(obj, jsonReplacer)),\n                    trace: currentTrace,\n                    action: 'init',\n                    path: ''\n                }],\n            useHistory: false,\n            getProxyObject(target, element, prop) {\n                let newProxy;\n                if (element instanceof Object && element.__isProxy) {\n                    newProxy = element;\n                }\n                else {\n                    try {\n                        if (element instanceof Object) {\n                            newProxy = new Proxy(element, this);\n                        }\n                        else {\n                            return element;\n                        }\n                    }\n                    catch {\n                        return element;\n                    }\n                }\n                let newPath = '';\n                if (Array.isArray(target)) {\n                    if (prop != \"length\") {\n                        if (target.__path) {\n                            newPath = target.__path;\n                        }\n                        newPath += \"[\" + prop + \"]\";\n                        setProxyPath(newProxy, newPath);\n                    }\n                }\n                else if (element instanceof Date) {\n                    return element;\n                }\n                else {\n                    if (target.__path) {\n                        newPath = target.__path + '.';\n                    }\n                    newPath += prop;\n                    setProxyPath(newProxy, newPath);\n                }\n                return newProxy;\n            },\n            tryCustomFunction(target, prop, receiver) {\n                if (prop == \"__isProxy\") {\n                    return true;\n                }\n                else if (prop == \"__subscribe\") {\n                    return (cb) => {\n                        this.callbacks.push(cb);\n                    };\n                }\n                else if (prop == \"__unsubscribe\") {\n                    return (cb) => {\n                        let index = this.callbacks.indexOf(cb);\n                        if (index > -1) {\n                            this.callbacks.splice(index, 1);\n                        }\n                    };\n                }\n                else if (prop == \"__proxyId\") {\n                    return this.id;\n                }\n                else if (prop == \"getHistory\") {\n                    return () => {\n                        return this.history;\n                    };\n                }\n                else if (prop == \"clearHistory\") {\n                    this.history = [];\n                }\n                else if (prop == \"enableHistory\") {\n                    return () => {\n                        this.useHistory = true;\n                    };\n                }\n                else if (prop == \"disableHistory\") {\n                    return () => {\n                        this.useHistory = false;\n                    };\n                }\n                else if (prop == \"__getTarget\" && onlyDuringInit) {\n                    return () => {\n                        return target;\n                    };\n                }\n                return undefined;\n            },\n            get(target, prop, receiver) {\n                if (prop == \"__proxyData\") {\n                    return target[prop];\n                }\n                let customResult = this.tryCustomFunction(target, prop, receiver);\n                if (customResult !== undefined) {\n                    return customResult;\n                }\n                let element = target[prop];\n                if (typeof (element) == 'object') {\n                    return this.getProxyObject(target, element, prop);\n                }\n                else if (typeof (element) == 'function') {\n                    if (Array.isArray(target)) {\n                        let result;\n                        if (prop == 'push') {\n                            if (target.__isProxy) {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    return index;\n                                };\n                            }\n                            else {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    let proxyEl = this.getProxyObject(target, el, (index - 1));\n                                    target.splice(target.length - 1, 1, proxyEl);\n                                    trigger('CREATED', target, receiver, proxyEl, \"[\" + (index - 1) + \"]\");\n                                    return index;\n                                };\n                            }\n                        }\n                        else if (prop == 'splice') {\n                            if (target.__isProxy) {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    let path = target.__path ? target.__path : '';\n                                    for (let i = 0; i < res.length; i++) {\n                                        trigger('DELETED', target, receiver, res[i], \"[\" + index + \"]\");\n                                        removeProxyPath(res[i], path + \"[\" + (index + i) + \"]\");\n                                    }\n                                    for (let i = 0; i < insert.length; i++) {\n                                        let proxyEl = this.getProxyObject(target, insert[i], (index + i));\n                                        target.splice((index + i), 1, proxyEl);\n                                        trigger('CREATED', target, receiver, proxyEl, \"[\" + (index + i) + \"]\");\n                                    }\n                                    let fromIndex = index + insert.length;\n                                    let baseDiff = index - insert.length + res.length + 1;\n                                    for (let i = fromIndex, j = 0; i < target.length; i++, j++) {\n                                        let oldPath = path + \"[\" + (j + baseDiff) + \"]\";\n                                        removeProxyPath(target[i], oldPath, false);\n                                        let proxyEl = this.getProxyObject(target, target[i], i);\n                                        let recuUpdate = (childEl) => {\n                                            if (Array.isArray(childEl)) {\n                                                for (let i = 0; i < childEl.length; i++) {\n                                                    if (childEl[i] instanceof Object && childEl[i].__path) {\n                                                        let oldPathRecu = proxyEl[i].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[i], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[i], i);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                            else if (childEl instanceof Object && !(childEl instanceof Date)) {\n                                                for (let key in childEl) {\n                                                    if (childEl[key] instanceof Object && childEl[key].__path) {\n                                                        let oldPathRecu = proxyEl[key].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[key], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[key], key);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                        };\n                                        recuUpdate(proxyEl);\n                                    }\n                                    return res;\n                                };\n                            }\n                        }\n                        else if (prop == 'pop') {\n                            if (target.__isProxy) {\n                                result = () => {\n                                    let res = target.pop();\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = () => {\n                                    let index = target.length - 1;\n                                    let res = target.pop();\n                                    let path = target.__path ? target.__path : '';\n                                    trigger('DELETED', target, receiver, res, \"[\" + index + \"]\");\n                                    removeProxyPath(res, path + \"[\" + index + \"]\");\n                                    return res;\n                                };\n                            }\n                        }\n                        else {\n                            result = element.bind(target);\n                        }\n                        return result;\n                    }\n                    return element.bind(target);\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n                let triggerChange = false;\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        let oldValue = Reflect.get(target, prop, receiver);\n                        if (oldValue !== value) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.set(target, prop, value, receiver);\n                if (triggerChange) {\n                    let index = this.avoidUpdate.indexOf(prop);\n                    if (index == -1) {\n                        trigger('UPDATED', target, receiver, value, prop);\n                    }\n                    else {\n                        this.avoidUpdate.splice(index, 1);\n                    }\n                }\n                return result;\n            },\n            deleteProperty(target, prop) {\n                let triggerChange = false;\n                let pathToDelete = '';\n                if (prop != \"__path\") {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                pathToDelete = target.__path;\n                            }\n                            pathToDelete += \"[\" + prop + \"]\";\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            pathToDelete = target.__path + '.';\n                        }\n                        pathToDelete += prop;\n                        triggerChange = true;\n                    }\n                }\n                if (target.hasOwnProperty(prop)) {\n                    let oldValue = target[prop];\n                    delete target[prop];\n                    if (triggerChange) {\n                        trigger('DELETED', target, null, oldValue, prop);\n                        removeProxyPath(oldValue, pathToDelete);\n                    }\n                    return true;\n                }\n                return false;\n            },\n            defineProperty(target, prop, descriptor) {\n                let triggerChange = false;\n                let newPath = '';\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                newPath = target.__path;\n                            }\n                            newPath += \"[\" + prop + \"]\";\n                            if (!target.hasOwnProperty(prop)) {\n                                triggerChange = true;\n                            }\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            newPath = target.__path + '.';\n                        }\n                        newPath += prop;\n                        if (!target.hasOwnProperty(prop)) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.defineProperty(target, prop, descriptor);\n                if (triggerChange) {\n                    this.avoidUpdate.push(prop);\n                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);\n                    target[prop] = proxyEl;\n                    trigger('CREATED', target, null, proxyEl, prop);\n                }\n                return result;\n            }\n        };\n        const trigger = (type, target, receiver, value, prop) => {\n            if (target.__isProxy) {\n                return;\n            }\n            let allProxies = target.__proxyData;\n            let receiverId = 0;\n            if (receiver == null) {\n                receiverId = proxyData.id;\n            }\n            else {\n                receiverId = receiver.__proxyId;\n            }\n            if (proxyData.id == receiverId) {\n                let stacks = [];\n                let allStacks = new Error().stack.split(\"\\n\");\n                for (let i = allStacks.length - 1; i >= 0; i--) {\n                    let current = allStacks[i].trim().replace(\"at \", \"\");\n                    if (current.startsWith(\"Object.set\") || current.startsWith(\"Proxy.result\")) {\n                        break;\n                    }\n                    stacks.push(current);\n                }\n                for (let triggerPath in allProxies) {\n                    for (let currentProxyData of allProxies[triggerPath]) {\n                        let pathToSend = triggerPath;\n                        if (pathToSend != \"\") {\n                            if (Array.isArray(target)) {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \"[\" + prop + \"]\";\n                                }\n                                else {\n                                    pathToSend += prop;\n                                }\n                            }\n                            else {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \".\";\n                                }\n                                pathToSend += prop;\n                            }\n                        }\n                        else {\n                            pathToSend = prop;\n                        }\n                        if (proxyData.useHistory) {\n                            proxyData.history.push({\n                                object: JSON.parse(JSON.stringify(currentProxyData.baseData, jsonReplacer)),\n                                trace: stacks.reverse(),\n                                action: WatchAction[type],\n                                path: pathToSend\n                            });\n                        }\n                        [...currentProxyData.callbacks].forEach((cb) => {\n                            cb(WatchAction[type], pathToSend, value);\n                        });\n                    }\n                }\n            }\n        };\n        var realProxy = new Proxy(obj, proxyData);\n        proxyData.baseData = realProxy.__getTarget();\n        onlyDuringInit = false;\n        setProxyPath(realProxy, '');\n        return realProxy;\n    }\n}\n","dependances":[{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Watcher","required":false},{"code":"var WatchAction;\n(function (WatchAction) {\n    WatchAction[WatchAction[\"CREATED\"] = 0] = \"CREATED\";\n    WatchAction[WatchAction[\"UPDATED\"] = 1] = \"UPDATED\";\n    WatchAction[WatchAction[\"DELETED\"] = 2] = \"DELETED\";\n})(WatchAction || (WatchAction = {}));\n","dependances":[],"fullName":"Aventus.WatchAction","required":false},{"code":"class ResourceLoader {\n    static headerLoaded = {};\n    static headerWaiting = {};\n    /**\n     * Load the resource inside the head tag\n     */\n    static async loadInHead(options) {\n        const _options = this.prepareOptions(options);\n        if (this.headerLoaded[_options.url]) {\n            return true;\n        }\n        else if (this.headerWaiting.hasOwnProperty(_options.url)) {\n            return await this.awaitFctHead(_options.url);\n        }\n        else {\n            this.headerWaiting[_options.url] = [];\n            let tagEl;\n            if (_options.type == \"js\") {\n                tagEl = document.createElement(\"SCRIPT\");\n            }\n            else if (_options.type == \"css\") {\n                tagEl = document.createElement(\"LINK\");\n                tagEl.setAttribute(\"rel\", \"stylesheet\");\n            }\n            else {\n                throw \"unknow type \" + _options.type + \" to append into head\";\n            }\n            document.head.appendChild(tagEl);\n            let result = await this.loadTag(tagEl, _options.url);\n            this.headerLoaded[_options.url] = true;\n            this.releaseAwaitFctHead(_options.url, result);\n            return result;\n        }\n    }\n    static loadTag(tagEl, url) {\n        return new Promise((resolve, reject) => {\n            tagEl.addEventListener(\"load\", (e) => {\n                resolve(true);\n            });\n            tagEl.addEventListener(\"error\", (e) => {\n                resolve(false);\n            });\n            if (tagEl instanceof HTMLLinkElement) {\n                tagEl.setAttribute(\"href\", url);\n            }\n            else {\n                tagEl.setAttribute('src', url);\n            }\n        });\n    }\n    static releaseAwaitFctHead(url, result) {\n        if (this.headerWaiting[url]) {\n            for (let i = 0; i < this.headerWaiting[url].length; i++) {\n                this.headerWaiting[url][i](result);\n            }\n            delete this.headerWaiting[url];\n        }\n    }\n    static awaitFctHead(url) {\n        return new Promise((resolve) => {\n            this.headerWaiting[url].push((result) => {\n                resolve(result);\n            });\n        });\n    }\n    static requestLoaded = {};\n    static requestWaiting = {};\n    /**\n     *\n    */\n    static async load(options) {\n        options = this.prepareOptions(options);\n        if (this.requestLoaded[options.url]) {\n            return this.requestLoaded[options.url];\n        }\n        else if (this.requestWaiting.hasOwnProperty(options.url)) {\n            await this.awaitFct(options.url);\n            return this.requestLoaded[options.url];\n        }\n        else {\n            this.requestWaiting[options.url] = [];\n            let blob = false;\n            if (options.type == \"img\") {\n                blob = true;\n            }\n            let content = await this.fetching(options.url, blob);\n            this.requestLoaded[options.url] = content;\n            this.releaseAwaitFct(options.url);\n            return content;\n        }\n    }\n    static releaseAwaitFct(url) {\n        if (this.requestWaiting[url]) {\n            for (let i = 0; i < this.requestWaiting[url].length; i++) {\n                this.requestWaiting[url][i]();\n            }\n            delete this.requestWaiting[url];\n        }\n    }\n    static awaitFct(url) {\n        return new Promise((resolve) => {\n            this.requestWaiting[url].push(() => {\n                resolve('');\n            });\n        });\n    }\n    static async fetching(url, useBlob = false) {\n        if (useBlob) {\n            let result = await fetch(url, {\n                headers: {\n                    responseType: 'blob'\n                }\n            });\n            let blob = await result.blob();\n            return await this.readFile(blob);\n        }\n        else {\n            let result = await fetch(url);\n            return await result.text();\n        }\n    }\n    static readFile(blob) {\n        return new Promise((resolve) => {\n            var reader = new FileReader();\n            reader.onloadend = function () {\n                resolve(reader.result);\n            };\n            reader.readAsDataURL(blob);\n        });\n    }\n    static imgExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\"];\n    static prepareOptions(options) {\n        let result;\n        if (typeof options === 'string' || options instanceof String) {\n            result = {\n                url: options,\n                type: 'js'\n            };\n            let splittedURI = result.url.split('.');\n            let extension = splittedURI[splittedURI.length - 1];\n            extension = extension.split(\"?\")[0];\n            if (extension == \"svg\") {\n                result.type = 'svg';\n            }\n            else if (extension == \"js\") {\n                result.type = 'js';\n            }\n            else if (extension == \"css\") {\n                result.type = 'css';\n            }\n            else if (this.imgExtensions.indexOf(extension) != -1) {\n                result.type = 'img';\n            }\n            else {\n                throw 'unknow extension found :' + extension + \". Please define your extension inside options\";\n            }\n        }\n        else {\n            result = options;\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.ResourceLoaderHeadOptions","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.ResourceLoaderOptions","isStrong":false},{"fullName":"Blob","isStrong":false}],"fullName":"Aventus.ResourceLoader","required":false},{"code":"class ResizeObserver {\n    callback;\n    targets;\n    fpsInterval;\n    nextFrame;\n    entriesChangedEvent;\n    willTrigger;\n    static resizeObserverClassByObject = {};\n    static uniqueInstance;\n    static getUniqueInstance() {\n        if (!ResizeObserver.uniqueInstance) {\n            ResizeObserver.uniqueInstance = new window.ResizeObserver(entries => {\n                let allClasses = [];\n                for (let j = 0; j < entries.length; j++) {\n                    let entry = entries[j];\n                    let index = entry.target['sourceIndex'];\n                    if (ResizeObserver.resizeObserverClassByObject[index]) {\n                        for (let i = 0; i < ResizeObserver.resizeObserverClassByObject[index].length; i++) {\n                            let classTemp = ResizeObserver.resizeObserverClassByObject[index][i];\n                            classTemp.entryChanged(entry);\n                            if (allClasses.indexOf(classTemp) == -1) {\n                                allClasses.push(classTemp);\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < allClasses.length; i++) {\n                    allClasses[i].triggerCb();\n                }\n            });\n        }\n        return ResizeObserver.uniqueInstance;\n    }\n    constructor(options) {\n        let realOption;\n        if (options instanceof Function) {\n            realOption = {\n                callback: options,\n            };\n        }\n        else {\n            realOption = options;\n        }\n        this.callback = realOption.callback;\n        this.targets = [];\n        if (!realOption.fps) {\n            realOption.fps = 60;\n        }\n        if (realOption.fps != -1) {\n            this.fpsInterval = 1000 / realOption.fps;\n        }\n        this.nextFrame = 0;\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n    }\n    /**\n     * Observe size changing for the element\n     */\n    observe(target) {\n        if (!target[\"sourceIndex\"]) {\n            target[\"sourceIndex\"] = Math.random().toString(36);\n            this.targets.push(target);\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]] = [];\n            ResizeObserver.getUniqueInstance().observe(target);\n        }\n        if (ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].indexOf(this) == -1) {\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].push(this);\n        }\n    }\n    /**\n     * Stop observing size changing for the element\n     */\n    unobserve(target) {\n        for (let i = 0; this.targets.length; i++) {\n            let tempTarget = this.targets[i];\n            if (tempTarget == target) {\n                let position = ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].indexOf(this);\n                if (position != -1) {\n                    ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].splice(position, 1);\n                }\n                if (ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].length == 0) {\n                    delete ResizeObserver.resizeObserverClassByObject[target['sourceIndex']];\n                }\n                ResizeObserver.getUniqueInstance().unobserve(target);\n                this.targets.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Destroy the resize observer\n     */\n    disconnect() {\n        for (let i = 0; this.targets.length; i++) {\n            this.unobserve(this.targets[i]);\n        }\n    }\n    entryChanged(entry) {\n        let index = entry.target.sourceIndex;\n        this.entriesChangedEvent[index] = entry;\n    }\n    triggerCb() {\n        if (!this.willTrigger) {\n            this.willTrigger = true;\n            this._triggerCb();\n        }\n    }\n    _triggerCb() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (this.fpsInterval != -1 && elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => {\n                this._triggerCb();\n            });\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        let changed = Object.values(this.entriesChangedEvent);\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n        setTimeout(() => {\n            this.callback(changed);\n        }, 0);\n    }\n}\n","dependances":[{"fullName":"CallableFunction","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.WindowResizeObserver","isStrong":false},{"fullName":"Aventus.ResizeObserverOptions","isStrong":false}],"fullName":"Aventus.ResizeObserver","required":false},{"code":"class Instance {\n    static elements = new Map();\n    static get(type) {\n        let result = this.elements.get(type);\n        if (!result) {\n            let cst = type.prototype['constructor'];\n            result = new cst();\n            this.elements.set(type, result);\n        }\n        return result;\n    }\n    static set(el) {\n        let cst = el.constructor;\n        if (this.elements.get(cst)) {\n            return false;\n        }\n        this.elements.set(cst, el);\n        return true;\n    }\n    static destroy(el) {\n        let cst = el.constructor;\n        return this.elements.delete(cst);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.Instance","required":false},{"code":"class HttpRequest {\n    options = {};\n    url = '';\n    /**\n     * Get the right http method inside enum\n     */\n    static getMethod(method) {\n        let genericMethod = method.toLowerCase().trim();\n        if (genericMethod == \"get\") {\n            return HttpRequestMethod.GET;\n        }\n        if (genericMethod == \"post\") {\n            return HttpRequestMethod.POST;\n        }\n        if (genericMethod == \"delete\") {\n            return HttpRequestMethod.DELETE;\n        }\n        if (genericMethod == \"put\") {\n            return HttpRequestMethod.PUT;\n        }\n        if (genericMethod == \"option\") {\n            return HttpRequestMethod.OPTION;\n        }\n        console.error(\"unknow type \" + method + \". I ll return GET by default\");\n        return HttpRequestMethod.GET;\n    }\n    /**\n     * Get http method in string\n     */\n    getMethod(method) {\n        if (method == HttpRequestMethod.GET)\n            return \"GET\";\n        if (method == HttpRequestMethod.POST)\n            return \"POST\";\n        if (method == HttpRequestMethod.DELETE)\n            return \"DELETE\";\n        if (method == HttpRequestMethod.OPTION)\n            return \"OPTION\";\n        if (method == HttpRequestMethod.PUT)\n            return \"PUT\";\n        return \"GET\";\n    }\n    constructor(options) {\n        options = {\n            ...new DefaultHttpRequestOptions(),\n            ...options\n        };\n        let optionsToSend = {\n            method: this.getMethod(options.method),\n        };\n        if (options.data) {\n            if (!options.useJSON) {\n                if (options.data instanceof FormData) {\n                    optionsToSend.body = options.data;\n                }\n                else {\n                    let formData = new FormData();\n                    this.recuFillFormData(options.data, \"\", formData);\n                    optionsToSend.body = formData;\n                }\n            }\n            else {\n                optionsToSend.body = JSON.stringify(options.data);\n                optionsToSend.headers = {};\n                optionsToSend.headers['Content-Type'] = \"application/json\";\n            }\n        }\n        this.options = optionsToSend;\n        this.url = options.url;\n    }\n    recuFillFormData(data, key, form) {\n        if (typeof data === 'object' && data !== null) {\n            if (Array.isArray(data)) {\n                for (let i = 0; i < data.length; i++) {\n                    this.recuFillFormData(data[i], key + '[' + i + ']', form);\n                }\n            }\n            else if (data instanceof Date) {\n                form.append(key, data.toISOString());\n            }\n            else {\n                let props = Object.getOwnPropertyNames(data);\n                for (let prop of props) {\n                    let newKey = key === \"\" ? prop : key + '.' + prop;\n                    this.recuFillFormData(data[prop], newKey, form);\n                }\n            }\n        }\n        else {\n            form.append(key, data);\n        }\n    }\n    /**\n     * Send the http request\n     */\n    async send() {\n        let result = await fetch(this.url, this.options);\n        return result;\n    }\n    /**\n     * Send a get request\n     */\n    static async get(url) {\n        return await fetch(url, {\n            method: \"GET\"\n        });\n    }\n    /**\n     * Send a post request and wait a result in JSON format\n     */\n    static async post(url, data) {\n        let formData = new FormData();\n        for (let key in data) {\n            formData.append(key, data[key]);\n        }\n        const response = await fetch(url, {\n            method: \"POST\",\n            body: formData\n        });\n        const content = await response.json();\n        return new Promise((resolve, reject) => {\n            if (response.ok) {\n                resolve(content);\n            }\n            else {\n                reject(content);\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"RequestInit","isStrong":false},{"fullName":"Aventus.HttpRequestMethod","isStrong":false},{"fullName":"FormData","isStrong":false}],"fullName":"Aventus.HttpRequest","required":false},{"code":"var HttpRequestMethod;\n(function (HttpRequestMethod) {\n    HttpRequestMethod[HttpRequestMethod[\"GET\"] = 0] = \"GET\";\n    HttpRequestMethod[HttpRequestMethod[\"POST\"] = 1] = \"POST\";\n    HttpRequestMethod[HttpRequestMethod[\"DELETE\"] = 2] = \"DELETE\";\n    HttpRequestMethod[HttpRequestMethod[\"PUT\"] = 3] = \"PUT\";\n    HttpRequestMethod[HttpRequestMethod[\"OPTION\"] = 4] = \"OPTION\";\n})(HttpRequestMethod || (HttpRequestMethod = {}));\n","dependances":[],"fullName":"Aventus.HttpRequestMethod","required":false},{"code":"class DefaultHttpRequestOptions {\n    url = \"\";\n    method = HttpRequestMethod.GET;\n    useJSON = false;\n}\n","dependances":[{"fullName":"Aventus.HttpRequestOptions","isStrong":true},{"fullName":"Aventus.HttpRequestMethod","isStrong":false}],"fullName":"Aventus.DefaultHttpRequestOptions","required":false},{"code":"class DragAndDrop {\n    /**\n     * Default offset before drag element\n     */\n    static defaultOffsetDrag = 20;\n    pressManager;\n    options;\n    startCursorPosition;\n    startElementPosition;\n    isEnable = true;\n    constructor(options) {\n        this.options = this.getDefaultOptions();\n        this.mergeProperties(options);\n        this.mergeFunctions(options);\n        this.init();\n    }\n    getDefaultOptions() {\n        return {\n            applyDrag: true,\n            element: null,\n            elementTrigger: null,\n            offsetDrag: DragAndDrop.defaultOffsetDrag,\n            shadow: {\n                enable: false,\n                container: document.body,\n                removeOnStop: true,\n                transform: () => { }\n            },\n            strict: false,\n            targets: [],\n            usePercent: false,\n            isDragEnable: () => true,\n            getZoom: () => 1,\n            getOffsetX: () => 0,\n            getOffsetY: () => 0,\n            onPointerDown: (e) => { },\n            onPointerUp: (e) => { },\n            onStart: (e) => { },\n            onMove: (e) => { },\n            onStop: (e) => { },\n            onDrop: (element, targets) => { }\n        };\n    }\n    mergeProperties(options) {\n        if (options.element === void 0) {\n            throw \"You must define the element for the drag&drop\";\n        }\n        this.options.element = options.element;\n        if (options.elementTrigger === void 0) {\n            this.options.elementTrigger = this.options.element;\n        }\n        else {\n            this.options.elementTrigger = options.elementTrigger;\n        }\n        this.defaultMerge(options, \"applyDrag\");\n        this.defaultMerge(options, \"offsetDrag\");\n        this.defaultMerge(options, \"strict\");\n        this.defaultMerge(options, \"targets\");\n        this.defaultMerge(options, \"usePercent\");\n        if (options.shadow !== void 0) {\n            this.options.shadow.enable = options.shadow.enable;\n            if (options.shadow.container !== void 0) {\n                this.options.shadow.container = options.shadow.container;\n            }\n            else {\n                this.options.shadow.container = document.body;\n            }\n            if (options.shadow.removeOnStop !== void 0) {\n                this.options.shadow.removeOnStop = options.shadow.removeOnStop;\n            }\n            if (options.shadow.transform !== void 0) {\n                this.options.shadow.transform = options.shadow.transform;\n            }\n        }\n    }\n    mergeFunctions(options) {\n        this.defaultMerge(options, \"isDragEnable\");\n        this.defaultMerge(options, \"getZoom\");\n        this.defaultMerge(options, \"getOffsetX\");\n        this.defaultMerge(options, \"getOffsetY\");\n        this.defaultMerge(options, \"onPointerDown\");\n        this.defaultMerge(options, \"onPointerUp\");\n        this.defaultMerge(options, \"onStart\");\n        this.defaultMerge(options, \"onMove\");\n        this.defaultMerge(options, \"onStop\");\n        this.defaultMerge(options, \"onDrop\");\n    }\n    defaultMerge(options, name) {\n        if (options[name] !== void 0) {\n            this.options[name] = options[name];\n        }\n    }\n    init() {\n        this.pressManager = new PressManager({\n            element: this.options.elementTrigger,\n            onPressStart: this.onPressStart.bind(this),\n            onPressEnd: this.onPressEnd.bind(this),\n            onDragStart: this.onDragStart.bind(this),\n            onDrag: this.onDrag.bind(this),\n            onDragEnd: this.onDragEnd.bind(this),\n            offsetDrag: this.options.offsetDrag\n        });\n    }\n    draggableElement;\n    positionShadowRelativeToElement;\n    onPressStart(e) {\n        this.options.onPointerDown(e);\n    }\n    onPressEnd(e) {\n        this.options.onPointerUp(e);\n    }\n    onDragStart(e) {\n        this.isEnable = this.options.isDragEnable();\n        if (!this.isEnable) {\n            return;\n        }\n        this.draggableElement = this.options.element;\n        this.startCursorPosition = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        this.startElementPosition = {\n            x: this.draggableElement.offsetLeft,\n            y: this.draggableElement.offsetTop\n        };\n        if (this.options.shadow.enable) {\n            this.draggableElement = this.options.element.cloneNode(true);\n            let elBox = this.options.element.getBoundingClientRect();\n            let containerBox = this.options.shadow.container.getBoundingClientRect();\n            this.positionShadowRelativeToElement = {\n                x: elBox.x - containerBox.x,\n                y: elBox.y - containerBox.y\n            };\n            if (this.options.applyDrag) {\n                this.draggableElement.style.position = \"absolute\";\n                this.draggableElement.style.top = this.positionShadowRelativeToElement.y + this.options.getOffsetY() + 'px';\n                this.draggableElement.style.left = this.positionShadowRelativeToElement.x + this.options.getOffsetX() + 'px';\n            }\n            this.options.shadow.transform(this.draggableElement);\n            this.options.shadow.container.appendChild(this.draggableElement);\n        }\n        this.options.onStart(e);\n    }\n    onDrag(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let zoom = this.options.getZoom();\n        let diff = {\n            x: 0,\n            y: 0\n        };\n        if (this.options.shadow.enable) {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) + this.positionShadowRelativeToElement.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) + this.positionShadowRelativeToElement.y + this.options.getOffsetY(),\n            };\n        }\n        else {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) / zoom + this.startElementPosition.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) / zoom + this.startElementPosition.y + this.options.getOffsetY()\n            };\n        }\n        let newPos = this.setPosition(diff);\n        this.options.onMove(e, newPos);\n    }\n    onDragEnd(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let targets = this.getMatchingTargets();\n        if (this.options.shadow.enable && this.options.shadow.removeOnStop) {\n            this.draggableElement.parentNode?.removeChild(this.draggableElement);\n        }\n        if (targets.length > 0) {\n            this.options.onDrop(this.draggableElement, targets);\n        }\n        this.options.onStop(e);\n    }\n    setPosition(position) {\n        if (this.options.usePercent) {\n            let elementParent = this.draggableElement.offsetParent;\n            const percentLeft = (position.x / elementParent.offsetWidth) * 100;\n            const percentTop = (position.y / elementParent.offsetHeight) * 100;\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = percentLeft + '%';\n                this.draggableElement.style.top = percentTop + '%';\n            }\n            return {\n                x: percentLeft,\n                y: percentTop\n            };\n        }\n        else {\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = position.x + 'px';\n                this.draggableElement.style.top = position.y + 'px';\n            }\n        }\n        return position;\n    }\n    /**\n     * Get targets within the current element position is matching\n     */\n    getMatchingTargets() {\n        let matchingTargets = [];\n        for (let target of this.options.targets) {\n            const elementCoordinates = this.draggableElement.getBoundingClientRect();\n            const targetCoordinates = target.getBoundingClientRect();\n            let offsetX = this.options.getOffsetX();\n            let offsetY = this.options.getOffsetY();\n            let zoom = this.options.getZoom();\n            targetCoordinates.x += offsetX;\n            targetCoordinates.y += offsetY;\n            targetCoordinates.width *= zoom;\n            targetCoordinates.height *= zoom;\n            if (this.options.strict) {\n                if ((elementCoordinates.x >= targetCoordinates.x && elementCoordinates.x + elementCoordinates.width <= targetCoordinates.x + targetCoordinates.width) &&\n                    (elementCoordinates.y >= targetCoordinates.y && elementCoordinates.y + elementCoordinates.height <= targetCoordinates.y + targetCoordinates.height)) {\n                    matchingTargets.push(target);\n                }\n            }\n            else {\n                let elementLeft = elementCoordinates.x;\n                let elementRight = elementCoordinates.x + elementCoordinates.width;\n                let elementTop = elementCoordinates.y;\n                let elementBottom = elementCoordinates.y + elementCoordinates.height;\n                let targetLeft = targetCoordinates.x;\n                let targetRight = targetCoordinates.x + targetCoordinates.width;\n                let targetTop = targetCoordinates.y;\n                let targetBottom = targetCoordinates.y + targetCoordinates.height;\n                if (!(elementRight < targetLeft ||\n                    elementLeft > targetRight ||\n                    elementBottom < targetTop ||\n                    elementTop > targetBottom)) {\n                    matchingTargets.push(target);\n                }\n            }\n        }\n        return matchingTargets;\n    }\n    /**\n     * Get element currently dragging\n     */\n    getElementDrag() {\n        return this.draggableElement;\n    }\n    /**\n     * Set targets where to drop\n     */\n    setTargets(targets) {\n        this.options.targets = targets;\n    }\n    /**\n     * Destroy the current drag&drop instance\n     */\n    destroy() {\n        this.pressManager.destroy();\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.Coordinate","isStrong":false},{"fullName":"Aventus.DragAndDropOptions","isStrong":false}],"fullName":"Aventus.DragAndDrop","required":false},{"code":"class PressManager {\n    options;\n    element;\n    subPressManager = [];\n    delayDblPress = 150;\n    delayLongPress = 700;\n    nbPress = 0;\n    offsetDrag = 20;\n    state = {\n        oneActionTriggered: false,\n        isMoving: false,\n    };\n    startPosition = { x: 0, y: 0 };\n    customFcts = {};\n    timeoutDblPress = 0;\n    timeoutLongPress = 0;\n    downEventSaved;\n    actionsName = {\n        press: \"press\",\n        longPress: \"longPress\",\n        dblPress: \"dblPress\",\n        drag: \"drag\"\n    };\n    useDblPress = false;\n    functionsBinded = {\n        downAction: (e) => { },\n        upAction: (e) => { },\n        moveAction: (e) => { },\n        childPressStart: (e) => { },\n        childPressEnd: (e) => { },\n        childPress: (e) => { },\n        childDblPress: (e) => { },\n        childLongPress: (e) => { },\n        childDragStart: (e) => { },\n    };\n    /**\n     * @param {*} options - The options\n     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage\n     */\n    constructor(options) {\n        if (options.element === void 0) {\n            throw 'You must provide an element';\n        }\n        if (Array.isArray(options.element)) {\n            for (let el of options.element) {\n                let cloneOpt = { ...options };\n                cloneOpt.element = el;\n                this.subPressManager.push(new PressManager(cloneOpt));\n            }\n        }\n        else {\n            this.element = options.element;\n            this.checkDragConstraint(options);\n            this.assignValueOption(options);\n            this.options = options;\n            this.init();\n        }\n    }\n    /**\n     * Get the current element focused by the PressManager\n     */\n    getElement() {\n        return this.element;\n    }\n    checkDragConstraint(options) {\n        if (options.onDrag !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragStart !== void 0) {\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragEnd !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n        }\n    }\n    assignValueOption(options) {\n        if (options.delayDblPress !== undefined) {\n            this.delayDblPress = options.delayDblPress;\n        }\n        if (options.delayLongPress !== undefined) {\n            this.delayLongPress = options.delayLongPress;\n        }\n        if (options.offsetDrag !== undefined) {\n            this.offsetDrag = options.offsetDrag;\n        }\n        if (options.onDblPress !== undefined) {\n            this.useDblPress = true;\n        }\n        if (options.forceDblPress) {\n            this.useDblPress = true;\n        }\n    }\n    bindAllFunction() {\n        this.functionsBinded.downAction = this.downAction.bind(this);\n        this.functionsBinded.moveAction = this.moveAction.bind(this);\n        this.functionsBinded.upAction = this.upAction.bind(this);\n        this.functionsBinded.childDblPress = this.childDblPress.bind(this);\n        this.functionsBinded.childDragStart = this.childDragStart.bind(this);\n        this.functionsBinded.childLongPress = this.childLongPress.bind(this);\n        this.functionsBinded.childPress = this.childPress.bind(this);\n        this.functionsBinded.childPressStart = this.childPressStart.bind(this);\n        this.functionsBinded.childPressEnd = this.childPressEnd.bind(this);\n    }\n    init() {\n        this.bindAllFunction();\n        this.element.addEventListener(\"pointerdown\", this.functionsBinded.downAction);\n        this.element.addEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n        this.element.addEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n        this.element.addEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n        this.element.addEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n        this.element.addEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n        this.element.addEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n    }\n    downAction(e) {\n        this.downEventSaved = e;\n        e.stopImmediatePropagation();\n        this.customFcts = {};\n        if (this.nbPress == 0) {\n            this.state.oneActionTriggered = false;\n            clearTimeout(this.timeoutDblPress);\n        }\n        this.startPosition = { x: e.pageX, y: e.pageY };\n        document.addEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.addEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        this.timeoutLongPress = setTimeout(() => {\n            if (!this.state.oneActionTriggered) {\n                if (this.options.onLongPress) {\n                    this.state.oneActionTriggered = true;\n                    this.options.onLongPress(e, this);\n                    this.triggerEventToParent(this.actionsName.longPress, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"longpress\", e);\n                }\n            }\n        }, this.delayLongPress);\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e, this);\n            this.emitTriggerFunction(\"pressstart\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressstart\", e);\n        }\n    }\n    upAction(e) {\n        e.stopImmediatePropagation();\n        document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        clearTimeout(this.timeoutLongPress);\n        if (this.state.isMoving) {\n            this.state.isMoving = false;\n            if (this.options.onDragEnd) {\n                this.options.onDragEnd(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDragEnd) {\n                this.customFcts.onDragEnd(e, this.customFcts.src);\n            }\n        }\n        else {\n            if (this.useDblPress) {\n                this.nbPress++;\n                if (this.nbPress == 2) {\n                    if (!this.state.oneActionTriggered) {\n                        this.state.oneActionTriggered = true;\n                        this.nbPress = 0;\n                        if (this.options.onDblPress) {\n                            this.options.onDblPress(e, this);\n                            this.triggerEventToParent(this.actionsName.dblPress, e);\n                        }\n                        else {\n                            this.emitTriggerFunction(\"dblpress\", e);\n                        }\n                    }\n                }\n                else if (this.nbPress == 1) {\n                    this.timeoutDblPress = setTimeout(() => {\n                        this.nbPress = 0;\n                        if (!this.state.oneActionTriggered) {\n                            if (this.options.onPress) {\n                                this.state.oneActionTriggered = true;\n                                this.options.onPress(e, this);\n                                this.triggerEventToParent(this.actionsName.press, e);\n                            }\n                            else {\n                                this.emitTriggerFunction(\"press\", e);\n                            }\n                        }\n                    }, this.delayDblPress);\n                }\n            }\n            else {\n                if (!this.state.oneActionTriggered) {\n                    if (this.options.onPress) {\n                        this.state.oneActionTriggered = true;\n                        this.options.onPress(e, this);\n                        this.triggerEventToParent(this.actionsName.press, e);\n                    }\n                    else {\n                        this.emitTriggerFunction(\"press\", e);\n                    }\n                }\n            }\n        }\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e, this);\n            this.emitTriggerFunction(\"pressend\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressend\", e);\n        }\n    }\n    moveAction(e) {\n        if (!this.state.isMoving && !this.state.oneActionTriggered) {\n            e.stopImmediatePropagation();\n            let xDist = e.pageX - this.startPosition.x;\n            let yDist = e.pageY - this.startPosition.y;\n            let distance = Math.sqrt(xDist * xDist + yDist * yDist);\n            if (distance > this.offsetDrag) {\n                this.state.oneActionTriggered = true;\n                if (this.options.onDragStart) {\n                    this.state.isMoving = true;\n                    this.options.onDragStart(this.downEventSaved, this);\n                    this.triggerEventToParent(this.actionsName.drag, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"dragstart\", this.downEventSaved);\n                }\n            }\n        }\n        else if (this.state.isMoving) {\n            if (this.options.onDrag) {\n                this.options.onDrag(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDrag) {\n                this.customFcts.onDrag(e, this.customFcts.src);\n            }\n        }\n    }\n    triggerEventToParent(eventName, pointerEvent) {\n        if (this.element.parentNode) {\n            this.element.parentNode.dispatchEvent(new CustomEvent(\"pressaction_trigger\", {\n                bubbles: true,\n                cancelable: false,\n                composed: true,\n                detail: {\n                    target: this.element,\n                    eventName: eventName,\n                    realEvent: pointerEvent\n                }\n            }));\n        }\n    }\n    childPressStart(e) {\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e.detail.realEvent, this);\n        }\n    }\n    childPressEnd(e) {\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e.detail.realEvent, this);\n        }\n    }\n    childPress(e) {\n        if (this.options.onPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.press, e.detail.realEvent);\n        }\n    }\n    childDblPress(e) {\n        if (this.options.onDblPress) {\n            e.stopImmediatePropagation();\n            if (e.detail.state) {\n                e.detail.state.oneActionTriggered = true;\n            }\n            this.options.onDblPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.dblPress, e.detail.realEvent);\n        }\n    }\n    childLongPress(e) {\n        if (this.options.onLongPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onLongPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.longPress, e.detail.realEvent);\n        }\n    }\n    childDragStart(e) {\n        if (this.options.onDragStart) {\n            e.stopImmediatePropagation();\n            e.detail.state.isMoving = true;\n            e.detail.customFcts.src = this;\n            e.detail.customFcts.onDrag = this.options.onDrag;\n            e.detail.customFcts.onDragEnd = this.options.onDragEnd;\n            e.detail.customFcts.offsetDrag = this.options.offsetDrag;\n            this.options.onDragStart(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.drag, e.detail.realEvent);\n        }\n    }\n    emitTriggerFunction(action, e, el = null) {\n        let ev = new CustomEvent(\"trigger_pointer_\" + action, {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n            detail: {\n                state: this.state,\n                customFcts: this.customFcts,\n                realEvent: e\n            }\n        });\n        if (!el) {\n            el = this.element;\n        }\n        el.dispatchEvent(ev);\n    }\n    /**\n     * Destroy the Press instance byremoving all events\n     */\n    destroy() {\n        for (let sub of this.subPressManager) {\n            sub.destroy();\n        }\n        if (this.element) {\n            this.element.removeEventListener(\"pointerdown\", this.functionsBinded.downAction);\n            this.element.removeEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n            this.element.removeEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n            this.element.removeEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n            this.element.removeEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n            this.element.removeEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n            this.element.removeEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.PressManagerState","isStrong":false},{"fullName":"Aventus.InternalCustomFunction","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.InternalPointerEvent","isStrong":false}],"fullName":"Aventus.PressManager","required":false},{"code":"class Callback {\n    callbacks = [];\n    /**\n     * Clear all callbacks\n     */\n    clear() {\n        this.callbacks = [];\n    }\n    /**\n     * Add a callback\n     */\n    add(cb) {\n        this.callbacks.push(cb);\n    }\n    /**\n     * Remove a callback\n     */\n    remove(cb) {\n        let index = this.callbacks.indexOf(cb);\n        if (index != -1) {\n            this.callbacks.splice(index, 1);\n        }\n    }\n    /**\n     * Trigger all callbacks\n     */\n    trigger(args) {\n        let result = [];\n        for (let callback of this.callbacks) {\n            result.push(callback.apply(null, args));\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.Callback","required":false},{"code":"class CallbackGroup {\n    callbacks = {};\n    /**\n     * Clear all callbacks\n     */\n    clearAll() {\n        this.callbacks = {};\n    }\n    /**\n     * Clear all callbacks for a specific group\n     */\n    clear(group) {\n        delete this.callbacks[group];\n    }\n    /**\n     * Add a callback for a group\n     */\n    add(group, cb) {\n        if (!this.callbacks[group]) {\n            this.callbacks[group] = [];\n        }\n        this.callbacks[group].push(cb);\n    }\n    /**\n     * Remove a callback for a group\n     */\n    remove(group, cb) {\n        if (this.callbacks[group]) {\n            let index = this.callbacks[group].indexOf(cb);\n            if (index != -1) {\n                this.callbacks[group].splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Trigger all callbacks inside a group\n     */\n    trigger(group, args) {\n        if (this.callbacks[group]) {\n            for (let callback of this.callbacks[group]) {\n                callback.apply(null, args);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.CallbackGroup","required":false},{"code":"class Animation {\n    /**\n     * Default FPS for all Animation if not set inside options\n     */\n    static FPS_DEFAULT = 60;\n    options;\n    nextFrame;\n    fpsInterval;\n    continueAnimation = false;\n    constructor(options) {\n        if (!options.animate) {\n            options.animate = () => { };\n        }\n        if (!options.stopped) {\n            options.stopped = () => { };\n        }\n        if (!options.fps) {\n            options.fps = Animation.FPS_DEFAULT;\n        }\n        this.options = options;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    animate() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => this.animate());\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        setTimeout(() => {\n            this.options.animate();\n        }, 0);\n        if (this.continueAnimation) {\n            requestAnimationFrame(() => this.animate());\n        }\n        else {\n            this.options.stopped();\n        }\n    }\n    /**\n     * Start the of animation\n     */\n    start() {\n        if (this.continueAnimation == false) {\n            this.continueAnimation = true;\n            this.nextFrame = window.performance.now();\n            this.animate();\n        }\n    }\n    /**\n     * Stop the animation\n     */\n    stop() {\n        this.continueAnimation = false;\n    }\n    /**\n     * Get the FPS\n     */\n    getFPS() {\n        return this.options.fps;\n    }\n    /**\n     * Set the FPS\n     */\n    setFPS(fps) {\n        this.options.fps = fps;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    /**\n     * Get the animation status (true if animation is running)\n     */\n    isStarted() {\n        return this.continueAnimation;\n    }\n}\n","dependances":[{"fullName":"Aventus.AnimationOptions","isStrong":false}],"fullName":"Aventus.Animation","required":false},{"code":"class Data {\n    /**\n     * The schema for the class\n     */\n    static get $schema() { return {}; }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * Get the name of the class\n     */\n    get className() {\n        return this.constructor.name;\n    }\n    /**\n     * Get a JSON for the current object\n     */\n    toJSON() {\n        let result = { $type: this.$type };\n        let props = Object.getOwnPropertyNames(this);\n        for (let prop of props) {\n            let propInfo = Object.getOwnPropertyDescriptor(this, prop);\n            if (propInfo.writable) {\n                result[prop] = this[prop];\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Aventus.DataManager","isStrong":false}],"fullName":"Aventus.Data","required":false},{"code":"class DataManager {\n    static info = new Map();\n    /**\n     * Register a unique string type for a data\n     */\n    static register($type, cst) {\n        this.info.set($type, cst);\n    }\n    /**\n     * Get the contructor for the unique string type\n     */\n    static getConstructor($type) {\n        let result = this.info.get($type);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Clone the object to keep real type\n     */\n    static clone(data) {\n        return this.createObject(JSON.parse(JSON.stringify(data)));\n    }\n    /**\n     * Create an object with the type management\n     * Usefull to convert object from JSON into Js class\n     */\n    static createObject(data, transfromToDate = false) {\n        if (typeof data === 'object' && data !== null) {\n            if (data instanceof Date) {\n                return data;\n            }\n            if (Array.isArray(data)) {\n                let result = [];\n                for (let element of data) {\n                    result.push(this.createObject(element));\n                }\n                return result;\n            }\n            if (data.$type) {\n                let cst = DataManager.getConstructor(data.$type);\n                if (cst) {\n                    let obj = new cst();\n                    let props = Object.getOwnPropertyNames(obj);\n                    for (let prop of props) {\n                        if (data[prop] !== undefined) {\n                            let propInfo = Object.getOwnPropertyDescriptor(obj, prop);\n                            if (propInfo.writable) {\n                                if (obj[prop] instanceof Date) {\n                                    obj[prop] = this.createObject(data[prop], true);\n                                }\n                                else {\n                                    obj[prop] = this.createObject(data[prop]);\n                                }\n                            }\n                        }\n                    }\n                    return obj;\n                }\n            }\n            else {\n                let result = {};\n                for (let key in data) {\n                    result[key] = this.createObject(data[key]);\n                }\n                return result;\n            }\n        }\n        else if (transfromToDate && typeof data === \"string\") {\n            return new Date(data);\n        }\n        return data;\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.DataManager","required":false},{"code":"class RamError extends GenericError {\n}\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Aventus.RamErrorCode","isStrong":true}],"fullName":"Aventus.RamError","required":false},{"code":"class ResultRamWithError extends ResultWithError {\n}\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"Aventus.RamError","isStrong":true}],"fullName":"Aventus.ResultRamWithError","required":false},{"code":"class Socket {\n    options;\n    waitingList = {};\n    multipltWaitingList = {};\n    timeoutError;\n    memoryBeforeOpen = [];\n    socket;\n    constructor() {\n        this._configure(this.configure({}));\n    }\n    /**\n     * Configure a new Websocket\n     */\n    _configure(options = {}) {\n        if (!options.host) {\n            options.host = window.location.hostname;\n        }\n        if (!options.hasOwnProperty('useHttps')) {\n            options.useHttps = window.location.protocol == \"https:\";\n        }\n        if (!options.port) {\n            if (window.location.port) {\n                options.port = parseInt(window.location.port);\n            }\n            else {\n                options.port = options.useHttps ? 443 : 80;\n            }\n        }\n        if (!options.routes) {\n            options.routes = {};\n        }\n        if (!options.socketName) {\n            options.socketName = \"\";\n        }\n        this.options = options;\n    }\n    /**\n     * Add a new route to listen to the websocket\n     */\n    addRoute(newRoute) {\n        if (!this.options.routes.hasOwnProperty(newRoute.channel)) {\n            this.options.routes[newRoute.channel] = [];\n        }\n        this.options.routes[newRoute.channel].push(newRoute);\n    }\n    /**\n     * The route to remove\n     * @param route - The route to remove\n     */\n    removeRoute(route) {\n        let index = this.options.routes[route.channel].indexOf(route);\n        if (index != -1) {\n            this.options.routes[route.channel].splice(index, 1);\n        }\n    }\n    openCallback;\n    /**\n     * Try to open the websocket\n     */\n    open() {\n        return new Promise((resolve) => {\n            try {\n                if (this.socket) {\n                    this.socket.close();\n                }\n                let protocol = \"ws\";\n                if (this.options.useHttps) {\n                    protocol = \"wss\";\n                }\n                let url = protocol + \"://\" + this.options.host + \":\" + this.options.port + \"/ws/\" + this.options.socketName;\n                this.log(url);\n                this.openCallback = (isOpen) => {\n                    resolve(isOpen);\n                };\n                this.socket = new WebSocket(url);\n                this.socket.onopen = this._onOpen.bind(this);\n                this.socket.onclose = this._onClose.bind(this);\n                this.socket.onerror = this._onError.bind(this);\n                this.socket.onmessage = this.onMessage.bind(this);\n            }\n            catch (e) {\n                console.log(e);\n                resolve(false);\n            }\n        });\n    }\n    jsonReplacer(key, value) {\n        if (this[key] instanceof Date && this[key].getFullYear() < 100) {\n            return \"0001-01-01T00:00:00\";\n        }\n        return value;\n    }\n    /**\n     * Send a message though the websocket\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param options the options to add to the message (typically the uid)\n     */\n    sendMessage(channelName, data = null, options = {}) {\n        if (this.socket && this.socket.readyState == 1) {\n            let message = {\n                channel: channelName,\n            };\n            for (let key in options) {\n                message[key] = options[key];\n            }\n            if (data) {\n                message.data = data;\n                this.log(message);\n                if (typeof data != 'string') {\n                    message.data = JSON.stringify(data, this.jsonReplacer);\n                }\n            }\n            else {\n                this.log(message);\n            }\n            this.socket.send(JSON.stringify(message));\n        }\n        else {\n            this.log('Socket not ready ! Please ensure that it is open and ready to send message');\n            this.memoryBeforeOpen.push({\n                channelName: channelName,\n                data: data,\n                options: options\n            });\n        }\n    }\n    /**\n     * Send a message though the websocket and wait one answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWait(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.waitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    ;\n    /**\n     * Send a message though the websocket and wait answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWaitMultiple(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.multipltWaitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    /**\n     * Check if socket is ready\n     */\n    isReady() {\n        if (this.socket && this.socket.readyState == 1) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Callback when the websocket connection is open\n     */\n    onOpen() {\n    }\n    _onOpen() {\n        if (this.socket && this.socket.readyState == 1) {\n            if (this.openCallback) {\n                this.openCallback(true);\n                this.openCallback = null;\n            }\n            this.log('Connection successfully established !' + this.options.host + \":\" + this.options.port);\n            window.clearTimeout(this.timeoutError);\n            this.onOpen();\n            for (let i = 0; i < this.memoryBeforeOpen.length; i++) {\n                this.sendMessage(this.memoryBeforeOpen[i].channelName, this.memoryBeforeOpen[i].data, this.memoryBeforeOpen[i].options);\n            }\n            this.memoryBeforeOpen = [];\n        }\n        else {\n            if (this.openCallback) {\n                this.openCallback(false);\n                this.openCallback = null;\n            }\n        }\n    }\n    errorOccur;\n    /**\n     * Callback called when the socket as an error\n     */\n    onError(event) {\n    }\n    _onError(event) {\n        this.errorOccur = true;\n        if (this.openCallback) {\n            this.openCallback(false);\n            this.openCallback = null;\n            return;\n        }\n        this.log('An error has occured');\n        this.onError(event);\n    }\n    /**\n     * Callback called when the connection closed without calling the close function\n     * By default the socket will try to reconnect each 5000ms\n     */\n    onClose(event) {\n        let reopenInterval = setInterval(async () => {\n            console.warn(\"try reopen socket \");\n            if (await this.open()) {\n                clearInterval(reopenInterval);\n            }\n        }, 5000);\n    }\n    _onClose(event) {\n        if (this.errorOccur) {\n            this.errorOccur = false;\n            return;\n        }\n        this.log('Closing connection');\n        this.onClose(event);\n    }\n    /**\n     * Close the current connection\n     */\n    close() {\n        if (this.socket) {\n            this.socket.onclose = null;\n            this.socket.onerror = null;\n            this.socket.onmessage = null;\n            this.socket.onopen = null;\n            this.socket.close();\n            delete this.socket;\n        }\n    }\n    onMessage(event) {\n        let response = JSON.parse(event.data);\n        this.log(response);\n        response.data = JSON.parse(response.data);\n        if (this.options.routes.hasOwnProperty(response.channel)) {\n            this.options.routes[response.channel].forEach(element => {\n                element.callback(response.data);\n            });\n        }\n        if (response.uid) {\n            if (this.waitingList.hasOwnProperty(response.uid)) {\n                let group = this.waitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    group[response.channel](response.data);\n                }\n                delete this.waitingList[response.uid];\n            }\n            else if (this.multipltWaitingList.hasOwnProperty(response.uid)) {\n                let group = this.multipltWaitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    try {\n                        group[response.channel](response.data);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                }\n                delete this.multipltWaitingList[response.uid];\n            }\n        }\n    }\n    /**\n     * Print a msg inside the console\n     */\n    log(message) {\n        if (this.options.log) {\n            const now = new Date();\n            const hours = (now.getHours()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const minutes = (now.getMinutes()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const seconds = (now.getSeconds()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            if (message instanceof Object) {\n                let cloneMessage = JSON.parse(JSON.stringify(message, this.jsonReplacer));\n                if (cloneMessage.data && typeof cloneMessage.data == 'string') {\n                    cloneMessage.data = JSON.parse(cloneMessage.data);\n                }\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, cloneMessage);\n            }\n            else {\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, message);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.ISocket","isStrong":true},{"fullName":"Aventus.SocketOptions","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.SocketMessage","isStrong":false},{"fullName":"Event","isStrong":false},{"fullName":"MessageEvent","isStrong":false}],"fullName":"Aventus.Socket","required":false}],"existing":[{"fullName":"Aventus.Loop","dependances":[]},{"fullName":"Aventus.ActionEventCallback","dependances":[]},{"fullName":"Aventus.ActionEventListener","dependances":[]},{"fullName":"Aventus.ActionBindings","dependances":[]},{"fullName":"Aventus.ActionInjection","dependances":[]},{"fullName":"Aventus.ActionChange","dependances":[]},{"fullName":"Aventus.ActionEvent","dependances":[]},{"fullName":"Aventus.ContextValues","dependances":[]},{"fullName":"Aventus.Actions","dependances":[]},{"fullName":"Aventus.ContextSchema","dependances":[]},{"fullName":"Aventus.WebComponentTemplateHTML","dependances":[]},{"fullName":"Aventus.DefaultComponent","dependances":[]},{"fullName":"Aventus.DebuggerConfig","dependances":[]},{"fullName":"Aventus.StateAskChangeFct","dependances":[]},{"fullName":"Aventus.StateInactivationFct","dependances":[]},{"fullName":"Aventus.StateActivationFct","dependances":[]},{"fullName":"Aventus.StateSlug","dependances":[]},{"fullName":"Aventus.StateAction","dependances":[]},{"fullName":"Aventus.Subscriber","dependances":[]},{"fullName":"Aventus.SocketMessage","dependances":[]},{"fullName":"Aventus.SocketRoute","dependances":[]},{"fullName":"Aventus.SocketOptions","dependances":[]},{"fullName":"Aventus.ISocket","dependances":[]},{"fullName":"Aventus.RamWsCallback","dependances":[]},{"fullName":"Aventus.RamWsRoute","dependances":[]},{"fullName":"Aventus.RamWsRoutes","dependances":[]},{"fullName":"Aventus.KeysObject","dependances":[]},{"fullName":"Aventus.RamItem","dependances":[]},{"fullName":"Aventus.RamSubscribers","dependances":[]},{"fullName":"Aventus.IRamAction","dependances":[]},{"fullName":"Aventus.IRam","dependances":[]},{"fullName":"Aventus.ResourceLoaderHeadOptions","dependances":[]},{"fullName":"Aventus.ResourceLoaderOptions","dependances":[]},{"fullName":"Aventus.WindowResizeObserver","dependances":[]},{"fullName":"Aventus.ResizeObserverOptions","dependances":[]},{"fullName":"Aventus.Pointer","dependances":[]},{"fullName":"Aventus.HttpRequestOptions","dependances":[]},{"fullName":"Aventus.InternalPointerEvent","dependances":[{"fullName":"Event","isStrong":true}]},{"fullName":"Aventus.InternalCustomFunction","dependances":[]},{"fullName":"Aventus.PressManagerState","dependances":[]},{"fullName":"Aventus.PressManagerOptions","dependances":[]},{"fullName":"Aventus.Coordinate","dependances":[]},{"fullName":"Aventus.DragAndDropOptions","dependances":[]},{"fullName":"Aventus.AnimationOptions","dependances":[]},{"fullName":"Aventus.IData","dependances":[]}]}
=======
{"namespace":"Aventus","available":[{"code":"Object.defineProperty(window, \"AvInstance\", {\r\n\tget() {return Aventus.Instance;}\r\n})","dependances":[],"fullName":"!staticClass_217d20ec-32b7-49fe-acaf-144a5bd92a88","required":true,"noNamespace":"before","type":0,"isExported":false},{"code":" ","dependances":[],"fullName":"!staticClass_3ec6235d-c904-423d-8c26-7f487aa3ed74","required":true,"noNamespace":"before","type":0,"isExported":false},{"code":"class WebComponentTemplateInstance {\n    context;\n    content;\n    actions;\n    component;\n    _components;\n    firstRenderUniqueCb = {};\n    firstRenderCb = [];\n    fctsToRemove = [];\n    loopRegisteries = {};\n    firstChild;\n    lastChild;\n    loops = [];\n    constructor(context, content, actions, component, loops) {\n        this.context = context;\n        this.content = content;\n        this.actions = actions;\n        this.component = component;\n        this.loops = loops;\n        this.firstChild = content.firstChild;\n        this.lastChild = content.lastChild;\n        this.transformActionsListening();\n        this.selectElements();\n        this.bindEvents();\n    }\n    render() {\n        for (let cb of this.firstRenderCb) {\n            cb();\n        }\n        for (let key in this.firstRenderUniqueCb) {\n            this.firstRenderUniqueCb[key]();\n        }\n        this.renderSubTemplate();\n        this.context.isRendered = true;\n    }\n    destructor() {\n        this.firstChild.remove();\n        this.context.destructor();\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__watchActions'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__watchActions'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    selectElements() {\n        this._components = {};\n        let idEls = Array.from(this.content.querySelectorAll('[_id]'));\n        for (let idEl of idEls) {\n            let id = idEl.attributes['_id'].value;\n            if (!this._components[id]) {\n                this._components[id] = [];\n            }\n            this._components[id].push(idEl);\n        }\n        if (this.actions.elements) {\n            for (let element of this.actions.elements) {\n                let components = [];\n                for (let id of element.ids) {\n                    if (this._components[id]) {\n                        components = [...components, ...this._components[id]];\n                    }\n                }\n                if (element.isArray) {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components);\n                }\n                else {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components[0]);\n                }\n            }\n        }\n    }\n    bindEvents() {\n        if (this.actions.events) {\n            for (let event of this.actions.events) {\n                this.bindEvent(event);\n            }\n        }\n        if (this.actions.pressEvents) {\n            for (let event of this.actions.pressEvents) {\n                this.bindPressEvent(event);\n            }\n        }\n    }\n    bindEvent(event) {\n        if (event.isCallback) {\n            for (let el of this._components[event.id]) {\n                let cb = WebComponentTemplate.getValueFromItem(event.eventName, el);\n                cb?.add((...args) => {\n                    event.fct(this.context, args);\n                });\n            }\n        }\n        else {\n            for (let el of this._components[event.id]) {\n                el.addEventListener(event.eventName, (e) => { event.fct(e, this.context); });\n            }\n        }\n    }\n    bindPressEvent(event) {\n        let id = event['id'];\n        if (id) {\n            let clone = {};\n            for (let temp in event) {\n                if (temp != 'id') {\n                    if (event[temp] instanceof Function) {\n                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };\n                    }\n                    else {\n                        clone[temp] = event[temp];\n                    }\n                }\n            }\n            clone.element = this._components[id];\n            new PressManager(clone);\n        }\n    }\n    transformActionsListening() {\n        if (this.actions.content) {\n            for (let name in this.actions.content) {\n                for (let change of this.actions.content[name]) {\n                    this.transformChangeAction(name, change);\n                }\n            }\n        }\n        if (this.actions.injection) {\n            for (let name in this.actions.injection) {\n                for (let injection of this.actions.injection[name]) {\n                    this.transformInjectionAction(name, injection);\n                }\n            }\n        }\n        if (this.actions.bindings) {\n            for (let name in this.actions.bindings) {\n                for (let binding of this.actions.bindings[name]) {\n                    this.transformBindigAction(name, binding);\n                }\n            }\n        }\n    }\n    transformChangeAction(name, change) {\n        let key = change.id + \"_\" + change.attrName;\n        if (change.attrName == \"@HTML\") {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.innerHTML = change.render(this.context.c);\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                };\n            }\n        }\n        else if (change.isBool) {\n            this.context.addChange(name, () => {\n                for (const el of this._components[change.id]) {\n                    if (this.context.c[name]) {\n                        el.setAttribute(change.attrName, \"true\");\n                    }\n                    else {\n                        el.removeAttribute(change.attrName);\n                    }\n                }\n            });\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        if (this.context.c[name]) {\n                            el.setAttribute(change.attrName, \"true\");\n                        }\n                        else {\n                            el.removeAttribute(change.attrName);\n                        }\n                    }\n                };\n            }\n        }\n        else {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.setAttribute(change.attrName, change.render(this.context.c));\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                };\n            }\n        }\n    }\n    transformInjectionAction(name, injection) {\n        if (injection.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, injection.path)) {\n                    for (const el of this._components[injection.id]) {\n                        el[injection.injectionName] = injection.inject(this.context.c);\n                    }\n                }\n            });\n        }\n        else {\n            this.context.addChange(name, (path) => {\n                for (const el of this._components[injection.id]) {\n                    el[injection.injectionName] = injection.inject(this.context.c);\n                }\n            });\n        }\n        this.firstRenderCb.push(() => {\n            for (const el of this._components[injection.id]) {\n                el[injection.injectionName] = injection.inject(this.context.c);\n            }\n        });\n    }\n    transformBindigAction(name, binding) {\n        if (binding.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, binding.path)) {\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    for (const el of this._components[binding.id]) {\n                        WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                    }\n                }\n            });\n        }\n        else {\n            binding.path = name;\n            this.context.addChange(name, (path) => {\n                let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                for (const el of this._components[binding.id]) {\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        if (binding.isCallback) {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        let cb = WebComponentTemplate.getValueFromItem(fct, el);\n                        cb?.add((value) => {\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, value);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        else {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        el.addEventListener(fct, (e) => {\n                            let valueToSet = WebComponentTemplate.getValueFromItem(binding.valueName, e.target);\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, valueToSet);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n    }\n    renderSubTemplate() {\n        for (let loop of this.loops) {\n            let localContext = JSON.parse(JSON.stringify(this.context.schema));\n            localContext.loops.push({\n                data: loop.data,\n                index: loop.index,\n                item: loop.item\n            });\n            this.renderLoop(loop, localContext);\n            this.registerLoopWatchEvent(loop, localContext);\n        }\n    }\n    renderLoop(loop, localContext) {\n        if (this.loopRegisteries[loop.anchorId]) {\n            for (let item of this.loopRegisteries[loop.anchorId]) {\n                item.destructor();\n            }\n        }\n        this.loopRegisteries[loop.anchorId] = [];\n        let result = WebComponentTemplate.getValueFromItem(loop.data, this.context.c);\n        let anchor = this._components[loop.anchorId][0];\n        for (let i = 0; i < result.length; i++) {\n            let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: i }]);\n            let content = loop.template.template.content.cloneNode(true);\n            let actions = loop.template.actions;\n            let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n            instance.render();\n            anchor.parentNode.insertBefore(instance.content, anchor);\n            this.loopRegisteries[loop.anchorId].push(instance);\n        }\n    }\n    registerLoopWatchEvent(loop, localContext) {\n        let fullPath = loop.data;\n        let watchName = fullPath.split(\".\")[0];\n        if (!this.component['__watchActions'][watchName]) {\n            this.component['__watchActions'][watchName] = [];\n        }\n        let regex = new RegExp(fullPath.replace(/\\./g, \"\\\\.\") + \"\\\\[(\\\\d+?)\\\\]$\");\n        this.component['__watchActions'][watchName].push((element, action, path, value) => {\n            if (path == fullPath) {\n                this.renderLoop(loop, localContext);\n                return;\n            }\n            regex.lastIndex = 0;\n            let result = regex.exec(path);\n            if (result) {\n                let registry = this.loopRegisteries[loop.anchorId];\n                let index = Number(result[1]);\n                if (action == WatchAction.CREATED) {\n                    let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: index }]);\n                    let content = loop.template.template.content.cloneNode(true);\n                    let actions = loop.template.actions;\n                    let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n                    instance.render();\n                    let anchor;\n                    if (index < registry.length) {\n                        anchor = registry[index].firstChild;\n                    }\n                    else {\n                        anchor = this._components[loop.anchorId][0];\n                    }\n                    anchor.parentNode.insertBefore(instance.content, anchor);\n                    registry.splice(index, 0, instance);\n                    for (let i = index + 1; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] + 1;\n                    }\n                }\n                else if (action == WatchAction.UPDATED) {\n                    registry[index].render();\n                }\n                else if (action == WatchAction.DELETED) {\n                    registry[index].destructor();\n                    registry.splice(index, 1);\n                    for (let i = index; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] - 1;\n                    }\n                }\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.ActionEvent","isStrong":false},{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.ActionChange","isStrong":false},{"fullName":"Aventus.ActionInjection","isStrong":false},{"fullName":"Aventus.ActionBindings","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateInstance","required":false,"type":1,"isExported":true},{"code":"class WebComponentTemplate {\n    static setValueToItem(path, obj, value) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (!obj[split]) {\n                obj[split] = {};\n            }\n            obj = obj[split];\n        }\n        obj[splitted[splitted.length - 1]] = value;\n    }\n    static getValueFromItem(path, obj) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (typeof obj[split] !== 'object') {\n                return undefined;\n            }\n            obj = obj[split];\n        }\n        return obj[splitted[splitted.length - 1]];\n    }\n    static validatePath(path, pathToCheck) {\n        if (path.startsWith(pathToCheck)) {\n            return true;\n        }\n        return false;\n    }\n    htmlParts = [];\n    setHTML(data) {\n        this.htmlParts.push(data);\n    }\n    generateTemplate() {\n        this.template = document.createElement('template');\n        let currentHTML = \"<slot></slot>\";\n        let previousSlots = {\n            default: '<slot></slot>'\n        };\n        for (let htmlPart of this.htmlParts) {\n            for (let blockName in htmlPart.blocks) {\n                if (!previousSlots.hasOwnProperty(blockName)) {\n                    throw \"can't found slot with name \" + blockName;\n                }\n                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);\n            }\n            for (let slotName in htmlPart.slots) {\n                previousSlots[slotName] = htmlPart.slots[slotName];\n            }\n        }\n        this.template.innerHTML = currentHTML;\n    }\n    setTemplate(template) {\n        this.template = document.createElement('template');\n        this.template.innerHTML = template;\n    }\n    contextSchema = {\n        globals: [],\n        locals: [],\n        loops: []\n    };\n    template;\n    actions = {};\n    loops = [];\n    setActions(actions) {\n        if (!this.actions) {\n            this.actions = actions;\n        }\n        else {\n            if (actions.elements) {\n                if (!this.actions.elements) {\n                    this.actions.elements = [];\n                }\n                this.actions.elements = [...actions.elements, ...this.actions.elements];\n            }\n            if (actions.events) {\n                if (!this.actions.events) {\n                    this.actions.events = [];\n                }\n                this.actions.events = [...actions.events, ...this.actions.events];\n            }\n            if (actions.pressEvents) {\n                if (!this.actions.pressEvents) {\n                    this.actions.pressEvents = [];\n                }\n                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];\n            }\n            if (actions.content) {\n                if (!this.actions.content) {\n                    this.actions.content = actions.content;\n                }\n                else {\n                    for (let contextProp in actions.content) {\n                        if (!this.actions.content[contextProp]) {\n                            this.actions.content[contextProp] = actions.content[contextProp];\n                        }\n                        else {\n                            this.actions.content[contextProp] = { ...actions.content[contextProp], ...this.actions.content[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.injection) {\n                if (!this.actions.injection) {\n                    this.actions.injection = actions.injection;\n                }\n                else {\n                    for (let contextProp in actions.injection) {\n                        if (!this.actions.injection[contextProp]) {\n                            this.actions.injection[contextProp] = actions.injection[contextProp];\n                        }\n                        else {\n                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.bindings) {\n                if (!this.actions.bindings) {\n                    this.actions.bindings = actions.bindings;\n                }\n                else {\n                    for (let contextProp in actions.bindings) {\n                        if (!this.actions.bindings[contextProp]) {\n                            this.actions.bindings[contextProp] = actions.bindings[contextProp];\n                        }\n                        else {\n                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };\n                        }\n                    }\n                }\n            }\n        }\n    }\n    setSchema(contextSchema) {\n        if (contextSchema.globals) {\n            this.contextSchema.globals = [...this.contextSchema.globals, ...contextSchema.globals];\n        }\n        if (contextSchema.locals) {\n            this.contextSchema.locals = [...this.contextSchema.locals, ...contextSchema.locals];\n        }\n        if (contextSchema.loops) {\n            this.contextSchema.loops = [...this.contextSchema.loops, ...contextSchema.loops];\n        }\n    }\n    createInstance(component) {\n        let context = new WebComponentTemplateContext(component, this.contextSchema, []);\n        let content = this.template.content.cloneNode(true);\n        let actions = this.actions;\n        let instance = new WebComponentTemplateInstance(context, content, actions, component, this.loops);\n        return instance;\n    }\n    addLoop(loop) {\n        this.loops.push(loop);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateHTML","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false},{"fullName":"HTMLTemplateElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"WebComponentTemplateInstance","isStrong":false}],"fullName":"Aventus.WebComponentTemplate","required":false,"type":1,"isExported":true},{"code":"class WebComponentTemplateContext {\n    __changes = {};\n    component;\n    fctsToRemove = [];\n    c = {};\n    isRendered = false;\n    schema;\n    constructor(component, schema, locals) {\n        this.component = component;\n        this.schema = { ...schema };\n        this.schema.locals = [...this.schema.locals, ...locals];\n        5;\n        this.buildSchema();\n    }\n    destructor() {\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__onChangeFct'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__onChangeFct'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    buildSchema() {\n        for (let global of this.schema.globals) {\n            this.createGlobal(global);\n        }\n        for (let loop of this.schema.loops) {\n            this.createLoop(loop);\n        }\n        for (let local of this.schema.locals) {\n            this.createLocal(local);\n        }\n    }\n    createGlobal(global) {\n        let comp = this.component;\n        Object.defineProperty(this.c, global, {\n            get() {\n                return WebComponentTemplate.getValueFromItem(global, comp);\n            },\n            set(value) {\n                WebComponentTemplate.setValueToItem(global, comp, value);\n            }\n        });\n        let name = global.split(\".\")[0];\n        this.__changes[name] = [];\n        if (!this.component['__onChangeFct'][name]) {\n            this.component['__onChangeFct'][name] = [];\n        }\n        let fct = (path) => {\n            if (this.isRendered) {\n                for (let change of this.__changes[name]) {\n                    change(path);\n                }\n            }\n        };\n        this.fctsToRemove.push({ name, fct });\n        this.component['__onChangeFct'][name].push(fct);\n    }\n    createLoop(loop) {\n        Object.defineProperty(this.c, loop.item, {\n            get() {\n                let indexValue = this[loop.index];\n                return WebComponentTemplate.getValueFromItem(loop.data, this)[indexValue];\n            }\n        });\n        let name = loop.data.split(\".\")[0];\n        this.__changes[loop.item] = [];\n        this.__changes[name].push((path) => {\n            if (this.isRendered) {\n                let currentPath = `${loop.data}[${this.c[loop.index]}]`;\n                if (path.startsWith(currentPath)) {\n                    let localPath = path.replace(currentPath, loop.item);\n                    for (let change of this.__changes[loop.item]) {\n                        change(localPath);\n                    }\n                }\n            }\n        });\n    }\n    createLocal(local) {\n        let localValue = local.value;\n        let changes = this.__changes;\n        Object.defineProperty(this.c, local.name, {\n            get() {\n                return localValue;\n            },\n            set(value) {\n                localValue = value;\n                if (changes[local.name]) {\n                    for (let change of changes[local.name]) {\n                        change(local.name);\n                    }\n                }\n            }\n        });\n    }\n    addChange(on, fct) {\n        if (!this.__changes[on]) {\n            this.__changes[on] = [];\n        }\n        this.__changes[on].push(fct);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.ContextValues","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateContext","required":false,"type":1,"isExported":true},{"code":"class WebComponent extends HTMLElement {\n    /**\n     * Add attributes informations\n     */\n    static get observedAttributes() {\n        return [];\n    }\n    _first;\n    _isReady;\n    /**\n     * Determine if the component is ready (postCreation done)\n     */\n    get isReady() {\n        return this._isReady;\n    }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the name of the component class\n     */\n    getClassName() {\n        return this.constructor.name;\n    }\n    /**\n    * Get the unique type for the data. Define it as the namespace + class name\n    */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    __onChangeFct = {};\n    __watch;\n    __watchActions = {};\n    __watchActionsCb = {};\n    __pressManagers = [];\n    __isDefaultState = true;\n    __defaultActiveState = new Map();\n    __defaultInactiveState = new Map();\n    __statesList = {};\n    constructor() {\n        super();\n        if (this.constructor == WebComponent) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this._first = true;\n        this._isReady = false;\n        this.__renderTemplate();\n        this.__registerWatchesActions();\n        this.__registerPropertiesActions();\n        this.__createStates();\n        this.__subscribeState();\n    }\n    /**\n     * Remove all listeners\n     * State + press\n     */\n    destructor() {\n        WebComponentInstance.removeInstance(this);\n        this.__unsubscribeState();\n        for (let press of this.__pressManagers) {\n            press.destroy();\n        }\n        // TODO add missing info for destructor();\n    }\n    __addWatchesActions(name, fct) {\n        if (!this.__watchActions[name]) {\n            this.__watchActions[name] = [];\n            this.__watchActionsCb[name] = (action, path, value) => {\n                for (let fct of this.__watchActions[name]) {\n                    fct(this, action, path, value);\n                }\n                if (this.__onChangeFct[name]) {\n                    for (let fct of this.__onChangeFct[name]) {\n                        fct(path);\n                    }\n                }\n            };\n        }\n        if (fct) {\n            this.__watchActions[name].push(fct);\n        }\n    }\n    __registerWatchesActions() {\n        if (Object.keys(this.__watchActions).length > 0) {\n            if (!this.__watch) {\n                this.__watch = Watcher.get({}, (type, path, element) => {\n                    let action = this.__watchActionsCb[path.split(\".\")[0]] || this.__watchActionsCb[path.split(\"[\")[0]];\n                    action(type, path, element);\n                });\n            }\n        }\n    }\n    __addPropertyActions(name, fct) {\n        if (!this.__onChangeFct[name]) {\n            this.__onChangeFct[name] = [];\n        }\n        if (fct) {\n            this.__onChangeFct[name].push(() => {\n                fct(this);\n            });\n        }\n    }\n    __registerPropertiesActions() { }\n    static __style = ``;\n    static __template;\n    __templateInstance;\n    styleBefore() {\n        return [\"@general\"];\n    }\n    styleAfter() {\n        return [];\n    }\n    __getStyle() {\n        return [WebComponent.__style];\n    }\n    __getHtml() { }\n    __getStatic() {\n        return WebComponent;\n    }\n    static __styleSheets = {};\n    __renderStyles() {\n        let sheets = {};\n        let befores = this.styleBefore();\n        for (let before of befores) {\n            let sheet = Style.get(before);\n            if (sheet) {\n                sheets[before] = sheet;\n            }\n        }\n        let localStyle = new CSSStyleSheet();\n        let styleTxt = this.__getStyle().join(\"\\r\\n\");\n        if (styleTxt.length > 0) {\n            localStyle.replace(styleTxt);\n            sheets['@local'] = localStyle;\n        }\n        let afters = this.styleAfter();\n        for (let after of afters) {\n            let sheet = Style.get(after);\n            if (sheet) {\n                sheets[after] = sheet;\n            }\n        }\n        return sheets;\n    }\n    __renderTemplate() {\n        let staticInstance = this.__getStatic();\n        if (!staticInstance.__template) {\n            staticInstance.__template = new WebComponentTemplate();\n            this.__getHtml();\n            this.__registerTemplateAction();\n            staticInstance.__template.generateTemplate();\n            staticInstance.__styleSheets = this.__renderStyles();\n        }\n        this.__templateInstance = staticInstance.__template.createInstance(this);\n        let shadowRoot = this.attachShadow({ mode: 'open' });\n        shadowRoot.adoptedStyleSheets = Object.values(staticInstance.__styleSheets);\n        this.shadowRoot.appendChild(this.__templateInstance.content);\n        customElements.upgrade(this.shadowRoot);\n    }\n    __registerTemplateAction() {\n    }\n    connectedCallback() {\n        if (this._first) {\n            WebComponentInstance.addInstance(this);\n            this._first = false;\n            this.__defaultValues();\n            this.__upgradeAttributes();\n            this.__templateInstance.render();\n            setTimeout(() => {\n                this.postCreation();\n                this._isReady = true;\n                this.dispatchEvent(new CustomEvent('postCreationDone'));\n            });\n        }\n    }\n    __defaultValues() { }\n    __upgradeAttributes() { }\n    __listBoolProps() {\n        return [];\n    }\n    __upgradeProperty(prop) {\n        let boolProps = this.__listBoolProps();\n        if (boolProps.indexOf(prop) != -1) {\n            if (this.hasAttribute(prop) && (this.getAttribute(prop) === \"true\" || this.getAttribute(prop) === \"\")) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n            else {\n                this.removeAttribute(prop);\n                this[prop] = false;\n            }\n        }\n        else {\n            if (this.hasAttribute(prop)) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n        }\n    }\n    __getStateManager(managerClass) {\n        let mClass;\n        if (managerClass instanceof StateManager) {\n            mClass = managerClass;\n        }\n        else {\n            mClass = Instance.get(managerClass);\n        }\n        return mClass;\n    }\n    __addActiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultActiveState.has(mClass)) {\n            this.__defaultActiveState.set(mClass, []);\n        }\n        this.__defaultActiveState.get(mClass).push(cb);\n    }\n    __addInactiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultInactiveState.has(mClass)) {\n            this.__defaultInactiveState.set(mClass, []);\n        }\n        this.__defaultInactiveState.get(mClass).push(cb);\n    }\n    __addActiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).active.push(cb);\n    }\n    __addInactiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).inactive.push(cb);\n    }\n    __addAskChangeState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).askChange.push(cb);\n    }\n    __createStates() { }\n    __createStatesList(statePattern, managerClass) {\n        if (!this.__statesList[statePattern]) {\n            this.__statesList[statePattern] = new Map();\n        }\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__statesList[statePattern].has(mClass)) {\n            this.__statesList[statePattern].set(mClass, {\n                active: [],\n                inactive: [],\n                askChange: []\n            });\n        }\n    }\n    __inactiveDefaultState(managerClass) {\n        if (this.__isDefaultState) {\n            this.__isDefaultState = false;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultInactiveState.has(mClass)) {\n                let fcts = this.__defaultInactiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __activeDefaultState(nextStep, managerClass) {\n        if (!this.__isDefaultState) {\n            for (let pattern in this.__statesList) {\n                if (StateManager.canBeActivate(pattern, nextStep)) {\n                    let mClass = this.__getStateManager(managerClass);\n                    if (this.__statesList[pattern].has(mClass)) {\n                        return;\n                    }\n                }\n            }\n            this.__isDefaultState = true;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultActiveState.has(mClass)) {\n                let fcts = this.__defaultActiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __subscribeState() {\n        if (!this.isReady && this.__stateCleared) {\n            return;\n        }\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.subscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n    }\n    __stateCleared;\n    __unsubscribeState() {\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.unsubscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n        this.__stateCleared = true;\n    }\n    dateToString(d) {\n        if (d instanceof Date) {\n            return new Date(d.getTime() - (d.getTimezoneOffset() * 60000)).toISOString().split(\"T\")[0];\n        }\n        return null;\n    }\n    dateTimeToString(dt) {\n        if (dt instanceof Date) {\n            return new Date(dt.getTime() - (dt.getTimezoneOffset() * 60000)).toISOString().slice(0, -1);\n        }\n        return null;\n    }\n    stringToDate(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    stringToDateTime(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    getBoolean(val) {\n        if (val === true || val === 1 || val === 'true' || val === '') {\n            return true;\n        }\n        else if (val === false || val === 0 || val === 'false' || val === null || val === undefined) {\n            return false;\n        }\n        console.error(\"error parsing boolean value \" + val);\n        return false;\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue !== newValue || !this.isReady) {\n            if (this.__onChangeFct.hasOwnProperty(name)) {\n                for (let fct of this.__onChangeFct[name]) {\n                    fct('');\n                }\n            }\n        }\n    }\n    remove() {\n        super.remove();\n        this.postDestruction();\n    }\n    /**\n     * Function triggered when the component is removed from the DOM\n     */\n    postDestruction() { }\n    /**\n     * Function triggered the first time the component is rendering inside DOM\n     */\n    postCreation() { }\n    /**\n     * Find a parent by tagname if exist\n     */\n    findParentByTag(tagname, untilNode) {\n        return ElementExtension.findParentByTag(this, tagname, untilNode);\n    }\n    /**\n     * Find a parent by class name if exist\n     */\n    findParentByClass(classname, untilNode) {\n        return ElementExtension.findParentByClass(this, classname, untilNode);\n    }\n    /**\n     * Find a parent by type if exist\n     */\n    findParentByType(type, untilNode) {\n        return ElementExtension.findParentByType(this, type, untilNode);\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    findParents(tagname, untilNode) {\n        return ElementExtension.findParents(this, tagname, untilNode);\n    }\n    /**\n     * Check if element contains a child\n     */\n    containsChild(el) {\n        return ElementExtension.containsChild(this, el);\n    }\n    /**\n     * Get element inside slot\n     */\n    getElementsInSlot(slotName = null) {\n        return ElementExtension.getElementsInSlot(this, slotName);\n    }\n}\n","dependances":[{"fullName":"HTMLElement","isStrong":true},{"fullName":"Aventus.DefaultComponent","isStrong":true},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.WebComponentTemplate","isStrong":false},{"fullName":"Aventus.WebComponentTemplateInstance","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false},{"fullName":"Aventus.Style","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"Date","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.ElementExtension","isStrong":false},{"fullName":"Aventus.WebComponentInstance","isStrong":true}],"fullName":"Aventus.WebComponent","required":false,"type":1,"isExported":true},{"code":"class WebComponentInstance {\n    static __allDefinitions = [];\n    static __allInstances = [];\n    /**\n     * Last definition insert datetime\n     */\n    static lastDefinition = 0;\n    static registerDefinition(def) {\n        WebComponentInstance.lastDefinition = Date.now();\n        WebComponentInstance.__allDefinitions.push(def);\n    }\n    /**\n     * Get all sub classes of type\n     */\n    static getAllClassesOf(type) {\n        let result = [];\n        for (let def of WebComponentInstance.__allDefinitions) {\n            if (def.prototype instanceof type) {\n                result.push(def);\n            }\n        }\n        return result;\n    }\n    /**\n     * Get all registered definitions\n     */\n    static getAllDefinitions() {\n        return WebComponentInstance.__allDefinitions;\n    }\n    static addInstance(instance) {\n        this.__allInstances.push(instance);\n    }\n    static removeInstance(instance) {\n        let index = this.__allInstances.indexOf(instance);\n        if (index > -1) {\n            this.__allInstances.splice(index, 1);\n        }\n    }\n    static getAllInstances(type) {\n        let result = [];\n        for (let instance of this.__allInstances) {\n            if (instance instanceof type) {\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"WebComponent","isStrong":false}],"fullName":"Aventus.WebComponentInstance","required":false,"type":1,"isExported":true},{"code":"class Style {\n    static instance;\n    static defaultStyleSheets = {\n        \"@general\": `:host{display:inline-block;box-sizing:border-box}:host *{box-sizing:border-box}`\n    };\n    static store(name, content) {\n        this.getInstance().store(name, content);\n    }\n    static get(name) {\n        return this.getInstance().get(name);\n    }\n    static load(name, url) {\n        return this.getInstance().load(name, url);\n    }\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new Style();\n        }\n        return this.instance;\n    }\n    constructor() {\n        for (let name in Style.defaultStyleSheets) {\n            this.store(name, Style.defaultStyleSheets[name]);\n        }\n    }\n    stylesheets = new Map();\n    async load(name, url) {\n        try {\n            if (!this.stylesheets.has(name) || this.stylesheets.get(name).cssRules.length == 0) {\n                let txt = await (await fetch(url)).text();\n                this.store(name, txt);\n            }\n        }\n        catch (e) {\n        }\n    }\n    store(name, content) {\n        if (!this.stylesheets.has(name)) {\n            const sheet = new CSSStyleSheet();\n            sheet.replaceSync(content);\n            this.stylesheets.set(name, sheet);\n        }\n        else {\n            this.stylesheets.get(name).replaceSync(content);\n        }\n    }\n    get(name) {\n        if (!this.stylesheets.has(name)) {\n            this.store(name, \"\");\n        }\n        return this.stylesheets.get(name);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false}],"fullName":"Aventus.Style","required":false,"type":1,"isExported":true},{"code":"class ElementExtension {\n    /**\n     * Find a parent by tagname if exist Static.findParentByTag(this, \"av-img\")\n     */\n    static findParentByTag(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let checkFunc = (el) => {\n            return tagname.indexOf((el.nodeName || el.tagName).toLowerCase()) != -1;\n        };\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by class name if exist Static.findParentByClass(this, \"my-class-img\") = querySelector('.my-class-img')\n     */\n    static findParentByClass(element, classname, untilNode) {\n        let el = element;\n        if (!Array.isArray(classname)) {\n            classname = [classname];\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            for (let classnameTemp of classname) {\n                if (el['classList'] && el['classList'].contains(classnameTemp)) {\n                    return el;\n                }\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by type if exist Static.findParentyType(this, Aventus.Img)\n     */\n    static findParentByType(element, type, untilNode) {\n        let el = element;\n        let checkFunc = (el) => {\n            return false;\n        };\n        if (typeof type == \"function\" && type['prototype']['constructor']) {\n            checkFunc = (el) => {\n                if (el instanceof type) {\n                    return true;\n                }\n                return false;\n            };\n        }\n        else {\n            console.error(\"you must provide a class inside this function\");\n            return null;\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    static findParents(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let result = [];\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (tagname.indexOf((el.nodeName || el['tagName']).toLowerCase()) != -1) {\n                result.push(el);\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Check if element contains a child\n     */\n    static containsChild(element, child) {\n        var rootScope = element.getRootNode();\n        var elScope = child.getRootNode();\n        while (elScope != rootScope) {\n            if (!elScope['host']) {\n                return false;\n            }\n            child = elScope['host'];\n            elScope = elScope['host'].getRootNode();\n        }\n        return element.contains(child);\n    }\n    /**\n     * Get element inside slot\n     */\n    static getElementsInSlot(element, slotName = null) {\n        if (element.shadowRoot) {\n            let slotEl;\n            if (slotName) {\n                slotEl = element.shadowRoot.querySelector('slot[name=\"' + slotName + '\"]');\n            }\n            else {\n                slotEl = element.shadowRoot.querySelector(\"slot\");\n            }\n            while (true) {\n                if (!slotEl) {\n                    return [];\n                }\n                var listChild = Array.from(slotEl.assignedElements());\n                if (!listChild) {\n                    return [];\n                }\n                let slotFound = false;\n                for (let i = 0; i < listChild.length; i++) {\n                    if (listChild[i].nodeName == \"SLOT\") {\n                        slotEl = listChild[i];\n                        slotFound = true;\n                        break;\n                    }\n                }\n                if (!slotFound) {\n                    return listChild;\n                }\n            }\n        }\n        return [];\n    }\n    /**\n     * Get deeper element inside dom at the position X and Y\n     */\n    static getElementAtPosition(x, y, startFrom = null) {\n        var _realTarget = (el, i = 0) => {\n            if (i == 50) {\n                debugger;\n            }\n            if (el.shadowRoot && x !== undefined && y !== undefined) {\n                var newEl = el.shadowRoot.elementFromPoint(x, y);\n                if (newEl && newEl != el) {\n                    return _realTarget(newEl, i + 1);\n                }\n            }\n            return el;\n        };\n        if (startFrom == null) {\n            startFrom = document.body;\n        }\n        return _realTarget(startFrom);\n    }\n}\n","dependances":[{"fullName":"Element","isStrong":false},{"fullName":"ShadowRoot","isStrong":false},{"fullName":"HTMLSlotElement","isStrong":false},{"fullName":"HTMLElement","isStrong":false}],"fullName":"Aventus.ElementExtension","required":false,"type":1,"isExported":true},{"code":"function uuidv4() {\n    let uid = '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));\n    return uid;\n}\n","dependances":[],"fullName":"Aventus.uuidv4","required":false,"type":4,"isExported":true},{"code":"function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","dependances":[],"fullName":"Aventus.sleep","required":false,"type":4,"isExported":true},{"code":"class Mutex {\n    waitingList = [];\n    isLocked = false;\n    /**\n     * Wait the mutex to be free then get it\n     */\n    waitOne() {\n        return new Promise((resolve) => {\n            if (this.isLocked) {\n                this.waitingList.push(() => {\n                    resolve();\n                });\n            }\n            else {\n                this.isLocked = true;\n                resolve();\n            }\n        });\n    }\n    /**\n     * Release the mutex\n     */\n    release() {\n        let nextFct = this.waitingList.shift();\n        if (nextFct) {\n            nextFct();\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Clear mutex\n     */\n    dispose() {\n        this.waitingList = [];\n        this.isLocked = false;\n    }\n}\n","dependances":[],"fullName":"Aventus.Mutex","required":false,"type":1,"isExported":true},{"code":"function compareObject(obj1, obj2) {\n    if (Array.isArray(obj1)) {\n        if (!obj2) {\n            obj2 = [];\n        }\n        else {\n            obj2 = obj2.slice();\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            let foundElement = false;\n            for (let j = 0; j < obj2.length; j++) {\n                if (compareObject(obj1[i], obj2[j])) {\n                    obj2.splice(j, 1);\n                    foundElement = true;\n                    break;\n                }\n            }\n            if (!foundElement) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (obj1 instanceof Date) {\n        return obj1.toString() === obj2.toString();\n    }\n    else if (typeof obj1 == 'object') {\n        if (!obj2) {\n            obj2 = {};\n        }\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (let key in obj1) {\n            if (!(key in obj2)) {\n                return false;\n            }\n            if (!compareObject(obj1[key], obj2[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return obj1 == obj2;\n    }\n}\n","dependances":[],"fullName":"Aventus.compareObject","required":false,"type":4,"isExported":true},{"code":"class StateManager {\n    subscribers = {};\n    static canBeActivate(statePattern, stateName) {\n        let stateInfo = this.prepareStateString(statePattern);\n        return stateInfo.regex.test(stateName);\n    }\n    activeState;\n    afterStateChanged = new Callback();\n    /**\n     * Subscribe actions for a state or a state list\n     */\n    subscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to subscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (!this.subscribers.hasOwnProperty(statePattern)) {\n                let res = StateManager.prepareStateString(statePattern);\n                let isActive = this.activeState !== undefined && res.regex.test(this.activeState.name);\n                this.subscribers[statePattern] = {\n                    \"regex\": res.regex,\n                    \"params\": res.params,\n                    \"callbacks\": {\n                        \"active\": [],\n                        \"inactive\": [],\n                        \"askChange\": [],\n                    },\n                    \"isActive\": isActive,\n                };\n            }\n            if (callbacks.active) {\n                if (!Array.isArray(callbacks.active)) {\n                    callbacks.active = [callbacks.active];\n                }\n                for (let activeFct of callbacks.active) {\n                    this.subscribers[statePattern].callbacks.active.push(activeFct);\n                    if (this.subscribers[statePattern].isActive) {\n                        let slugs = this.getInternalStateSlugs(this.subscribers[statePattern], this.activeState.name);\n                        activeFct(this.activeState, slugs);\n                    }\n                }\n            }\n            if (callbacks.inactive) {\n                if (!Array.isArray(callbacks.inactive)) {\n                    callbacks.inactive = [callbacks.inactive];\n                }\n                for (let inactiveFct of callbacks.inactive) {\n                    this.subscribers[statePattern].callbacks.inactive.push(inactiveFct);\n                }\n            }\n            if (callbacks.askChange) {\n                if (!Array.isArray(callbacks.askChange)) {\n                    callbacks.askChange = [callbacks.askChange];\n                }\n                for (let askChangeFct of callbacks.askChange) {\n                    this.subscribers[statePattern].callbacks.askChange.push(askChangeFct);\n                }\n            }\n        }\n    }\n    /**\n     * Unsubscribe actions for a state or a state list\n     */\n    unsubscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to unsubscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (this.subscribers[statePattern]) {\n                if (callbacks.active) {\n                    if (!Array.isArray(callbacks.active)) {\n                        callbacks.active = [callbacks.active];\n                    }\n                    for (let activeFct of callbacks.active) {\n                        let index = this.subscribers[statePattern].callbacks.active.indexOf(activeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.active.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.inactive) {\n                    if (!Array.isArray(callbacks.inactive)) {\n                        callbacks.inactive = [callbacks.inactive];\n                    }\n                    for (let inactiveFct of callbacks.inactive) {\n                        let index = this.subscribers[statePattern].callbacks.inactive.indexOf(inactiveFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.inactive.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.askChange) {\n                    if (!Array.isArray(callbacks.askChange)) {\n                        callbacks.askChange = [callbacks.askChange];\n                    }\n                    for (let askChangeFct of callbacks.askChange) {\n                        let index = this.subscribers[statePattern].callbacks.askChange.indexOf(askChangeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.askChange.splice(index, 1);\n                        }\n                    }\n                }\n                if (this.subscribers[statePattern].callbacks.active.length === 0 &&\n                    this.subscribers[statePattern].callbacks.inactive.length === 0 &&\n                    this.subscribers[statePattern].callbacks.askChange.length === 0) {\n                    delete this.subscribers[statePattern];\n                }\n            }\n        }\n    }\n    onAfterStateChanged(cb) {\n        this.afterStateChanged.add(cb);\n    }\n    offAfterStateChanged(cb) {\n        this.afterStateChanged.remove(cb);\n    }\n    static prepareStateString(stateName) {\n        let params = [];\n        let i = 0;\n        let regexState = stateName.replace(/{.*?}/g, (group, position) => {\n            group = group.slice(1, -1);\n            let splitted = group.split(\":\");\n            let name = splitted[0].trim();\n            let type = \"string\";\n            let result = \"([^\\\\/]+)\";\n            i++;\n            if (splitted.length > 1) {\n                if (splitted[1].trim() == \"number\") {\n                    result = \"([0-9]+)\";\n                    type = \"number\";\n                }\n            }\n            params.push({\n                name,\n                type,\n                position: i\n            });\n            return result;\n        });\n        regexState = regexState.replace(/\\*/g, \".*?\");\n        regexState = \"^\" + regexState + '$';\n        return {\n            regex: new RegExp(regexState),\n            params\n        };\n    }\n    /**\n     * Activate a current state\n     */\n    async setState(state) {\n        let stateToUse;\n        if (typeof state == \"string\") {\n            stateToUse = new EmptyState(state);\n        }\n        else {\n            stateToUse = state;\n        }\n        if (!stateToUse) {\n            this._log(\"state is undefined\", \"error\");\n            return false;\n        }\n        let canChange = true;\n        if (this.activeState) {\n            let activeToInactive = [];\n            let inactiveToActive = [];\n            let triggerActive = [];\n            canChange = await this.activeState.askChange(this.activeState, stateToUse);\n            if (canChange) {\n                for (let statePattern in this.subscribers) {\n                    let subscriber = this.subscribers[statePattern];\n                    if (subscriber.isActive) {\n                        let clone = [...subscriber.callbacks.askChange];\n                        let currentSlug = this.getInternalStateSlugs(subscriber, this.activeState.name);\n                        for (let i = 0; i < clone.length; i++) {\n                            let askChange = clone[i];\n                            if (!await askChange(this.activeState, stateToUse, currentSlug)) {\n                                canChange = false;\n                                break;\n                            }\n                        }\n                        let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                        if (slugs === null) {\n                            activeToInactive.push(subscriber);\n                        }\n                        else {\n                            triggerActive.push({\n                                subscriber: subscriber,\n                                params: slugs\n                            });\n                        }\n                    }\n                    else {\n                        let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                        if (slugs) {\n                            inactiveToActive.push({\n                                subscriber,\n                                params: slugs\n                            });\n                        }\n                    }\n                    if (!canChange) {\n                        break;\n                    }\n                }\n            }\n            if (canChange) {\n                const oldState = this.activeState;\n                this.activeState = stateToUse;\n                oldState.onInactivate(stateToUse);\n                for (let subscriber of activeToInactive) {\n                    subscriber.isActive = false;\n                    let oldSlug = this.getInternalStateSlugs(subscriber, oldState.name);\n                    [...subscriber.callbacks.inactive].forEach(callback => {\n                        callback(oldState, stateToUse, oldSlug);\n                    });\n                }\n                for (let trigger of triggerActive) {\n                    [...trigger.subscriber.callbacks.active].forEach(callback => {\n                        callback(stateToUse, trigger.params);\n                    });\n                }\n                for (let trigger of inactiveToActive) {\n                    trigger.subscriber.isActive = true;\n                    [...trigger.subscriber.callbacks.active].forEach(callback => {\n                        callback(stateToUse, trigger.params);\n                    });\n                }\n                stateToUse.onActivate();\n            }\n        }\n        else {\n            this.activeState = stateToUse;\n            for (let key in this.subscribers) {\n                let slugs = this.getInternalStateSlugs(this.subscribers[key], stateToUse.name);\n                if (slugs) {\n                    this.subscribers[key].isActive = true;\n                    [...this.subscribers[key].callbacks.active].forEach(callback => {\n                        callback(stateToUse, slugs);\n                    });\n                }\n            }\n            stateToUse.onActivate();\n        }\n        this.afterStateChanged.trigger([]);\n        return true;\n    }\n    getState() {\n        return this.activeState;\n    }\n    getInternalStateSlugs(subscriber, stateName) {\n        let matches = subscriber.regex.exec(stateName);\n        if (matches) {\n            let slugs = {};\n            for (let param of subscriber.params) {\n                if (param.type == \"number\") {\n                    slugs[param.name] = Number(matches[param.position]);\n                }\n                else {\n                    slugs[param.name] = matches[param.position];\n                }\n            }\n            return slugs;\n        }\n        return null;\n    }\n    /**\n     * Check if a state is in the subscribers and active, return true if it is, false otherwise\n     */\n    isStateActive(statePattern) {\n        return StateManager.prepareStateString(statePattern).regex.test(this.activeState.name);\n    }\n    /**\n     * Get slugs information for the current state, return null if state isn't active\n     */\n    getStateSlugs(statePattern) {\n        let prepared = StateManager.prepareStateString(statePattern);\n        return this.getInternalStateSlugs({\n            regex: prepared.regex,\n            params: prepared.params,\n            isActive: false,\n            callbacks: {\n                active: [],\n                inactive: [],\n                askChange: [],\n            }\n        }, this.activeState.name);\n    }\n    // 0 = error only / 1 = errors and warning / 2 = error, warning and logs (not implemented)\n    logLevel() {\n        return 0;\n    }\n    _log(msg, type) {\n        if (type === \"error\") {\n            console.error(msg);\n        }\n        else if (type === \"warning\" && this.logLevel() > 0) {\n            console.warn(msg);\n        }\n        else if (type === \"info\" && this.logLevel() > 1) {\n            console.log(msg);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.Subscriber","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Aventus.StateAction","isStrong":false},{"fullName":"Aventus.EmptyState","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false}],"fullName":"Aventus.StateManager","required":false,"type":1,"isExported":true},{"code":"class State {\n    /**\n     * Activate a custom state inside a specific manager\n     * It ll be a generic state with no information inside exept name\n     */\n    static async activate(stateName, manager) {\n        return await new EmptyState(stateName).activate(manager);\n    }\n    /**\n     * Activate this state inside a specific manager\n     */\n    async activate(manager) {\n        return await manager.setState(this);\n    }\n    onActivate() {\n    }\n    onInactivate(nextState) {\n    }\n    async askChange(state, nextState) {\n        return true;\n    }\n}\n","dependances":[{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"EmptyState","isStrong":false}],"fullName":"Aventus.State","required":false,"type":1,"isExported":true},{"code":"class EmptyState extends State {\n    localName;\n    constructor(stateName) {\n        super();\n        this.localName = stateName;\n    }\n    /**\n     * @inheritdoc\n     */\n    get name() {\n        return this.localName;\n    }\n}\n","dependances":[{"fullName":"Aventus.State","isStrong":true}],"fullName":"Aventus.EmptyState","required":false,"type":1,"isExported":true},{"code":"class GenericRam {\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    subscribers = {\n        created: [],\n        updated: [],\n        deleted: [],\n    };\n    recordsSubscribers = new Map();\n    /**\n     * List of stored item by index key\n     */\n    records = new Map();\n    constructor() {\n        if (this.constructor == GenericRam) {\n            throw \"can't instanciate an abstract class\";\n        }\n    }\n    /**\n     * Get item id\n     */\n    getIdWithError(item) {\n        let action = new ResultRamWithError();\n        let idTemp = item[this.defineIndexKey()];\n        if (idTemp !== undefined) {\n            action.result = idTemp;\n        }\n        else {\n            action.errors.push(new RamError(RamErrorCode.noId, \"no key found for item\"));\n        }\n        return action;\n    }\n    /**\n     * Get item id\n     */\n    getId(item) {\n        let result = this.getIdWithError(item);\n        if (result.success) {\n            return result.result;\n        }\n        return null;\n    }\n    /**\n     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete\n     */\n    addRamAction(Base) {\n        let that = this;\n        return class ActionClass extends Base {\n            async update(newData = {}) {\n                let id = that.getId(this);\n                let oldData = that.records.get(id);\n                if (oldData) {\n                    that.mergeObject(oldData, newData);\n                    let result = await that.update(oldData);\n                    return result;\n                }\n                return undefined;\n            }\n            onUpdate(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).updated.includes(callback)) {\n                    that.recordsSubscribers.get(id).updated.push(callback);\n                }\n            }\n            offUpdate(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).updated.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).updated.splice(index, 1);\n                    }\n                }\n            }\n            async delete() {\n                let id = that.getId(this);\n                await that.deleteById(id);\n            }\n            onDelete(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).deleted.includes(callback)) {\n                    that.recordsSubscribers.get(id).deleted.push(callback);\n                }\n            }\n            offDelete(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).deleted.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).deleted.splice(index, 1);\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Transform the object into the object stored inside Ram\n     */\n    getObjectForRam(objJson) {\n        let T = this.addRamAction(this.getTypeForData(objJson));\n        let item = new T();\n        this.mergeObject(item, objJson);\n        return item;\n    }\n    /**\n     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced\n     */\n    addOrUpdateData(item, result) {\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    this.mergeObject(this.records.get(id), item);\n                }\n                else {\n                    let realObject = this.getObjectForRam(item);\n                    this.records.set(id, realObject);\n                }\n                result.result = this.records.get(id);\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n            }\n        }\n        catch (e) {\n            result.errors.push(new RamError(RamErrorCode.unknow, e));\n        }\n    }\n    /**\n     * Merge object and create real instance of class\n     */\n    mergeObject(item, objJson) {\n        let realObject = DataManager.createObject(objJson);\n        let props = Object.getOwnPropertyNames(item);\n        for (let prop of props) {\n            if (realObject[prop] !== undefined) {\n                let propInfo = Object.getOwnPropertyDescriptor(item, prop);\n                if (propInfo.writable) {\n                    item[prop] = realObject[prop];\n                }\n            }\n        }\n    }\n    publish(type, data) {\n        [...this.subscribers[type]].forEach(callback => callback(data));\n        if (this.recordsSubscribers.has(this.getId(data))) {\n            [...this.recordsSubscribers.get(this.getId(data))[type]].forEach(callback => callback(data));\n        }\n    }\n    subscribe(type, cb) {\n        if (!this.subscribers[type].includes(cb)) {\n            this.subscribers[type].push(cb);\n        }\n    }\n    unsubscribe(type, cb) {\n        let index = this.subscribers[type].indexOf(cb);\n        if (index != -1) {\n            this.subscribers[type].splice(index, 1);\n        }\n    }\n    /**\n    * Add a callback that ll be triggered when a new item is stored\n    */\n    onCreated(cb) {\n        this.subscribe('created', cb);\n    }\n    /**\n     * Remove a created callback\n     */\n    offCreated(cb) {\n        this.unsubscribe('created', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is updated\n     */\n    onUpdated(cb) {\n        this.subscribe('updated', cb);\n    }\n    /**\n     * Remove an updated callback\n     */\n    offUpdated(cb) {\n        this.unsubscribe('updated', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is deleted\n     */\n    onDeleted(cb) {\n        this.subscribe('deleted', cb);\n    }\n    /**\n     * Remove an deleted callback\n     */\n    offDeleted(cb) {\n        this.unsubscribe('deleted', cb);\n    }\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async get(id) {\n        return await this.getById(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async getWithError(id) {\n        return await this.getByIdWithError(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist\n     */\n    async getById(id) {\n        let action = await this.getByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Get an item by id if exist\n     */\n    async getByIdWithError(id) {\n        let action = new ResultRamWithError();\n        await this.beforeGetById(id, action);\n        if (action.success) {\n            if (this.records.has(id)) {\n                action.result = this.records.get(id);\n                await this.afterGetById(action);\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before getting an item by id\n     */\n    async beforeGetById(id, result) { }\n    ;\n    /**\n     * Trigger after getting an item by id\n     */\n    async afterGetById(result) { }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIds(ids) {\n        let result = await this.getByIdsWithError(ids);\n        if (result.success) {\n            return result.result;\n        }\n        return [];\n    }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIdsWithError(ids) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeGetByIds(ids, action);\n        if (action.success) {\n            for (let id of ids) {\n                if (this.records.has(id)) {\n                    action.result.push(this.records.get(id));\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                }\n            }\n            if (action.success) {\n                await this.afterGetByIds(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting a list of items by id\n     */\n    async beforeGetByIds(ids, result) { }\n    ;\n    /**\n     * Trigger after getting a list of items by id\n     */\n    async afterGetByIds(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAll() {\n        let result = await this.getAllWithError();\n        if (result.success) {\n            return result.result;\n        }\n        return new Map();\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAllWithError() {\n        let action = new ResultRamWithError();\n        action.result = new Map();\n        await this.beforeGetAll(action);\n        if (action.success) {\n            action.result = this.records;\n            await this.afterGetAll(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting all items inside Ram\n     */\n    async beforeGetAll(result) { }\n    ;\n    /**\n     * Trigger after getting all items inside Ram\n     */\n    async afterGetAll(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getList() {\n        let data = await this.getAll();\n        return Array.from(data.values());\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getListWithError() {\n        let action = new ResultRamWithError();\n        action.result = [];\n        let result = await this.getAllWithError();\n        if (result.success) {\n            action.result = Object.values(result.result);\n        }\n        else {\n            action.errors = result.errors;\n        }\n        return action;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createList(list) {\n        let result = await this.createListWithError(list);\n        return result.result;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeCreateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._create(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterCreateList(action);\n            }\n        }\n        return action;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async create(item, ...args) {\n        let action = await this.createWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async createWithError(item, ...args) {\n        return await this._create(item, false);\n    }\n    async _create(item, fromList) {\n        let action = new ResultRamWithError();\n        await this.beforeCreateItem(item, fromList, action);\n        if (action.success) {\n            if (action.result) {\n                item = action.result;\n            }\n            let resultTemp = this.getIdWithError(item);\n            if (resultTemp.success) {\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterCreateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('created', action.result);\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before creating a list of items\n     */\n    async beforeCreateList(list, result) {\n    }\n    ;\n    /**\n     * Trigger before creating an item\n     */\n    async beforeCreateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after creating an item\n     */\n    async afterCreateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after creating a list of items\n     */\n    async afterCreateList(result) {\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateList(list) {\n        let result = await this.updateListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeUpdateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._update(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterUpdateList(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Update an item inside ram\n     */\n    async update(item, ...args) {\n        let action = await this.updateWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Update an item inside ram\n     */\n    async updateWithError(item, ...args) {\n        return await this._update(item, false);\n    }\n    async _update(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                await this.beforeUpdateItem(item, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                if (action.result) {\n                    item = action.result;\n                }\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterUpdateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('updated', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before updating a list of items\n     */\n    async beforeUpdateList(list, result) {\n    }\n    ;\n    /**\n    * Trigger before updating an item\n    */\n    async beforeUpdateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after updating an item\n     */\n    async afterUpdateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after updating a list of items\n     */\n    async afterUpdateList(result) {\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteList(list) {\n        let result = await this.deleteListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeDeleteList(list, action);\n        for (let item of list) {\n            let resultItem = await this._delete(item, true);\n            if (resultItem.success) {\n                action.result.push(resultItem.result);\n            }\n            else {\n                action.errors = [...action.errors, ...resultItem.errors];\n            }\n        }\n        if (action.success) {\n            await this.afterDeleteList(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Delete an item inside ram\n     */\n    async delete(item, ...args) {\n        let action = await this.deleteWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    ;\n    /**\n    * Delete an item inside ram\n    */\n    async deleteWithError(item, ...args) {\n        return await this._delete(item, false);\n    }\n    ;\n    /**\n     * Delete an item by id inside ram\n     */\n    async deleteById(id) {\n        let action = await this.deleteByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n    * Delete an item by id inside ram\n    */\n    async deleteByIdWithError(id) {\n        if (this.records.has(id)) {\n            let item = this.records.get(id);\n            return await this._delete(item, false);\n        }\n        let result = new ResultRamWithError();\n        result.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + id + \" because it wasn't found inside ram\"));\n        return result;\n    }\n    async _delete(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                let oldItem = this.records.get(key);\n                await this.beforeDeleteItem(oldItem, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                this.records.delete(key);\n                action.result = oldItem;\n                await this.afterDeleteItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('deleted', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    /**\n     * Trigger before deleting a list of items\n     */\n    async beforeDeleteList(list, result) { }\n    ;\n    /**\n     * Trigger before deleting an item\n     */\n    async beforeDeleteItem(item, fromList, result) { }\n    ;\n    /**\n     * Trigger after deleting an item\n     */\n    async afterDeleteItem(result, fromList) { }\n    ;\n    /**\n     * Trigger after deleting a list of items\n     */\n    async afterDeleteList(result) { }\n}\n","dependances":[{"fullName":"Aventus.IRam","isStrong":true},{"fullName":"Aventus.RamSubscribers","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Base","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.DataManager","isStrong":false}],"fullName":"Aventus.GenericRam","required":false,"type":1,"isExported":true},{"code":"class Ram extends GenericRam {\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true}],"fullName":"Aventus.Ram","required":false,"type":1,"isExported":true},{"code":"class GenericRamWs extends GenericRam {\n    wsRoutes;\n    ws;\n    getAllDone = false;\n    constructor() {\n        super();\n        if (this.constructor == GenericRamWs) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.init();\n    }\n    init() {\n        this.ws = this.getWebSocket();\n        this.createRoutes();\n        this.addSocketCallback();\n    }\n    createRoutes() {\n        const socketActions = {\n            get: \"get\",\n            getAll: \"get/all\",\n            create: \"create\",\n            created: \"created\",\n            update: \"update\",\n            updated: \"updated\",\n            delete: \"delete\",\n            deleted: \"deleted\"\n        };\n        let temp = {};\n        let wsRouteBase = this.getWebSocketRoute();\n        if (wsRouteBase.endsWith(\"/\")) {\n            wsRouteBase = wsRouteBase.slice(0, -1);\n        }\n        for (const [key, name] of Object.entries(socketActions)) {\n            temp[key] = {\n                request: `${wsRouteBase}/${name}`,\n                multiple: `${wsRouteBase}/${name}/multiple`,\n                success: `${wsRouteBase}/${name}/success`,\n                error: `${wsRouteBase}/${name}/error`,\n            };\n        }\n        this.wsRoutes = temp;\n    }\n    addSocketCallback() {\n        let createdRoute = {\n            channel: this.wsRoutes.created.request,\n            callback: response => {\n                if (response.data) {\n                    for (let obj of response.data) {\n                        let id = this.getId(obj);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            this.addOrUpdateData(obj, result);\n                            if (result.success) {\n                                this.publish('created', this.records.get(id));\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(createdRoute);\n        let updatedRoute = {\n            channel: this.wsRoutes.updated.request,\n            callback: response => {\n                if (response.data) {\n                    for (let newData of response.data) {\n                        let id = this.getId(newData);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            if (this.records.has(id)) {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('updated', this.records.get(id));\n                                }\n                            }\n                            else {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('created', this.records.get(id));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(updatedRoute);\n        let deletedRoute = {\n            channel: this.wsRoutes.deleted.request,\n            callback: response => {\n                if (response.data) {\n                    for (let data of response.data) {\n                        let id = this.getId(data);\n                        if (this.records.has(id)) {\n                            let oldData = this.records.get(id);\n                            this.records.delete(id);\n                            this.publish('deleted', oldData);\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(deletedRoute);\n    }\n    /**\n     * Send a msg through the websocket\n     */\n    sendMsg(route, params, callbacks) {\n        this.ws.sendMessageAndWait(route, params, callbacks);\n    }\n    uniqueMsgWaiting = {};\n    /**\n     * Send a unique msg through the websocket and wait answer\n     */\n    sendUniqueMsg(route, params, callbacks) {\n        let uniqueKey = route + JSON.stringify(params);\n        if (this.uniqueMsgWaiting[uniqueKey]) {\n            for (let name in callbacks) {\n                if (this.uniqueMsgWaiting[uniqueKey][name]) {\n                    this.uniqueMsgWaiting[uniqueKey][name].push(callbacks[name]);\n                }\n                else {\n                    this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n                }\n            }\n        }\n        else {\n            let callbacksToAdd = {};\n            const createCallback = (name) => {\n                callbacksToAdd[name] = (data) => {\n                    for (let fct of this.uniqueMsgWaiting[uniqueKey][name]) {\n                        fct(data);\n                    }\n                    delete this.uniqueMsgWaiting[uniqueKey];\n                };\n            };\n            this.uniqueMsgWaiting[uniqueKey] = {};\n            for (let name in callbacks) {\n                createCallback(name);\n                this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n            }\n            this.ws.sendMessageAndWait(route, params, callbacksToAdd);\n        }\n    }\n    addRoute(newRoute) {\n        this.ws.addRoute(newRoute);\n    }\n    beforeGetById(id, result) {\n        return new Promise((resolve, reject) => {\n            if (this.records.has(id)) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.get.request, {\n                    [this.defineIndexKey()]: id\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            let resultTemp = new ResultRamWithError();\n                            this.addOrUpdateData(response.data, resultTemp);\n                            if (!resultTemp.success) {\n                                result.errors = [...result.errors, ...resultTemp.errors];\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeGetByIds(ids, result) {\n        return new Promise((resolve, reject) => {\n            let missingIds = [];\n            for (let id of ids) {\n                if (!this.records.has(id)) {\n                    missingIds.push(id);\n                }\n            }\n            if (missingIds.length > 0) {\n                this.sendUniqueMsg(this.wsRoutes.get.multiple, {\n                    [this.defineIndexKey()]: ids\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeGetAll(result) {\n        return new Promise((resolve, reject) => {\n            if (this.getAllDone) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.getAll.request, {}, {\n                    [this.wsRoutes.getAll.success]: (response) => {\n                        if (response.data) {\n                            this.getAllDone = true;\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.getAll.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeCreateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.create.request, item, {\n                    [this.wsRoutes.create.success]: (response) => {\n                        let element = response.created[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.create.error]: (response) => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeCreateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.create.multiple, list, {\n                [this.wsRoutes.create.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.created) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.create.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeUpdateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.update.request, item, {\n                    [this.wsRoutes.update.success]: (response) => {\n                        let element = response.updated[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.update.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeUpdateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.update.multiple, list, {\n                [this.wsRoutes.update.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.updated) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.update.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeDeleteItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.delete.request, item, {\n                    [this.wsRoutes.delete.success]: (response) => {\n                        resolve();\n                    },\n                    [this.wsRoutes.delete.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeDeleteList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.delete.multiple, list, {\n                [this.wsRoutes.delete.success]: (response) => {\n                    resolve();\n                },\n                [this.wsRoutes.delete.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true},{"fullName":"Aventus.RamWsRoutes","isStrong":false},{"fullName":"Aventus.Socket","isStrong":false},{"fullName":"Aventus.RamWsCallback","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Map","isStrong":false}],"fullName":"Aventus.GenericRamWs","required":false,"type":1,"isExported":true},{"code":"class RamWs extends GenericRamWs {\n}\n","dependances":[{"fullName":"Aventus.GenericRamWs","isStrong":true}],"fullName":"Aventus.RamWs","required":false,"type":1,"isExported":true},{"code":"class ResultWithError {\n    /**\n     * Determine if the action is a success\n     */\n    get success() {\n        return this.errors.length == 0;\n    }\n    /**\n     * Result\n     */\n    result;\n    /**\n     * List of errors\n     */\n    errors = [];\n}\n","dependances":[],"fullName":"Aventus.ResultWithError","required":false,"type":1,"isExported":true},{"code":"var RamErrorCode;\n(function (RamErrorCode) {\n    RamErrorCode[RamErrorCode[\"unknow\"] = 0] = \"unknow\";\n    RamErrorCode[RamErrorCode[\"noId\"] = 1] = \"noId\";\n    RamErrorCode[RamErrorCode[\"noItemInsideRam\"] = 2] = \"noItemInsideRam\";\n})(RamErrorCode || (RamErrorCode = {}));\n","dependances":[],"fullName":"Aventus.RamErrorCode","required":false,"type":6,"isExported":true},{"code":"class GenericError {\n    /**\n     * Code for the error\n     */\n    code;\n    /**\n     * Description of the error\n     */\n    message;\n    constructor(code, message) {\n        this.code = code;\n        this.message = message;\n    }\n}\n","dependances":[],"fullName":"Aventus.GenericError","required":false,"type":1,"isExported":true},{"code":"class Watcher {\n    static __maxProxyData = 0;\n    /**\n     * Transform object into a watcher\n     */\n    static get(obj, onDataChanged) {\n        if (obj == undefined) {\n            console.error(\"You must define an objet / array for your proxy\");\n            return;\n        }\n        if (obj.__isProxy) {\n            obj.__subscribe(onDataChanged);\n            return obj;\n        }\n        Watcher.__maxProxyData++;\n        let setProxyPath = (newProxy, newPath) => {\n            if (newProxy instanceof Object && newProxy.__isProxy) {\n                newProxy.__path = newPath;\n                if (!newProxy.__proxyData) {\n                    newProxy.__proxyData = {};\n                }\n                if (!newProxy.__proxyData[newPath]) {\n                    newProxy.__proxyData[newPath] = [];\n                }\n                if (newProxy.__proxyData[newPath].indexOf(proxyData) == -1) {\n                    newProxy.__proxyData[newPath].push(proxyData);\n                }\n            }\n        };\n        let removeProxyPath = (oldValue, pathToDelete, recursive = true) => {\n            if (oldValue instanceof Object && oldValue.__isProxy) {\n                let allProxies = oldValue.__proxyData;\n                for (let triggerPath in allProxies) {\n                    if (triggerPath == pathToDelete) {\n                        for (let i = 0; i < allProxies[triggerPath].length; i++) {\n                            if (allProxies[triggerPath][i] == proxyData) {\n                                allProxies[triggerPath].splice(i, 1);\n                                i--;\n                            }\n                        }\n                        if (allProxies[triggerPath].length == 0) {\n                            delete allProxies[triggerPath];\n                            if (Object.keys(allProxies).length == 0) {\n                                delete oldValue.__proxyData;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        let jsonReplacer = (key, value) => {\n            if (key == \"__path\")\n                return undefined;\n            else if (key == \"__proxyData\")\n                return undefined;\n            else\n                return value;\n        };\n        let currentTrace = new Error().stack.split(\"\\n\");\n        currentTrace.shift();\n        currentTrace.shift();\n        let onlyDuringInit = true;\n        let proxyData = {\n            baseData: {},\n            id: Watcher.__maxProxyData,\n            callbacks: [onDataChanged],\n            avoidUpdate: [],\n            pathToRemove: [],\n            history: [{\n                    object: JSON.parse(JSON.stringify(obj, jsonReplacer)),\n                    trace: currentTrace,\n                    action: 'init',\n                    path: ''\n                }],\n            useHistory: false,\n            getProxyObject(target, element, prop) {\n                let newProxy;\n                if (element instanceof Object && element.__isProxy) {\n                    newProxy = element;\n                }\n                else {\n                    try {\n                        if (element instanceof Object) {\n                            newProxy = new Proxy(element, this);\n                        }\n                        else {\n                            return element;\n                        }\n                    }\n                    catch {\n                        return element;\n                    }\n                }\n                let newPath = '';\n                if (Array.isArray(target)) {\n                    if (prop != \"length\") {\n                        if (target.__path) {\n                            newPath = target.__path;\n                        }\n                        newPath += \"[\" + prop + \"]\";\n                        setProxyPath(newProxy, newPath);\n                    }\n                }\n                else if (element instanceof Date) {\n                    return element;\n                }\n                else {\n                    if (target.__path) {\n                        newPath = target.__path + '.';\n                    }\n                    newPath += prop;\n                    setProxyPath(newProxy, newPath);\n                }\n                return newProxy;\n            },\n            tryCustomFunction(target, prop, receiver) {\n                if (prop == \"__isProxy\") {\n                    return true;\n                }\n                else if (prop == \"__subscribe\") {\n                    return (cb) => {\n                        this.callbacks.push(cb);\n                    };\n                }\n                else if (prop == \"__unsubscribe\") {\n                    return (cb) => {\n                        let index = this.callbacks.indexOf(cb);\n                        if (index > -1) {\n                            this.callbacks.splice(index, 1);\n                        }\n                    };\n                }\n                else if (prop == \"__proxyId\") {\n                    return this.id;\n                }\n                else if (prop == \"getHistory\") {\n                    return () => {\n                        return this.history;\n                    };\n                }\n                else if (prop == \"clearHistory\") {\n                    this.history = [];\n                }\n                else if (prop == \"enableHistory\") {\n                    return () => {\n                        this.useHistory = true;\n                    };\n                }\n                else if (prop == \"disableHistory\") {\n                    return () => {\n                        this.useHistory = false;\n                    };\n                }\n                else if (prop == \"__getTarget\" && onlyDuringInit) {\n                    return () => {\n                        return target;\n                    };\n                }\n                return undefined;\n            },\n            get(target, prop, receiver) {\n                if (prop == \"__proxyData\") {\n                    return target[prop];\n                }\n                let customResult = this.tryCustomFunction(target, prop, receiver);\n                if (customResult !== undefined) {\n                    return customResult;\n                }\n                let element = target[prop];\n                if (typeof (element) == 'object') {\n                    return this.getProxyObject(target, element, prop);\n                }\n                else if (typeof (element) == 'function') {\n                    if (Array.isArray(target)) {\n                        let result;\n                        if (prop == 'push') {\n                            if (target.__isProxy) {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    return index;\n                                };\n                            }\n                            else {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    let proxyEl = this.getProxyObject(target, el, (index - 1));\n                                    target.splice(target.length - 1, 1, proxyEl);\n                                    trigger('CREATED', target, receiver, proxyEl, \"[\" + (index - 1) + \"]\");\n                                    return index;\n                                };\n                            }\n                        }\n                        else if (prop == 'splice') {\n                            if (target.__isProxy) {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    let path = target.__path ? target.__path : '';\n                                    for (let i = 0; i < res.length; i++) {\n                                        trigger('DELETED', target, receiver, res[i], \"[\" + index + \"]\");\n                                        removeProxyPath(res[i], path + \"[\" + (index + i) + \"]\");\n                                    }\n                                    for (let i = 0; i < insert.length; i++) {\n                                        let proxyEl = this.getProxyObject(target, insert[i], (index + i));\n                                        target.splice((index + i), 1, proxyEl);\n                                        trigger('CREATED', target, receiver, proxyEl, \"[\" + (index + i) + \"]\");\n                                    }\n                                    let fromIndex = index + insert.length;\n                                    let baseDiff = index - insert.length + res.length + 1;\n                                    for (let i = fromIndex, j = 0; i < target.length; i++, j++) {\n                                        let oldPath = path + \"[\" + (j + baseDiff) + \"]\";\n                                        removeProxyPath(target[i], oldPath, false);\n                                        let proxyEl = this.getProxyObject(target, target[i], i);\n                                        let recuUpdate = (childEl) => {\n                                            if (Array.isArray(childEl)) {\n                                                for (let i = 0; i < childEl.length; i++) {\n                                                    if (childEl[i] instanceof Object && childEl[i].__path) {\n                                                        let oldPathRecu = proxyEl[i].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[i], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[i], i);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                            else if (childEl instanceof Object && !(childEl instanceof Date)) {\n                                                for (let key in childEl) {\n                                                    if (childEl[key] instanceof Object && childEl[key].__path) {\n                                                        let oldPathRecu = proxyEl[key].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[key], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[key], key);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                        };\n                                        recuUpdate(proxyEl);\n                                    }\n                                    return res;\n                                };\n                            }\n                        }\n                        else if (prop == 'pop') {\n                            if (target.__isProxy) {\n                                result = () => {\n                                    let res = target.pop();\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = () => {\n                                    let index = target.length - 1;\n                                    let res = target.pop();\n                                    let path = target.__path ? target.__path : '';\n                                    trigger('DELETED', target, receiver, res, \"[\" + index + \"]\");\n                                    removeProxyPath(res, path + \"[\" + index + \"]\");\n                                    return res;\n                                };\n                            }\n                        }\n                        else {\n                            result = element.bind(target);\n                        }\n                        return result;\n                    }\n                    return element.bind(target);\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n                let triggerChange = false;\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        let oldValue = Reflect.get(target, prop, receiver);\n                        if (oldValue !== value) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.set(target, prop, value, receiver);\n                if (triggerChange) {\n                    let index = this.avoidUpdate.indexOf(prop);\n                    if (index == -1) {\n                        trigger('UPDATED', target, receiver, value, prop);\n                    }\n                    else {\n                        this.avoidUpdate.splice(index, 1);\n                    }\n                }\n                return result;\n            },\n            deleteProperty(target, prop) {\n                let triggerChange = false;\n                let pathToDelete = '';\n                if (prop != \"__path\") {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                pathToDelete = target.__path;\n                            }\n                            pathToDelete += \"[\" + prop + \"]\";\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            pathToDelete = target.__path + '.';\n                        }\n                        pathToDelete += prop;\n                        triggerChange = true;\n                    }\n                }\n                if (target.hasOwnProperty(prop)) {\n                    let oldValue = target[prop];\n                    delete target[prop];\n                    if (triggerChange) {\n                        trigger('DELETED', target, null, oldValue, prop);\n                        removeProxyPath(oldValue, pathToDelete);\n                    }\n                    return true;\n                }\n                return false;\n            },\n            defineProperty(target, prop, descriptor) {\n                let triggerChange = false;\n                let newPath = '';\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                newPath = target.__path;\n                            }\n                            newPath += \"[\" + prop + \"]\";\n                            if (!target.hasOwnProperty(prop)) {\n                                triggerChange = true;\n                            }\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            newPath = target.__path + '.';\n                        }\n                        newPath += prop;\n                        if (!target.hasOwnProperty(prop)) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.defineProperty(target, prop, descriptor);\n                if (triggerChange) {\n                    this.avoidUpdate.push(prop);\n                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);\n                    target[prop] = proxyEl;\n                    trigger('CREATED', target, null, proxyEl, prop);\n                }\n                return result;\n            }\n        };\n        const trigger = (type, target, receiver, value, prop) => {\n            if (target.__isProxy) {\n                return;\n            }\n            let allProxies = target.__proxyData;\n            let receiverId = 0;\n            if (receiver == null) {\n                receiverId = proxyData.id;\n            }\n            else {\n                receiverId = receiver.__proxyId;\n            }\n            if (proxyData.id == receiverId) {\n                let stacks = [];\n                let allStacks = new Error().stack.split(\"\\n\");\n                for (let i = allStacks.length - 1; i >= 0; i--) {\n                    let current = allStacks[i].trim().replace(\"at \", \"\");\n                    if (current.startsWith(\"Object.set\") || current.startsWith(\"Proxy.result\")) {\n                        break;\n                    }\n                    stacks.push(current);\n                }\n                for (let triggerPath in allProxies) {\n                    for (let currentProxyData of allProxies[triggerPath]) {\n                        let pathToSend = triggerPath;\n                        if (pathToSend != \"\") {\n                            if (Array.isArray(target)) {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \"[\" + prop + \"]\";\n                                }\n                                else {\n                                    pathToSend += prop;\n                                }\n                            }\n                            else {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \".\";\n                                }\n                                pathToSend += prop;\n                            }\n                        }\n                        else {\n                            pathToSend = prop;\n                        }\n                        if (proxyData.useHistory) {\n                            proxyData.history.push({\n                                object: JSON.parse(JSON.stringify(currentProxyData.baseData, jsonReplacer)),\n                                trace: stacks.reverse(),\n                                action: WatchAction[type],\n                                path: pathToSend\n                            });\n                        }\n                        [...currentProxyData.callbacks].forEach((cb) => {\n                            cb(WatchAction[type], pathToSend, value);\n                        });\n                    }\n                }\n            }\n        };\n        var realProxy = new Proxy(obj, proxyData);\n        proxyData.baseData = realProxy.__getTarget();\n        onlyDuringInit = false;\n        setProxyPath(realProxy, '');\n        return realProxy;\n    }\n}\n","dependances":[{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Watcher","required":false,"type":1,"isExported":true},{"code":"var WatchAction;\n(function (WatchAction) {\n    WatchAction[WatchAction[\"CREATED\"] = 0] = \"CREATED\";\n    WatchAction[WatchAction[\"UPDATED\"] = 1] = \"UPDATED\";\n    WatchAction[WatchAction[\"DELETED\"] = 2] = \"DELETED\";\n})(WatchAction || (WatchAction = {}));\n","dependances":[],"fullName":"Aventus.WatchAction","required":false,"type":6,"isExported":true},{"code":"class ResourceLoader {\n    static headerLoaded = {};\n    static headerWaiting = {};\n    /**\n     * Load the resource inside the head tag\n     */\n    static async loadInHead(options) {\n        const _options = this.prepareOptions(options);\n        if (this.headerLoaded[_options.url]) {\n            return true;\n        }\n        else if (this.headerWaiting.hasOwnProperty(_options.url)) {\n            return await this.awaitFctHead(_options.url);\n        }\n        else {\n            this.headerWaiting[_options.url] = [];\n            let tagEl;\n            if (_options.type == \"js\") {\n                tagEl = document.createElement(\"SCRIPT\");\n            }\n            else if (_options.type == \"css\") {\n                tagEl = document.createElement(\"LINK\");\n                tagEl.setAttribute(\"rel\", \"stylesheet\");\n            }\n            else {\n                throw \"unknow type \" + _options.type + \" to append into head\";\n            }\n            document.head.appendChild(tagEl);\n            let result = await this.loadTag(tagEl, _options.url);\n            this.headerLoaded[_options.url] = true;\n            this.releaseAwaitFctHead(_options.url, result);\n            return result;\n        }\n    }\n    static loadTag(tagEl, url) {\n        return new Promise((resolve, reject) => {\n            tagEl.addEventListener(\"load\", (e) => {\n                resolve(true);\n            });\n            tagEl.addEventListener(\"error\", (e) => {\n                resolve(false);\n            });\n            if (tagEl instanceof HTMLLinkElement) {\n                tagEl.setAttribute(\"href\", url);\n            }\n            else {\n                tagEl.setAttribute('src', url);\n            }\n        });\n    }\n    static releaseAwaitFctHead(url, result) {\n        if (this.headerWaiting[url]) {\n            for (let i = 0; i < this.headerWaiting[url].length; i++) {\n                this.headerWaiting[url][i](result);\n            }\n            delete this.headerWaiting[url];\n        }\n    }\n    static awaitFctHead(url) {\n        return new Promise((resolve) => {\n            this.headerWaiting[url].push((result) => {\n                resolve(result);\n            });\n        });\n    }\n    static requestLoaded = {};\n    static requestWaiting = {};\n    /**\n     *\n    */\n    static async load(options) {\n        options = this.prepareOptions(options);\n        if (this.requestLoaded[options.url]) {\n            return this.requestLoaded[options.url];\n        }\n        else if (this.requestWaiting.hasOwnProperty(options.url)) {\n            await this.awaitFct(options.url);\n            return this.requestLoaded[options.url];\n        }\n        else {\n            this.requestWaiting[options.url] = [];\n            let blob = false;\n            if (options.type == \"img\") {\n                blob = true;\n            }\n            let content = await this.fetching(options.url, blob);\n            this.requestLoaded[options.url] = content;\n            this.releaseAwaitFct(options.url);\n            return content;\n        }\n    }\n    static releaseAwaitFct(url) {\n        if (this.requestWaiting[url]) {\n            for (let i = 0; i < this.requestWaiting[url].length; i++) {\n                this.requestWaiting[url][i]();\n            }\n            delete this.requestWaiting[url];\n        }\n    }\n    static awaitFct(url) {\n        return new Promise((resolve) => {\n            this.requestWaiting[url].push(() => {\n                resolve('');\n            });\n        });\n    }\n    static async fetching(url, useBlob = false) {\n        if (useBlob) {\n            let result = await fetch(url, {\n                headers: {\n                    responseType: 'blob'\n                }\n            });\n            let blob = await result.blob();\n            return await this.readFile(blob);\n        }\n        else {\n            let result = await fetch(url);\n            return await result.text();\n        }\n    }\n    static readFile(blob) {\n        return new Promise((resolve) => {\n            var reader = new FileReader();\n            reader.onloadend = function () {\n                resolve(reader.result);\n            };\n            reader.readAsDataURL(blob);\n        });\n    }\n    static imgExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\"];\n    static prepareOptions(options) {\n        let result;\n        if (typeof options === 'string' || options instanceof String) {\n            result = {\n                url: options,\n                type: 'js'\n            };\n            let splittedURI = result.url.split('.');\n            let extension = splittedURI[splittedURI.length - 1];\n            extension = extension.split(\"?\")[0];\n            if (extension == \"svg\") {\n                result.type = 'svg';\n            }\n            else if (extension == \"js\") {\n                result.type = 'js';\n            }\n            else if (extension == \"css\") {\n                result.type = 'css';\n            }\n            else if (this.imgExtensions.indexOf(extension) != -1) {\n                result.type = 'img';\n            }\n            else {\n                throw 'unknow extension found :' + extension + \". Please define your extension inside options\";\n            }\n        }\n        else {\n            result = options;\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.ResourceLoaderHeadOptions","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.ResourceLoaderOptions","isStrong":false},{"fullName":"Blob","isStrong":false}],"fullName":"Aventus.ResourceLoader","required":false,"type":1,"isExported":true},{"code":"class ResizeObserver {\n    callback;\n    targets;\n    fpsInterval;\n    nextFrame;\n    entriesChangedEvent;\n    willTrigger;\n    static resizeObserverClassByObject = {};\n    static uniqueInstance;\n    static getUniqueInstance() {\n        if (!ResizeObserver.uniqueInstance) {\n            ResizeObserver.uniqueInstance = new window.ResizeObserver(entries => {\n                let allClasses = [];\n                for (let j = 0; j < entries.length; j++) {\n                    let entry = entries[j];\n                    let index = entry.target['sourceIndex'];\n                    if (ResizeObserver.resizeObserverClassByObject[index]) {\n                        for (let i = 0; i < ResizeObserver.resizeObserverClassByObject[index].length; i++) {\n                            let classTemp = ResizeObserver.resizeObserverClassByObject[index][i];\n                            classTemp.entryChanged(entry);\n                            if (allClasses.indexOf(classTemp) == -1) {\n                                allClasses.push(classTemp);\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < allClasses.length; i++) {\n                    allClasses[i].triggerCb();\n                }\n            });\n        }\n        return ResizeObserver.uniqueInstance;\n    }\n    constructor(options) {\n        let realOption;\n        if (options instanceof Function) {\n            realOption = {\n                callback: options,\n            };\n        }\n        else {\n            realOption = options;\n        }\n        this.callback = realOption.callback;\n        this.targets = [];\n        if (!realOption.fps) {\n            realOption.fps = 60;\n        }\n        if (realOption.fps != -1) {\n            this.fpsInterval = 1000 / realOption.fps;\n        }\n        this.nextFrame = 0;\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n    }\n    /**\n     * Observe size changing for the element\n     */\n    observe(target) {\n        if (!target[\"sourceIndex\"]) {\n            target[\"sourceIndex\"] = Math.random().toString(36);\n            this.targets.push(target);\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]] = [];\n            ResizeObserver.getUniqueInstance().observe(target);\n        }\n        if (ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].indexOf(this) == -1) {\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].push(this);\n        }\n    }\n    /**\n     * Stop observing size changing for the element\n     */\n    unobserve(target) {\n        for (let i = 0; this.targets.length; i++) {\n            let tempTarget = this.targets[i];\n            if (tempTarget == target) {\n                let position = ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].indexOf(this);\n                if (position != -1) {\n                    ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].splice(position, 1);\n                }\n                if (ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].length == 0) {\n                    delete ResizeObserver.resizeObserverClassByObject[target['sourceIndex']];\n                }\n                ResizeObserver.getUniqueInstance().unobserve(target);\n                this.targets.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Destroy the resize observer\n     */\n    disconnect() {\n        for (let i = 0; this.targets.length; i++) {\n            this.unobserve(this.targets[i]);\n        }\n    }\n    entryChanged(entry) {\n        let index = entry.target.sourceIndex;\n        this.entriesChangedEvent[index] = entry;\n    }\n    triggerCb() {\n        if (!this.willTrigger) {\n            this.willTrigger = true;\n            this._triggerCb();\n        }\n    }\n    _triggerCb() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (this.fpsInterval != -1 && elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => {\n                this._triggerCb();\n            });\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        let changed = Object.values(this.entriesChangedEvent);\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n        setTimeout(() => {\n            this.callback(changed);\n        }, 0);\n    }\n}\n","dependances":[{"fullName":"CallableFunction","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.WindowResizeObserver","isStrong":false},{"fullName":"Aventus.ResizeObserverOptions","isStrong":false}],"fullName":"Aventus.ResizeObserver","required":false,"type":1,"isExported":true},{"code":"class Instance {\n    static elements = new Map();\n    static get(type) {\n        let result = this.elements.get(type);\n        if (!result) {\n            let cst = type.prototype['constructor'];\n            result = new cst();\n            this.elements.set(type, result);\n        }\n        return result;\n    }\n    static set(el) {\n        let cst = el.constructor;\n        if (this.elements.get(cst)) {\n            return false;\n        }\n        this.elements.set(cst, el);\n        return true;\n    }\n    static destroy(el) {\n        let cst = el.constructor;\n        return this.elements.delete(cst);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.Instance","required":false,"type":1,"isExported":true},{"code":"class HttpRequest {\n    options = {};\n    url = '';\n    /**\n     * Get the right http method inside enum\n     */\n    static getMethod(method) {\n        let genericMethod = method.toLowerCase().trim();\n        if (genericMethod == \"get\") {\n            return HttpRequestMethod.GET;\n        }\n        if (genericMethod == \"post\") {\n            return HttpRequestMethod.POST;\n        }\n        if (genericMethod == \"delete\") {\n            return HttpRequestMethod.DELETE;\n        }\n        if (genericMethod == \"put\") {\n            return HttpRequestMethod.PUT;\n        }\n        if (genericMethod == \"option\") {\n            return HttpRequestMethod.OPTION;\n        }\n        console.error(\"unknow type \" + method + \". I ll return GET by default\");\n        return HttpRequestMethod.GET;\n    }\n    /**\n     * Get http method in string\n     */\n    getMethod(method) {\n        if (method == HttpRequestMethod.GET)\n            return \"GET\";\n        if (method == HttpRequestMethod.POST)\n            return \"POST\";\n        if (method == HttpRequestMethod.DELETE)\n            return \"DELETE\";\n        if (method == HttpRequestMethod.OPTION)\n            return \"OPTION\";\n        if (method == HttpRequestMethod.PUT)\n            return \"PUT\";\n        return \"GET\";\n    }\n    constructor(options) {\n        options = {\n            ...new DefaultHttpRequestOptions(),\n            ...options\n        };\n        let optionsToSend = {\n            method: this.getMethod(options.method),\n        };\n        if (options.data) {\n            if (!options.useJSON) {\n                if (options.data instanceof FormData) {\n                    optionsToSend.body = options.data;\n                }\n                else {\n                    let formData = new FormData();\n                    this.recuFillFormData(options.data, \"\", formData);\n                    optionsToSend.body = formData;\n                }\n            }\n            else {\n                optionsToSend.body = JSON.stringify(options.data);\n                optionsToSend.headers = {};\n                optionsToSend.headers['Content-Type'] = \"application/json\";\n            }\n        }\n        this.options = optionsToSend;\n        this.url = options.url;\n    }\n    recuFillFormData(data, key, form) {\n        if (typeof data === 'object' && data !== null) {\n            if (Array.isArray(data)) {\n                for (let i = 0; i < data.length; i++) {\n                    this.recuFillFormData(data[i], key + '[' + i + ']', form);\n                }\n            }\n            else if (data instanceof Date) {\n                form.append(key, data.toISOString());\n            }\n            else {\n                let props = Object.getOwnPropertyNames(data);\n                for (let prop of props) {\n                    let newKey = key === \"\" ? prop : key + '.' + prop;\n                    this.recuFillFormData(data[prop], newKey, form);\n                }\n            }\n        }\n        else {\n            form.append(key, data);\n        }\n    }\n    /**\n     * Send the http request\n     */\n    async send() {\n        let result = await fetch(this.url, this.options);\n        return result;\n    }\n    /**\n     * Send a get request\n     */\n    static async get(url) {\n        return await fetch(url, {\n            method: \"GET\"\n        });\n    }\n    /**\n     * Send a post request and wait a result in JSON format\n     */\n    static async post(url, data) {\n        let formData = new FormData();\n        for (let key in data) {\n            formData.append(key, data[key]);\n        }\n        const response = await fetch(url, {\n            method: \"POST\",\n            body: formData\n        });\n        const content = await response.json();\n        return new Promise((resolve, reject) => {\n            if (response.ok) {\n                resolve(content);\n            }\n            else {\n                reject(content);\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"RequestInit","isStrong":false},{"fullName":"Aventus.HttpRequestMethod","isStrong":false},{"fullName":"Aventus.DefaultHttpRequestOptions","isStrong":false},{"fullName":"FormData","isStrong":false}],"fullName":"Aventus.HttpRequest","required":false,"type":1,"isExported":true},{"code":"var HttpRequestMethod;\n(function (HttpRequestMethod) {\n    HttpRequestMethod[HttpRequestMethod[\"GET\"] = 0] = \"GET\";\n    HttpRequestMethod[HttpRequestMethod[\"POST\"] = 1] = \"POST\";\n    HttpRequestMethod[HttpRequestMethod[\"DELETE\"] = 2] = \"DELETE\";\n    HttpRequestMethod[HttpRequestMethod[\"PUT\"] = 3] = \"PUT\";\n    HttpRequestMethod[HttpRequestMethod[\"OPTION\"] = 4] = \"OPTION\";\n})(HttpRequestMethod || (HttpRequestMethod = {}));\n","dependances":[],"fullName":"Aventus.HttpRequestMethod","required":false,"type":6,"isExported":true},{"code":"class DefaultHttpRequestOptions {\n    url = \"\";\n    method = HttpRequestMethod.GET;\n    useJSON = false;\n}\n","dependances":[{"fullName":"Aventus.HttpRequestOptions","isStrong":true},{"fullName":"Aventus.HttpRequestMethod","isStrong":false}],"fullName":"Aventus.DefaultHttpRequestOptions","required":false,"type":1,"isExported":true},{"code":"class DragAndDrop {\n    /**\n     * Default offset before drag element\n     */\n    static defaultOffsetDrag = 20;\n    pressManager;\n    options;\n    startCursorPosition;\n    startElementPosition;\n    isEnable = true;\n    constructor(options) {\n        this.options = this.getDefaultOptions();\n        this.mergeProperties(options);\n        this.mergeFunctions(options);\n        this.init();\n    }\n    getDefaultOptions() {\n        return {\n            applyDrag: true,\n            element: null,\n            elementTrigger: null,\n            offsetDrag: DragAndDrop.defaultOffsetDrag,\n            shadow: {\n                enable: false,\n                container: document.body,\n                removeOnStop: true,\n                transform: () => { }\n            },\n            strict: false,\n            targets: [],\n            usePercent: false,\n            isDragEnable: () => true,\n            getZoom: () => 1,\n            getOffsetX: () => 0,\n            getOffsetY: () => 0,\n            onPointerDown: (e) => { },\n            onPointerUp: (e) => { },\n            onStart: (e) => { },\n            onMove: (e) => { },\n            onStop: (e) => { },\n            onDrop: (element, targets) => { }\n        };\n    }\n    mergeProperties(options) {\n        if (options.element === void 0) {\n            throw \"You must define the element for the drag&drop\";\n        }\n        this.options.element = options.element;\n        if (options.elementTrigger === void 0) {\n            this.options.elementTrigger = this.options.element;\n        }\n        else {\n            this.options.elementTrigger = options.elementTrigger;\n        }\n        this.defaultMerge(options, \"applyDrag\");\n        this.defaultMerge(options, \"offsetDrag\");\n        this.defaultMerge(options, \"strict\");\n        this.defaultMerge(options, \"targets\");\n        this.defaultMerge(options, \"usePercent\");\n        if (options.shadow !== void 0) {\n            this.options.shadow.enable = options.shadow.enable;\n            if (options.shadow.container !== void 0) {\n                this.options.shadow.container = options.shadow.container;\n            }\n            else {\n                this.options.shadow.container = document.body;\n            }\n            if (options.shadow.removeOnStop !== void 0) {\n                this.options.shadow.removeOnStop = options.shadow.removeOnStop;\n            }\n            if (options.shadow.transform !== void 0) {\n                this.options.shadow.transform = options.shadow.transform;\n            }\n        }\n    }\n    mergeFunctions(options) {\n        this.defaultMerge(options, \"isDragEnable\");\n        this.defaultMerge(options, \"getZoom\");\n        this.defaultMerge(options, \"getOffsetX\");\n        this.defaultMerge(options, \"getOffsetY\");\n        this.defaultMerge(options, \"onPointerDown\");\n        this.defaultMerge(options, \"onPointerUp\");\n        this.defaultMerge(options, \"onStart\");\n        this.defaultMerge(options, \"onMove\");\n        this.defaultMerge(options, \"onStop\");\n        this.defaultMerge(options, \"onDrop\");\n    }\n    defaultMerge(options, name) {\n        if (options[name] !== void 0) {\n            this.options[name] = options[name];\n        }\n    }\n    init() {\n        this.pressManager = new PressManager({\n            element: this.options.elementTrigger,\n            onPressStart: this.onPressStart.bind(this),\n            onPressEnd: this.onPressEnd.bind(this),\n            onDragStart: this.onDragStart.bind(this),\n            onDrag: this.onDrag.bind(this),\n            onDragEnd: this.onDragEnd.bind(this),\n            offsetDrag: this.options.offsetDrag\n        });\n    }\n    draggableElement;\n    positionShadowRelativeToElement;\n    onPressStart(e) {\n        this.options.onPointerDown(e);\n    }\n    onPressEnd(e) {\n        this.options.onPointerUp(e);\n    }\n    onDragStart(e) {\n        this.isEnable = this.options.isDragEnable();\n        if (!this.isEnable) {\n            return;\n        }\n        this.draggableElement = this.options.element;\n        this.startCursorPosition = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        this.startElementPosition = {\n            x: this.draggableElement.offsetLeft,\n            y: this.draggableElement.offsetTop\n        };\n        if (this.options.shadow.enable) {\n            this.draggableElement = this.options.element.cloneNode(true);\n            let elBox = this.options.element.getBoundingClientRect();\n            let containerBox = this.options.shadow.container.getBoundingClientRect();\n            this.positionShadowRelativeToElement = {\n                x: elBox.x - containerBox.x,\n                y: elBox.y - containerBox.y\n            };\n            if (this.options.applyDrag) {\n                this.draggableElement.style.position = \"absolute\";\n                this.draggableElement.style.top = this.positionShadowRelativeToElement.y + this.options.getOffsetY() + 'px';\n                this.draggableElement.style.left = this.positionShadowRelativeToElement.x + this.options.getOffsetX() + 'px';\n            }\n            this.options.shadow.transform(this.draggableElement);\n            this.options.shadow.container.appendChild(this.draggableElement);\n        }\n        this.options.onStart(e);\n    }\n    onDrag(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let zoom = this.options.getZoom();\n        let diff = {\n            x: 0,\n            y: 0\n        };\n        if (this.options.shadow.enable) {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) + this.positionShadowRelativeToElement.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) + this.positionShadowRelativeToElement.y + this.options.getOffsetY(),\n            };\n        }\n        else {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) / zoom + this.startElementPosition.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) / zoom + this.startElementPosition.y + this.options.getOffsetY()\n            };\n        }\n        let newPos = this.setPosition(diff);\n        this.options.onMove(e, newPos);\n    }\n    onDragEnd(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let targets = this.getMatchingTargets();\n        if (this.options.shadow.enable && this.options.shadow.removeOnStop) {\n            this.draggableElement.parentNode?.removeChild(this.draggableElement);\n        }\n        if (targets.length > 0) {\n            this.options.onDrop(this.draggableElement, targets);\n        }\n        this.options.onStop(e);\n    }\n    setPosition(position) {\n        if (this.options.usePercent) {\n            let elementParent = this.draggableElement.offsetParent;\n            const percentLeft = (position.x / elementParent.offsetWidth) * 100;\n            const percentTop = (position.y / elementParent.offsetHeight) * 100;\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = percentLeft + '%';\n                this.draggableElement.style.top = percentTop + '%';\n            }\n            return {\n                x: percentLeft,\n                y: percentTop\n            };\n        }\n        else {\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = position.x + 'px';\n                this.draggableElement.style.top = position.y + 'px';\n            }\n        }\n        return position;\n    }\n    /**\n     * Get targets within the current element position is matching\n     */\n    getMatchingTargets() {\n        let matchingTargets = [];\n        for (let target of this.options.targets) {\n            const elementCoordinates = this.draggableElement.getBoundingClientRect();\n            const targetCoordinates = target.getBoundingClientRect();\n            let offsetX = this.options.getOffsetX();\n            let offsetY = this.options.getOffsetY();\n            let zoom = this.options.getZoom();\n            targetCoordinates.x += offsetX;\n            targetCoordinates.y += offsetY;\n            targetCoordinates.width *= zoom;\n            targetCoordinates.height *= zoom;\n            if (this.options.strict) {\n                if ((elementCoordinates.x >= targetCoordinates.x && elementCoordinates.x + elementCoordinates.width <= targetCoordinates.x + targetCoordinates.width) &&\n                    (elementCoordinates.y >= targetCoordinates.y && elementCoordinates.y + elementCoordinates.height <= targetCoordinates.y + targetCoordinates.height)) {\n                    matchingTargets.push(target);\n                }\n            }\n            else {\n                let elementLeft = elementCoordinates.x;\n                let elementRight = elementCoordinates.x + elementCoordinates.width;\n                let elementTop = elementCoordinates.y;\n                let elementBottom = elementCoordinates.y + elementCoordinates.height;\n                let targetLeft = targetCoordinates.x;\n                let targetRight = targetCoordinates.x + targetCoordinates.width;\n                let targetTop = targetCoordinates.y;\n                let targetBottom = targetCoordinates.y + targetCoordinates.height;\n                if (!(elementRight < targetLeft ||\n                    elementLeft > targetRight ||\n                    elementBottom < targetTop ||\n                    elementTop > targetBottom)) {\n                    matchingTargets.push(target);\n                }\n            }\n        }\n        return matchingTargets;\n    }\n    /**\n     * Get element currently dragging\n     */\n    getElementDrag() {\n        return this.draggableElement;\n    }\n    /**\n     * Set targets where to drop\n     */\n    setTargets(targets) {\n        this.options.targets = targets;\n    }\n    /**\n     * Destroy the current drag&drop instance\n     */\n    destroy() {\n        this.pressManager.destroy();\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.Coordinate","isStrong":false},{"fullName":"Aventus.DragAndDropOptions","isStrong":false}],"fullName":"Aventus.DragAndDrop","required":false,"type":1,"isExported":true},{"code":"class PressManager {\n    options;\n    element;\n    subPressManager = [];\n    delayDblPress = 150;\n    delayLongPress = 700;\n    nbPress = 0;\n    offsetDrag = 20;\n    state = {\n        oneActionTriggered: false,\n        isMoving: false,\n    };\n    startPosition = { x: 0, y: 0 };\n    customFcts = {};\n    timeoutDblPress = 0;\n    timeoutLongPress = 0;\n    downEventSaved;\n    actionsName = {\n        press: \"press\",\n        longPress: \"longPress\",\n        dblPress: \"dblPress\",\n        drag: \"drag\"\n    };\n    useDblPress = false;\n    functionsBinded = {\n        downAction: (e) => { },\n        upAction: (e) => { },\n        moveAction: (e) => { },\n        childPressStart: (e) => { },\n        childPressEnd: (e) => { },\n        childPress: (e) => { },\n        childDblPress: (e) => { },\n        childLongPress: (e) => { },\n        childDragStart: (e) => { },\n    };\n    /**\n     * @param {*} options - The options\n     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage\n     */\n    constructor(options) {\n        if (options.element === void 0) {\n            throw 'You must provide an element';\n        }\n        if (Array.isArray(options.element)) {\n            for (let el of options.element) {\n                let cloneOpt = { ...options };\n                cloneOpt.element = el;\n                this.subPressManager.push(new PressManager(cloneOpt));\n            }\n        }\n        else {\n            this.element = options.element;\n            this.checkDragConstraint(options);\n            this.assignValueOption(options);\n            this.options = options;\n            this.init();\n        }\n    }\n    /**\n     * Get the current element focused by the PressManager\n     */\n    getElement() {\n        return this.element;\n    }\n    checkDragConstraint(options) {\n        if (options.onDrag !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragStart !== void 0) {\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragEnd !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n        }\n    }\n    assignValueOption(options) {\n        if (options.delayDblPress !== undefined) {\n            this.delayDblPress = options.delayDblPress;\n        }\n        if (options.delayLongPress !== undefined) {\n            this.delayLongPress = options.delayLongPress;\n        }\n        if (options.offsetDrag !== undefined) {\n            this.offsetDrag = options.offsetDrag;\n        }\n        if (options.onDblPress !== undefined) {\n            this.useDblPress = true;\n        }\n        if (options.forceDblPress) {\n            this.useDblPress = true;\n        }\n    }\n    bindAllFunction() {\n        this.functionsBinded.downAction = this.downAction.bind(this);\n        this.functionsBinded.moveAction = this.moveAction.bind(this);\n        this.functionsBinded.upAction = this.upAction.bind(this);\n        this.functionsBinded.childDblPress = this.childDblPress.bind(this);\n        this.functionsBinded.childDragStart = this.childDragStart.bind(this);\n        this.functionsBinded.childLongPress = this.childLongPress.bind(this);\n        this.functionsBinded.childPress = this.childPress.bind(this);\n        this.functionsBinded.childPressStart = this.childPressStart.bind(this);\n        this.functionsBinded.childPressEnd = this.childPressEnd.bind(this);\n    }\n    init() {\n        this.bindAllFunction();\n        this.element.addEventListener(\"pointerdown\", this.functionsBinded.downAction);\n        this.element.addEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n        this.element.addEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n        this.element.addEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n        this.element.addEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n        this.element.addEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n        this.element.addEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n    }\n    downAction(e) {\n        this.downEventSaved = e;\n        e.stopImmediatePropagation();\n        this.customFcts = {};\n        if (this.nbPress == 0) {\n            this.state.oneActionTriggered = false;\n            clearTimeout(this.timeoutDblPress);\n        }\n        this.startPosition = { x: e.pageX, y: e.pageY };\n        document.addEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.addEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        this.timeoutLongPress = setTimeout(() => {\n            if (!this.state.oneActionTriggered) {\n                if (this.options.onLongPress) {\n                    this.state.oneActionTriggered = true;\n                    this.options.onLongPress(e, this);\n                    this.triggerEventToParent(this.actionsName.longPress, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"longpress\", e);\n                }\n            }\n        }, this.delayLongPress);\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e, this);\n            this.emitTriggerFunction(\"pressstart\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressstart\", e);\n        }\n    }\n    upAction(e) {\n        e.stopImmediatePropagation();\n        document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        clearTimeout(this.timeoutLongPress);\n        if (this.state.isMoving) {\n            this.state.isMoving = false;\n            if (this.options.onDragEnd) {\n                this.options.onDragEnd(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDragEnd) {\n                this.customFcts.onDragEnd(e, this.customFcts.src);\n            }\n        }\n        else {\n            if (this.useDblPress) {\n                this.nbPress++;\n                if (this.nbPress == 2) {\n                    if (!this.state.oneActionTriggered) {\n                        this.state.oneActionTriggered = true;\n                        this.nbPress = 0;\n                        if (this.options.onDblPress) {\n                            this.options.onDblPress(e, this);\n                            this.triggerEventToParent(this.actionsName.dblPress, e);\n                        }\n                        else {\n                            this.emitTriggerFunction(\"dblpress\", e);\n                        }\n                    }\n                }\n                else if (this.nbPress == 1) {\n                    this.timeoutDblPress = setTimeout(() => {\n                        this.nbPress = 0;\n                        if (!this.state.oneActionTriggered) {\n                            if (this.options.onPress) {\n                                this.state.oneActionTriggered = true;\n                                this.options.onPress(e, this);\n                                this.triggerEventToParent(this.actionsName.press, e);\n                            }\n                            else {\n                                this.emitTriggerFunction(\"press\", e);\n                            }\n                        }\n                    }, this.delayDblPress);\n                }\n            }\n            else {\n                if (!this.state.oneActionTriggered) {\n                    if (this.options.onPress) {\n                        this.state.oneActionTriggered = true;\n                        this.options.onPress(e, this);\n                        this.triggerEventToParent(this.actionsName.press, e);\n                    }\n                    else {\n                        this.emitTriggerFunction(\"press\", e);\n                    }\n                }\n            }\n        }\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e, this);\n            this.emitTriggerFunction(\"pressend\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressend\", e);\n        }\n    }\n    moveAction(e) {\n        if (!this.state.isMoving && !this.state.oneActionTriggered) {\n            e.stopImmediatePropagation();\n            let xDist = e.pageX - this.startPosition.x;\n            let yDist = e.pageY - this.startPosition.y;\n            let distance = Math.sqrt(xDist * xDist + yDist * yDist);\n            if (distance > this.offsetDrag) {\n                this.state.oneActionTriggered = true;\n                if (this.options.onDragStart) {\n                    this.state.isMoving = true;\n                    this.options.onDragStart(this.downEventSaved, this);\n                    this.triggerEventToParent(this.actionsName.drag, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"dragstart\", this.downEventSaved);\n                }\n            }\n        }\n        else if (this.state.isMoving) {\n            if (this.options.onDrag) {\n                this.options.onDrag(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDrag) {\n                this.customFcts.onDrag(e, this.customFcts.src);\n            }\n        }\n    }\n    triggerEventToParent(eventName, pointerEvent) {\n        if (this.element.parentNode) {\n            this.element.parentNode.dispatchEvent(new CustomEvent(\"pressaction_trigger\", {\n                bubbles: true,\n                cancelable: false,\n                composed: true,\n                detail: {\n                    target: this.element,\n                    eventName: eventName,\n                    realEvent: pointerEvent\n                }\n            }));\n        }\n    }\n    childPressStart(e) {\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e.detail.realEvent, this);\n        }\n    }\n    childPressEnd(e) {\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e.detail.realEvent, this);\n        }\n    }\n    childPress(e) {\n        if (this.options.onPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.press, e.detail.realEvent);\n        }\n    }\n    childDblPress(e) {\n        if (this.options.onDblPress) {\n            e.stopImmediatePropagation();\n            if (e.detail.state) {\n                e.detail.state.oneActionTriggered = true;\n            }\n            this.options.onDblPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.dblPress, e.detail.realEvent);\n        }\n    }\n    childLongPress(e) {\n        if (this.options.onLongPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onLongPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.longPress, e.detail.realEvent);\n        }\n    }\n    childDragStart(e) {\n        if (this.options.onDragStart) {\n            e.stopImmediatePropagation();\n            e.detail.state.isMoving = true;\n            e.detail.customFcts.src = this;\n            e.detail.customFcts.onDrag = this.options.onDrag;\n            e.detail.customFcts.onDragEnd = this.options.onDragEnd;\n            e.detail.customFcts.offsetDrag = this.options.offsetDrag;\n            this.options.onDragStart(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.drag, e.detail.realEvent);\n        }\n    }\n    emitTriggerFunction(action, e, el = null) {\n        let ev = new CustomEvent(\"trigger_pointer_\" + action, {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n            detail: {\n                state: this.state,\n                customFcts: this.customFcts,\n                realEvent: e\n            }\n        });\n        if (!el) {\n            el = this.element;\n        }\n        el.dispatchEvent(ev);\n    }\n    /**\n     * Destroy the Press instance byremoving all events\n     */\n    destroy() {\n        for (let sub of this.subPressManager) {\n            sub.destroy();\n        }\n        if (this.element) {\n            this.element.removeEventListener(\"pointerdown\", this.functionsBinded.downAction);\n            this.element.removeEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n            this.element.removeEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n            this.element.removeEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n            this.element.removeEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n            this.element.removeEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n            this.element.removeEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.PressManagerState","isStrong":false},{"fullName":"Aventus.InternalCustomFunction","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.InternalPointerEvent","isStrong":false}],"fullName":"Aventus.PressManager","required":false,"type":1,"isExported":true},{"code":"class Callback {\n    callbacks = [];\n    /**\n     * Clear all callbacks\n     */\n    clear() {\n        this.callbacks = [];\n    }\n    /**\n     * Add a callback\n     */\n    add(cb) {\n        this.callbacks.push(cb);\n    }\n    /**\n     * Remove a callback\n     */\n    remove(cb) {\n        let index = this.callbacks.indexOf(cb);\n        if (index != -1) {\n            this.callbacks.splice(index, 1);\n        }\n    }\n    /**\n     * Trigger all callbacks\n     */\n    trigger(args) {\n        let result = [];\n        for (let callback of this.callbacks) {\n            result.push(callback.apply(null, args));\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.Callback","required":false,"type":1,"isExported":true},{"code":"class CallbackGroup {\n    callbacks = {};\n    /**\n     * Clear all callbacks\n     */\n    clearAll() {\n        this.callbacks = {};\n    }\n    /**\n     * Clear all callbacks for a specific group\n     */\n    clear(group) {\n        delete this.callbacks[group];\n    }\n    /**\n     * Add a callback for a group\n     */\n    add(group, cb) {\n        if (!this.callbacks[group]) {\n            this.callbacks[group] = [];\n        }\n        this.callbacks[group].push(cb);\n    }\n    /**\n     * Remove a callback for a group\n     */\n    remove(group, cb) {\n        if (this.callbacks[group]) {\n            let index = this.callbacks[group].indexOf(cb);\n            if (index != -1) {\n                this.callbacks[group].splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Trigger all callbacks inside a group\n     */\n    trigger(group, args) {\n        if (this.callbacks[group]) {\n            for (let callback of this.callbacks[group]) {\n                callback.apply(null, args);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.CallbackGroup","required":false,"type":1,"isExported":true},{"code":"class Animation {\n    /**\n     * Default FPS for all Animation if not set inside options\n     */\n    static FPS_DEFAULT = 60;\n    options;\n    nextFrame;\n    fpsInterval;\n    continueAnimation = false;\n    constructor(options) {\n        if (!options.animate) {\n            options.animate = () => { };\n        }\n        if (!options.stopped) {\n            options.stopped = () => { };\n        }\n        if (!options.fps) {\n            options.fps = Animation.FPS_DEFAULT;\n        }\n        this.options = options;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    animate() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => this.animate());\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        setTimeout(() => {\n            this.options.animate();\n        }, 0);\n        if (this.continueAnimation) {\n            requestAnimationFrame(() => this.animate());\n        }\n        else {\n            this.options.stopped();\n        }\n    }\n    /**\n     * Start the of animation\n     */\n    start() {\n        if (this.continueAnimation == false) {\n            this.continueAnimation = true;\n            this.nextFrame = window.performance.now();\n            this.animate();\n        }\n    }\n    /**\n     * Stop the animation\n     */\n    stop() {\n        this.continueAnimation = false;\n    }\n    /**\n     * Get the FPS\n     */\n    getFPS() {\n        return this.options.fps;\n    }\n    /**\n     * Set the FPS\n     */\n    setFPS(fps) {\n        this.options.fps = fps;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    /**\n     * Get the animation status (true if animation is running)\n     */\n    isStarted() {\n        return this.continueAnimation;\n    }\n}\n","dependances":[{"fullName":"Aventus.AnimationOptions","isStrong":false}],"fullName":"Aventus.Animation","required":false,"type":1,"isExported":true},{"code":"class DataManager {\n    static info = new Map();\n    /**\n     * Register a unique string type for a data\n     */\n    static register($type, cst) {\n        this.info.set($type, cst);\n    }\n    /**\n     * Get the contructor for the unique string type\n     */\n    static getConstructor($type) {\n        let result = this.info.get($type);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Clone the object to keep real type\n     */\n    static clone(data) {\n        return this.createObject(JSON.parse(JSON.stringify(data)));\n    }\n    /**\n     * Create an object with the type management\n     * Usefull to convert object from JSON into Js class\n     */\n    static createObject(data, transfromToDate = false) {\n        if (typeof data === 'object' && data !== null) {\n            if (data instanceof Date) {\n                return data;\n            }\n            if (Array.isArray(data)) {\n                let result = [];\n                for (let element of data) {\n                    result.push(this.createObject(element));\n                }\n                return result;\n            }\n            if (data.$type) {\n                let cst = DataManager.getConstructor(data.$type);\n                if (cst) {\n                    let obj = new cst();\n                    let props = Object.getOwnPropertyNames(obj);\n                    for (let prop of props) {\n                        if (data[prop] !== undefined) {\n                            let propInfo = Object.getOwnPropertyDescriptor(obj, prop);\n                            if (propInfo.writable) {\n                                if (obj[prop] instanceof Date) {\n                                    obj[prop] = this.createObject(data[prop], true);\n                                }\n                                else {\n                                    obj[prop] = this.createObject(data[prop]);\n                                }\n                            }\n                        }\n                    }\n                    return obj;\n                }\n            }\n            else {\n                let result = {};\n                for (let key in data) {\n                    result[key] = this.createObject(data[key]);\n                }\n                return result;\n            }\n        }\n        else if (transfromToDate && typeof data === \"string\") {\n            return new Date(data);\n        }\n        return data;\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.DataManager","required":false,"type":1,"isExported":true},{"code":"class Data {\n    /**\n     * The schema for the class\n     */\n    static get $schema() { return {}; }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * Get the name of the class\n     */\n    get className() {\n        return this.constructor.name;\n    }\n    /**\n     * Get a JSON for the current object\n     */\n    toJSON() {\n        let result = { $type: this.$type };\n        let props = Object.getOwnPropertyNames(this);\n        for (let prop of props) {\n            let propInfo = Object.getOwnPropertyDescriptor(this, prop);\n            if (propInfo.writable) {\n                result[prop] = this[prop];\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Aventus.DataManager","isStrong":true}],"fullName":"Aventus.Data","required":false,"type":1,"isExported":true},{"code":"class RamError extends GenericError {\n}\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Aventus.RamErrorCode","isStrong":true}],"fullName":"Aventus.RamError","required":false,"type":1,"isExported":true},{"code":"class ResultRamWithError extends ResultWithError {\n}\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"Aventus.RamError","isStrong":true}],"fullName":"Aventus.ResultRamWithError","required":false,"type":1,"isExported":true},{"code":"class Socket {\n    options;\n    waitingList = {};\n    multipltWaitingList = {};\n    timeoutError;\n    memoryBeforeOpen = [];\n    socket;\n    constructor() {\n        this._configure(this.configure({}));\n    }\n    /**\n     * Configure a new Websocket\n     */\n    _configure(options = {}) {\n        if (!options.host) {\n            options.host = window.location.hostname;\n        }\n        if (!options.hasOwnProperty('useHttps')) {\n            options.useHttps = window.location.protocol == \"https:\";\n        }\n        if (!options.port) {\n            if (window.location.port) {\n                options.port = parseInt(window.location.port);\n            }\n            else {\n                options.port = options.useHttps ? 443 : 80;\n            }\n        }\n        if (!options.routes) {\n            options.routes = {};\n        }\n        if (!options.socketName) {\n            options.socketName = \"\";\n        }\n        this.options = options;\n    }\n    /**\n     * Add a new route to listen to the websocket\n     */\n    addRoute(newRoute) {\n        if (!this.options.routes.hasOwnProperty(newRoute.channel)) {\n            this.options.routes[newRoute.channel] = [];\n        }\n        this.options.routes[newRoute.channel].push(newRoute);\n    }\n    /**\n     * The route to remove\n     * @param route - The route to remove\n     */\n    removeRoute(route) {\n        let index = this.options.routes[route.channel].indexOf(route);\n        if (index != -1) {\n            this.options.routes[route.channel].splice(index, 1);\n        }\n    }\n    openCallback;\n    /**\n     * Try to open the websocket\n     */\n    open() {\n        return new Promise((resolve) => {\n            try {\n                if (this.socket) {\n                    this.socket.close();\n                }\n                let protocol = \"ws\";\n                if (this.options.useHttps) {\n                    protocol = \"wss\";\n                }\n                let url = protocol + \"://\" + this.options.host + \":\" + this.options.port + \"/ws/\" + this.options.socketName;\n                this.log(url);\n                this.openCallback = (isOpen) => {\n                    resolve(isOpen);\n                };\n                this.socket = new WebSocket(url);\n                this.socket.onopen = this._onOpen.bind(this);\n                this.socket.onclose = this._onClose.bind(this);\n                this.socket.onerror = this._onError.bind(this);\n                this.socket.onmessage = this.onMessage.bind(this);\n            }\n            catch (e) {\n                console.log(e);\n                resolve(false);\n            }\n        });\n    }\n    jsonReplacer(key, value) {\n        if (this[key] instanceof Date && this[key].getFullYear() < 100) {\n            return \"0001-01-01T00:00:00\";\n        }\n        return value;\n    }\n    /**\n     * Send a message though the websocket\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param options the options to add to the message (typically the uid)\n     */\n    sendMessage(channelName, data = null, options = {}) {\n        if (this.socket && this.socket.readyState == 1) {\n            let message = {\n                channel: channelName,\n            };\n            for (let key in options) {\n                message[key] = options[key];\n            }\n            if (data) {\n                message.data = data;\n                this.log(message);\n                if (typeof data != 'string') {\n                    message.data = JSON.stringify(data, this.jsonReplacer);\n                }\n            }\n            else {\n                this.log(message);\n            }\n            this.socket.send(JSON.stringify(message));\n        }\n        else {\n            this.log('Socket not ready ! Please ensure that it is open and ready to send message');\n            this.memoryBeforeOpen.push({\n                channelName: channelName,\n                data: data,\n                options: options\n            });\n        }\n    }\n    /**\n     * Send a message though the websocket and wait one answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWait(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.waitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    ;\n    /**\n     * Send a message though the websocket and wait answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWaitMultiple(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.multipltWaitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    /**\n     * Check if socket is ready\n     */\n    isReady() {\n        if (this.socket && this.socket.readyState == 1) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Callback when the websocket connection is open\n     */\n    onOpen() {\n    }\n    _onOpen() {\n        if (this.socket && this.socket.readyState == 1) {\n            if (this.openCallback) {\n                this.openCallback(true);\n                this.openCallback = null;\n            }\n            this.log('Connection successfully established !' + this.options.host + \":\" + this.options.port);\n            window.clearTimeout(this.timeoutError);\n            this.onOpen();\n            for (let i = 0; i < this.memoryBeforeOpen.length; i++) {\n                this.sendMessage(this.memoryBeforeOpen[i].channelName, this.memoryBeforeOpen[i].data, this.memoryBeforeOpen[i].options);\n            }\n            this.memoryBeforeOpen = [];\n        }\n        else {\n            if (this.openCallback) {\n                this.openCallback(false);\n                this.openCallback = null;\n            }\n        }\n    }\n    errorOccur;\n    /**\n     * Callback called when the socket as an error\n     */\n    onError(event) {\n    }\n    _onError(event) {\n        this.errorOccur = true;\n        if (this.openCallback) {\n            this.openCallback(false);\n            this.openCallback = null;\n            return;\n        }\n        this.log('An error has occured');\n        this.onError(event);\n    }\n    /**\n     * Callback called when the connection closed without calling the close function\n     * By default the socket will try to reconnect each 5000ms\n     */\n    onClose(event) {\n        let reopenInterval = setInterval(async () => {\n            console.warn(\"try reopen socket \");\n            if (await this.open()) {\n                clearInterval(reopenInterval);\n            }\n        }, 5000);\n    }\n    _onClose(event) {\n        if (this.errorOccur) {\n            this.errorOccur = false;\n            return;\n        }\n        this.log('Closing connection');\n        this.onClose(event);\n    }\n    /**\n     * Close the current connection\n     */\n    close() {\n        if (this.socket) {\n            this.socket.onclose = null;\n            this.socket.onerror = null;\n            this.socket.onmessage = null;\n            this.socket.onopen = null;\n            this.socket.close();\n            delete this.socket;\n        }\n    }\n    onMessage(event) {\n        let response = JSON.parse(event.data);\n        this.log(response);\n        response.data = JSON.parse(response.data);\n        if (this.options.routes.hasOwnProperty(response.channel)) {\n            this.options.routes[response.channel].forEach(element => {\n                element.callback(response.data);\n            });\n        }\n        if (response.uid) {\n            if (this.waitingList.hasOwnProperty(response.uid)) {\n                let group = this.waitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    group[response.channel](response.data);\n                }\n                delete this.waitingList[response.uid];\n            }\n            else if (this.multipltWaitingList.hasOwnProperty(response.uid)) {\n                let group = this.multipltWaitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    try {\n                        group[response.channel](response.data);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                }\n                delete this.multipltWaitingList[response.uid];\n            }\n        }\n    }\n    /**\n     * Print a msg inside the console\n     */\n    log(message) {\n        if (this.options.log) {\n            const now = new Date();\n            const hours = (now.getHours()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const minutes = (now.getMinutes()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const seconds = (now.getSeconds()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            if (message instanceof Object) {\n                let cloneMessage = JSON.parse(JSON.stringify(message, this.jsonReplacer));\n                if (cloneMessage.data && typeof cloneMessage.data == 'string') {\n                    cloneMessage.data = JSON.parse(cloneMessage.data);\n                }\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, cloneMessage);\n            }\n            else {\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, message);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.ISocket","isStrong":true},{"fullName":"Aventus.SocketOptions","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.SocketMessage","isStrong":false},{"fullName":"Event","isStrong":false},{"fullName":"MessageEvent","isStrong":false}],"fullName":"Aventus.Socket","required":false,"type":1,"isExported":true}],"existing":[{"fullName":"Aventus.Loop","dependances":[]},{"fullName":"Aventus.ActionEventCallback","dependances":[]},{"fullName":"Aventus.ActionEventListener","dependances":[]},{"fullName":"Aventus.ActionBindings","dependances":[]},{"fullName":"Aventus.ActionInjection","dependances":[]},{"fullName":"Aventus.ActionChange","dependances":[]},{"fullName":"Aventus.ActionEvent","dependances":[]},{"fullName":"Aventus.ContextValues","dependances":[]},{"fullName":"Aventus.Actions","dependances":[]},{"fullName":"Aventus.ContextSchema","dependances":[]},{"fullName":"Aventus.WebComponentTemplateHTML","dependances":[]},{"fullName":"Aventus.DefaultComponent","dependances":[]},{"fullName":"Aventus.DebuggerConfig","dependances":[]},{"fullName":"Aventus.StateAskChangeFct","dependances":[]},{"fullName":"Aventus.StateInactivationFct","dependances":[]},{"fullName":"Aventus.StateActivationFct","dependances":[]},{"fullName":"Aventus.StateSlug","dependances":[]},{"fullName":"Aventus.StateAction","dependances":[]},{"fullName":"Aventus.Subscriber","dependances":[]},{"fullName":"Aventus.SocketMessage","dependances":[]},{"fullName":"Aventus.SocketRoute","dependances":[]},{"fullName":"Aventus.SocketOptions","dependances":[]},{"fullName":"Aventus.ISocket","dependances":[]},{"fullName":"Aventus.RamWsCallback","dependances":[]},{"fullName":"Aventus.RamWsRoute","dependances":[]},{"fullName":"Aventus.RamWsRoutes","dependances":[]},{"fullName":"Aventus.KeysObject","dependances":[]},{"fullName":"Aventus.RamItem","dependances":[]},{"fullName":"Aventus.RamSubscribers","dependances":[]},{"fullName":"Aventus.IRamAction","dependances":[]},{"fullName":"Aventus.IRam","dependances":[]},{"fullName":"Aventus.ResourceLoaderHeadOptions","dependances":[]},{"fullName":"Aventus.ResourceLoaderOptions","dependances":[]},{"fullName":"Aventus.WindowResizeObserver","dependances":[]},{"fullName":"Aventus.ResizeObserverOptions","dependances":[]},{"fullName":"Aventus.Pointer","dependances":[]},{"fullName":"Aventus.HttpRequestOptions","dependances":[]},{"fullName":"Aventus.InternalPointerEvent","dependances":[{"fullName":"Event","isStrong":true}]},{"fullName":"Aventus.InternalCustomFunction","dependances":[]},{"fullName":"Aventus.PressManagerState","dependances":[]},{"fullName":"Aventus.PressManagerOptions","dependances":[]},{"fullName":"Aventus.Coordinate","dependances":[]},{"fullName":"Aventus.DragAndDropOptions","dependances":[]},{"fullName":"Aventus.AnimationOptions","dependances":[]},{"fullName":"Aventus.IData","dependances":[]}]}
>>>>>>> 69d64e6 (Config to build all is ok - ready to dev)
=======
{"namespace":"Aventus","available":[{"code":"Object.defineProperty(window, \"AvInstance\", {\r\n\tget() {return Aventus.Instance;}\r\n})","dependances":[],"fullName":"!staticClass_b55fc902-f065-44d6-8e1c-851b6f827e57","required":true,"noNamespace":"before","type":0,"isExported":false},{"code":" ","dependances":[],"fullName":"!staticClass_eb295627-bb65-4a9b-a5c8-3cfe24b29317","required":true,"noNamespace":"before","type":0,"isExported":false},{"code":"class WebComponentTemplateInstance {\n    context;\n    content;\n    actions;\n    component;\n    _components;\n    firstRenderUniqueCb = {};\n    firstRenderCb = [];\n    fctsToRemove = [];\n    loopRegisteries = {};\n    firstChild;\n    lastChild;\n    loops = [];\n    constructor(context, content, actions, component, loops) {\n        this.context = context;\n        this.content = content;\n        this.actions = actions;\n        this.component = component;\n        this.loops = loops;\n        this.firstChild = content.firstChild;\n        this.lastChild = content.lastChild;\n        this.transformActionsListening();\n        this.selectElements();\n        this.bindEvents();\n    }\n    render() {\n        for (let cb of this.firstRenderCb) {\n            cb();\n        }\n        for (let key in this.firstRenderUniqueCb) {\n            this.firstRenderUniqueCb[key]();\n        }\n        this.renderSubTemplate();\n        this.context.isRendered = true;\n    }\n    destructor() {\n        this.firstChild.remove();\n        this.context.destructor();\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__watchActions'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__watchActions'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    selectElements() {\n        this._components = {};\n        let idEls = Array.from(this.content.querySelectorAll('[_id]'));\n        for (let idEl of idEls) {\n            let id = idEl.attributes['_id'].value;\n            if (!this._components[id]) {\n                this._components[id] = [];\n            }\n            this._components[id].push(idEl);\n        }\n        if (this.actions.elements) {\n            for (let element of this.actions.elements) {\n                let components = [];\n                for (let id of element.ids) {\n                    if (this._components[id]) {\n                        components = [...components, ...this._components[id]];\n                    }\n                }\n                if (element.isArray) {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components);\n                }\n                else {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components[0]);\n                }\n            }\n        }\n    }\n    bindEvents() {\n        if (this.actions.events) {\n            for (let event of this.actions.events) {\n                this.bindEvent(event);\n            }\n        }\n        if (this.actions.pressEvents) {\n            for (let event of this.actions.pressEvents) {\n                this.bindPressEvent(event);\n            }\n        }\n    }\n    bindEvent(event) {\n        if (event.isCallback) {\n            for (let el of this._components[event.id]) {\n                let cb = WebComponentTemplate.getValueFromItem(event.eventName, el);\n                cb?.add((...args) => {\n                    event.fct(this.context, args);\n                });\n            }\n        }\n        else {\n            for (let el of this._components[event.id]) {\n                el.addEventListener(event.eventName, (e) => { event.fct(e, this.context); });\n            }\n        }\n    }\n    bindPressEvent(event) {\n        let id = event['id'];\n        if (id) {\n            let clone = {};\n            for (let temp in event) {\n                if (temp != 'id') {\n                    if (event[temp] instanceof Function) {\n                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };\n                    }\n                    else {\n                        clone[temp] = event[temp];\n                    }\n                }\n            }\n            clone.element = this._components[id];\n            new PressManager(clone);\n        }\n    }\n    transformActionsListening() {\n        if (this.actions.content) {\n            for (let name in this.actions.content) {\n                for (let change of this.actions.content[name]) {\n                    this.transformChangeAction(name, change);\n                }\n            }\n        }\n        if (this.actions.injection) {\n            for (let name in this.actions.injection) {\n                for (let injection of this.actions.injection[name]) {\n                    this.transformInjectionAction(name, injection);\n                }\n            }\n        }\n        if (this.actions.bindings) {\n            for (let name in this.actions.bindings) {\n                for (let binding of this.actions.bindings[name]) {\n                    this.transformBindigAction(name, binding);\n                }\n            }\n        }\n    }\n    transformChangeAction(name, change) {\n        let key = change.id + \"_\" + change.attrName;\n        if (change.attrName == \"@HTML\") {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.innerHTML = change.render(this.context.c);\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                };\n            }\n        }\n        else if (change.isBool) {\n            this.context.addChange(name, () => {\n                for (const el of this._components[change.id]) {\n                    if (this.context.c[name]) {\n                        el.setAttribute(change.attrName, \"true\");\n                    }\n                    else {\n                        el.removeAttribute(change.attrName);\n                    }\n                }\n            });\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        if (this.context.c[name]) {\n                            el.setAttribute(change.attrName, \"true\");\n                        }\n                        else {\n                            el.removeAttribute(change.attrName);\n                        }\n                    }\n                };\n            }\n        }\n        else {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.setAttribute(change.attrName, change.render(this.context.c));\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                };\n            }\n        }\n    }\n    transformInjectionAction(name, injection) {\n        if (injection.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, injection.path)) {\n                    for (const el of this._components[injection.id]) {\n                        el[injection.injectionName] = injection.inject(this.context.c);\n                    }\n                }\n            });\n        }\n        else {\n            this.context.addChange(name, (path) => {\n                for (const el of this._components[injection.id]) {\n                    el[injection.injectionName] = injection.inject(this.context.c);\n                }\n            });\n        }\n        this.firstRenderCb.push(() => {\n            for (const el of this._components[injection.id]) {\n                el[injection.injectionName] = injection.inject(this.context.c);\n            }\n        });\n    }\n    transformBindigAction(name, binding) {\n        if (binding.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, binding.path)) {\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    for (const el of this._components[binding.id]) {\n                        WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                    }\n                }\n            });\n        }\n        else {\n            binding.path = name;\n            this.context.addChange(name, (path) => {\n                let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                for (const el of this._components[binding.id]) {\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        if (binding.isCallback) {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        let cb = WebComponentTemplate.getValueFromItem(fct, el);\n                        cb?.add((value) => {\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, value);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        else {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        el.addEventListener(fct, (e) => {\n                            let valueToSet = WebComponentTemplate.getValueFromItem(binding.valueName, e.target);\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, valueToSet);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n    }\n    renderSubTemplate() {\n        for (let loop of this.loops) {\n            let localContext = JSON.parse(JSON.stringify(this.context.schema));\n            localContext.loops.push({\n                data: loop.data,\n                index: loop.index,\n                item: loop.item\n            });\n            this.renderLoop(loop, localContext);\n            this.registerLoopWatchEvent(loop, localContext);\n        }\n    }\n    renderLoop(loop, localContext) {\n        if (this.loopRegisteries[loop.anchorId]) {\n            for (let item of this.loopRegisteries[loop.anchorId]) {\n                item.destructor();\n            }\n        }\n        this.loopRegisteries[loop.anchorId] = [];\n        let result = WebComponentTemplate.getValueFromItem(loop.data, this.context.c);\n        let anchor = this._components[loop.anchorId][0];\n        for (let i = 0; i < result.length; i++) {\n            let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: i }]);\n            let content = loop.template.template.content.cloneNode(true);\n            let actions = loop.template.actions;\n            let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n            instance.render();\n            anchor.parentNode.insertBefore(instance.content, anchor);\n            this.loopRegisteries[loop.anchorId].push(instance);\n        }\n    }\n    registerLoopWatchEvent(loop, localContext) {\n        let fullPath = loop.data;\n        let watchName = fullPath.split(\".\")[0];\n        if (!this.component['__watchActions'][watchName]) {\n            this.component['__watchActions'][watchName] = [];\n        }\n        let regex = new RegExp(fullPath.replace(/\\./g, \"\\\\.\") + \"\\\\[(\\\\d+?)\\\\]$\");\n        this.component['__watchActions'][watchName].push((element, action, path, value) => {\n            if (path == fullPath) {\n                this.renderLoop(loop, localContext);\n                return;\n            }\n            regex.lastIndex = 0;\n            let result = regex.exec(path);\n            if (result) {\n                let registry = this.loopRegisteries[loop.anchorId];\n                let index = Number(result[1]);\n                if (action == WatchAction.CREATED) {\n                    let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: index }]);\n                    let content = loop.template.template.content.cloneNode(true);\n                    let actions = loop.template.actions;\n                    let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n                    instance.render();\n                    let anchor;\n                    if (index < registry.length) {\n                        anchor = registry[index].firstChild;\n                    }\n                    else {\n                        anchor = this._components[loop.anchorId][0];\n                    }\n                    anchor.parentNode.insertBefore(instance.content, anchor);\n                    registry.splice(index, 0, instance);\n                    for (let i = index + 1; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] + 1;\n                    }\n                }\n                else if (action == WatchAction.UPDATED) {\n                    registry[index].render();\n                }\n                else if (action == WatchAction.DELETED) {\n                    registry[index].destructor();\n                    registry.splice(index, 1);\n                    for (let i = index; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] - 1;\n                    }\n                }\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.ActionEvent","isStrong":false},{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.ActionChange","isStrong":false},{"fullName":"Aventus.ActionInjection","isStrong":false},{"fullName":"Aventus.ActionBindings","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateInstance","required":false,"type":1,"isExported":true},{"code":"class WebComponentTemplate {\n    static setValueToItem(path, obj, value) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (!obj[split]) {\n                obj[split] = {};\n            }\n            obj = obj[split];\n        }\n        obj[splitted[splitted.length - 1]] = value;\n    }\n    static getValueFromItem(path, obj) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (typeof obj[split] !== 'object') {\n                return undefined;\n            }\n            obj = obj[split];\n        }\n        return obj[splitted[splitted.length - 1]];\n    }\n    static validatePath(path, pathToCheck) {\n        if (path.startsWith(pathToCheck)) {\n            return true;\n        }\n        return false;\n    }\n    htmlParts = [];\n    setHTML(data) {\n        this.htmlParts.push(data);\n    }\n    generateTemplate() {\n        this.template = document.createElement('template');\n        let currentHTML = \"<slot></slot>\";\n        let previousSlots = {\n            default: '<slot></slot>'\n        };\n        for (let htmlPart of this.htmlParts) {\n            for (let blockName in htmlPart.blocks) {\n                if (!previousSlots.hasOwnProperty(blockName)) {\n                    throw \"can't found slot with name \" + blockName;\n                }\n                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);\n            }\n            for (let slotName in htmlPart.slots) {\n                previousSlots[slotName] = htmlPart.slots[slotName];\n            }\n        }\n        this.template.innerHTML = currentHTML;\n    }\n    setTemplate(template) {\n        this.template = document.createElement('template');\n        this.template.innerHTML = template;\n    }\n    contextSchema = {\n        globals: [],\n        locals: [],\n        loops: []\n    };\n    template;\n    actions = {};\n    loops = [];\n    setActions(actions) {\n        if (!this.actions) {\n            this.actions = actions;\n        }\n        else {\n            if (actions.elements) {\n                if (!this.actions.elements) {\n                    this.actions.elements = [];\n                }\n                this.actions.elements = [...actions.elements, ...this.actions.elements];\n            }\n            if (actions.events) {\n                if (!this.actions.events) {\n                    this.actions.events = [];\n                }\n                this.actions.events = [...actions.events, ...this.actions.events];\n            }\n            if (actions.pressEvents) {\n                if (!this.actions.pressEvents) {\n                    this.actions.pressEvents = [];\n                }\n                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];\n            }\n            if (actions.content) {\n                if (!this.actions.content) {\n                    this.actions.content = actions.content;\n                }\n                else {\n                    for (let contextProp in actions.content) {\n                        if (!this.actions.content[contextProp]) {\n                            this.actions.content[contextProp] = actions.content[contextProp];\n                        }\n                        else {\n                            this.actions.content[contextProp] = { ...actions.content[contextProp], ...this.actions.content[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.injection) {\n                if (!this.actions.injection) {\n                    this.actions.injection = actions.injection;\n                }\n                else {\n                    for (let contextProp in actions.injection) {\n                        if (!this.actions.injection[contextProp]) {\n                            this.actions.injection[contextProp] = actions.injection[contextProp];\n                        }\n                        else {\n                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.bindings) {\n                if (!this.actions.bindings) {\n                    this.actions.bindings = actions.bindings;\n                }\n                else {\n                    for (let contextProp in actions.bindings) {\n                        if (!this.actions.bindings[contextProp]) {\n                            this.actions.bindings[contextProp] = actions.bindings[contextProp];\n                        }\n                        else {\n                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };\n                        }\n                    }\n                }\n            }\n        }\n    }\n    setSchema(contextSchema) {\n        if (contextSchema.globals) {\n            this.contextSchema.globals = [...this.contextSchema.globals, ...contextSchema.globals];\n        }\n        if (contextSchema.locals) {\n            this.contextSchema.locals = [...this.contextSchema.locals, ...contextSchema.locals];\n        }\n        if (contextSchema.loops) {\n            this.contextSchema.loops = [...this.contextSchema.loops, ...contextSchema.loops];\n        }\n    }\n    createInstance(component) {\n        let context = new WebComponentTemplateContext(component, this.contextSchema, []);\n        let content = this.template.content.cloneNode(true);\n        let actions = this.actions;\n        let instance = new WebComponentTemplateInstance(context, content, actions, component, this.loops);\n        return instance;\n    }\n    addLoop(loop) {\n        this.loops.push(loop);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateHTML","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false},{"fullName":"HTMLTemplateElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"WebComponentTemplateInstance","isStrong":false}],"fullName":"Aventus.WebComponentTemplate","required":false,"type":1,"isExported":true},{"code":"class WebComponentTemplateContext {\n    __changes = {};\n    component;\n    fctsToRemove = [];\n    c = {};\n    isRendered = false;\n    schema;\n    constructor(component, schema, locals) {\n        this.component = component;\n        this.schema = { ...schema };\n        this.schema.locals = [...this.schema.locals, ...locals];\n        5;\n        this.buildSchema();\n    }\n    destructor() {\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__onChangeFct'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__onChangeFct'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    buildSchema() {\n        for (let global of this.schema.globals) {\n            this.createGlobal(global);\n        }\n        for (let loop of this.schema.loops) {\n            this.createLoop(loop);\n        }\n        for (let local of this.schema.locals) {\n            this.createLocal(local);\n        }\n    }\n    createGlobal(global) {\n        let comp = this.component;\n        Object.defineProperty(this.c, global, {\n            get() {\n                return WebComponentTemplate.getValueFromItem(global, comp);\n            },\n            set(value) {\n                WebComponentTemplate.setValueToItem(global, comp, value);\n            }\n        });\n        let name = global.split(\".\")[0];\n        this.__changes[name] = [];\n        if (!this.component['__onChangeFct'][name]) {\n            this.component['__onChangeFct'][name] = [];\n        }\n        let fct = (path) => {\n            if (this.isRendered) {\n                for (let change of this.__changes[name]) {\n                    change(path);\n                }\n            }\n        };\n        this.fctsToRemove.push({ name, fct });\n        this.component['__onChangeFct'][name].push(fct);\n    }\n    createLoop(loop) {\n        Object.defineProperty(this.c, loop.item, {\n            get() {\n                let indexValue = this[loop.index];\n                return WebComponentTemplate.getValueFromItem(loop.data, this)[indexValue];\n            }\n        });\n        let name = loop.data.split(\".\")[0];\n        this.__changes[loop.item] = [];\n        this.__changes[name].push((path) => {\n            if (this.isRendered) {\n                let currentPath = `${loop.data}[${this.c[loop.index]}]`;\n                if (path.startsWith(currentPath)) {\n                    let localPath = path.replace(currentPath, loop.item);\n                    for (let change of this.__changes[loop.item]) {\n                        change(localPath);\n                    }\n                }\n            }\n        });\n    }\n    createLocal(local) {\n        let localValue = local.value;\n        let changes = this.__changes;\n        Object.defineProperty(this.c, local.name, {\n            get() {\n                return localValue;\n            },\n            set(value) {\n                localValue = value;\n                if (changes[local.name]) {\n                    for (let change of changes[local.name]) {\n                        change(local.name);\n                    }\n                }\n            }\n        });\n    }\n    addChange(on, fct) {\n        if (!this.__changes[on]) {\n            this.__changes[on] = [];\n        }\n        this.__changes[on].push(fct);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.ContextValues","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateContext","required":false,"type":1,"isExported":true},{"code":"class WebComponent extends HTMLElement {\n    /**\n     * Add attributes informations\n     */\n    static get observedAttributes() {\n        return [];\n    }\n    _first;\n    _isReady;\n    /**\n     * Determine if the component is ready (postCreation done)\n     */\n    get isReady() {\n        return this._isReady;\n    }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the name of the component class\n     */\n    getClassName() {\n        return this.constructor.name;\n    }\n    /**\n    * Get the unique type for the data. Define it as the namespace + class name\n    */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    __onChangeFct = {};\n    __watch;\n    __watchActions = {};\n    __watchActionsCb = {};\n    __pressManagers = [];\n    __isDefaultState = true;\n    __defaultActiveState = new Map();\n    __defaultInactiveState = new Map();\n    __statesList = {};\n    constructor() {\n        super();\n        if (this.constructor == WebComponent) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this._first = true;\n        this._isReady = false;\n        this.__renderTemplate();\n        this.__registerWatchesActions();\n        this.__registerPropertiesActions();\n        this.__createStates();\n        this.__subscribeState();\n    }\n    /**\n     * Remove all listeners\n     * State + press\n     */\n    destructor() {\n        WebComponentInstance.removeInstance(this);\n        this.__unsubscribeState();\n        for (let press of this.__pressManagers) {\n            press.destroy();\n        }\n        // TODO add missing info for destructor();\n    }\n    __addWatchesActions(name, fct) {\n        if (!this.__watchActions[name]) {\n            this.__watchActions[name] = [];\n            this.__watchActionsCb[name] = (action, path, value) => {\n                for (let fct of this.__watchActions[name]) {\n                    fct(this, action, path, value);\n                }\n                if (this.__onChangeFct[name]) {\n                    for (let fct of this.__onChangeFct[name]) {\n                        fct(path);\n                    }\n                }\n            };\n        }\n        if (fct) {\n            this.__watchActions[name].push(fct);\n        }\n    }\n    __registerWatchesActions() {\n        if (Object.keys(this.__watchActions).length > 0) {\n            if (!this.__watch) {\n                this.__watch = Watcher.get({}, (type, path, element) => {\n                    let action = this.__watchActionsCb[path.split(\".\")[0]] || this.__watchActionsCb[path.split(\"[\")[0]];\n                    action(type, path, element);\n                });\n            }\n        }\n    }\n    __addPropertyActions(name, fct) {\n        if (!this.__onChangeFct[name]) {\n            this.__onChangeFct[name] = [];\n        }\n        if (fct) {\n            this.__onChangeFct[name].push(() => {\n                fct(this);\n            });\n        }\n    }\n    __registerPropertiesActions() { }\n    static __style = ``;\n    static __template;\n    __templateInstance;\n    styleBefore() {\n        return [\"@general\"];\n    }\n    styleAfter() {\n        return [];\n    }\n    __getStyle() {\n        return [WebComponent.__style];\n    }\n    __getHtml() { }\n    __getStatic() {\n        return WebComponent;\n    }\n    static __styleSheets = {};\n    __renderStyles() {\n        let sheets = {};\n        let befores = this.styleBefore();\n        for (let before of befores) {\n            let sheet = Style.get(before);\n            if (sheet) {\n                sheets[before] = sheet;\n            }\n        }\n        let localStyle = new CSSStyleSheet();\n        let styleTxt = this.__getStyle().join(\"\\r\\n\");\n        if (styleTxt.length > 0) {\n            localStyle.replace(styleTxt);\n            sheets['@local'] = localStyle;\n        }\n        let afters = this.styleAfter();\n        for (let after of afters) {\n            let sheet = Style.get(after);\n            if (sheet) {\n                sheets[after] = sheet;\n            }\n        }\n        return sheets;\n    }\n    __renderTemplate() {\n        let staticInstance = this.__getStatic();\n        if (!staticInstance.__template) {\n            staticInstance.__template = new WebComponentTemplate();\n            this.__getHtml();\n            this.__registerTemplateAction();\n            staticInstance.__template.generateTemplate();\n            staticInstance.__styleSheets = this.__renderStyles();\n        }\n        this.__templateInstance = staticInstance.__template.createInstance(this);\n        let shadowRoot = this.attachShadow({ mode: 'open' });\n        shadowRoot.adoptedStyleSheets = Object.values(staticInstance.__styleSheets);\n        this.shadowRoot.appendChild(this.__templateInstance.content);\n        customElements.upgrade(this.shadowRoot);\n    }\n    __registerTemplateAction() {\n    }\n    connectedCallback() {\n        if (this._first) {\n            WebComponentInstance.addInstance(this);\n            this._first = false;\n            this.__defaultValues();\n            this.__upgradeAttributes();\n            this.__templateInstance.render();\n            setTimeout(() => {\n                this.postCreation();\n                this._isReady = true;\n                this.dispatchEvent(new CustomEvent('postCreationDone'));\n            });\n        }\n    }\n    __defaultValues() { }\n    __upgradeAttributes() { }\n    __listBoolProps() {\n        return [];\n    }\n    __upgradeProperty(prop) {\n        let boolProps = this.__listBoolProps();\n        if (boolProps.indexOf(prop) != -1) {\n            if (this.hasAttribute(prop) && (this.getAttribute(prop) === \"true\" || this.getAttribute(prop) === \"\")) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n            else {\n                this.removeAttribute(prop);\n                this[prop] = false;\n            }\n        }\n        else {\n            if (this.hasAttribute(prop)) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n        }\n    }\n    __getStateManager(managerClass) {\n        let mClass;\n        if (managerClass instanceof StateManager) {\n            mClass = managerClass;\n        }\n        else {\n            mClass = Instance.get(managerClass);\n        }\n        return mClass;\n    }\n    __addActiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultActiveState.has(mClass)) {\n            this.__defaultActiveState.set(mClass, []);\n        }\n        this.__defaultActiveState.get(mClass).push(cb);\n    }\n    __addInactiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultInactiveState.has(mClass)) {\n            this.__defaultInactiveState.set(mClass, []);\n        }\n        this.__defaultInactiveState.get(mClass).push(cb);\n    }\n    __addActiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).active.push(cb);\n    }\n    __addInactiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).inactive.push(cb);\n    }\n    __addAskChangeState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).askChange.push(cb);\n    }\n    __createStates() { }\n    __createStatesList(statePattern, managerClass) {\n        if (!this.__statesList[statePattern]) {\n            this.__statesList[statePattern] = new Map();\n        }\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__statesList[statePattern].has(mClass)) {\n            this.__statesList[statePattern].set(mClass, {\n                active: [],\n                inactive: [],\n                askChange: []\n            });\n        }\n    }\n    __inactiveDefaultState(managerClass) {\n        if (this.__isDefaultState) {\n            this.__isDefaultState = false;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultInactiveState.has(mClass)) {\n                let fcts = this.__defaultInactiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __activeDefaultState(nextStep, managerClass) {\n        if (!this.__isDefaultState) {\n            for (let pattern in this.__statesList) {\n                if (StateManager.canBeActivate(pattern, nextStep)) {\n                    let mClass = this.__getStateManager(managerClass);\n                    if (this.__statesList[pattern].has(mClass)) {\n                        return;\n                    }\n                }\n            }\n            this.__isDefaultState = true;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultActiveState.has(mClass)) {\n                let fcts = this.__defaultActiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __subscribeState() {\n        if (!this.isReady && this.__stateCleared) {\n            return;\n        }\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.subscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n    }\n    __stateCleared;\n    __unsubscribeState() {\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.unsubscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n        this.__stateCleared = true;\n    }\n    dateToString(d) {\n        if (d instanceof Date) {\n            return new Date(d.getTime() - (d.getTimezoneOffset() * 60000)).toISOString().split(\"T\")[0];\n        }\n        return null;\n    }\n    dateTimeToString(dt) {\n        if (dt instanceof Date) {\n            return new Date(dt.getTime() - (dt.getTimezoneOffset() * 60000)).toISOString().slice(0, -1);\n        }\n        return null;\n    }\n    stringToDate(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    stringToDateTime(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    getBoolean(val) {\n        if (val === true || val === 1 || val === 'true' || val === '') {\n            return true;\n        }\n        else if (val === false || val === 0 || val === 'false' || val === null || val === undefined) {\n            return false;\n        }\n        console.error(\"error parsing boolean value \" + val);\n        return false;\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue !== newValue || !this.isReady) {\n            if (this.__onChangeFct.hasOwnProperty(name)) {\n                for (let fct of this.__onChangeFct[name]) {\n                    fct('');\n                }\n            }\n        }\n    }\n    remove() {\n        super.remove();\n        this.postDestruction();\n    }\n    /**\n     * Function triggered when the component is removed from the DOM\n     */\n    postDestruction() { }\n    /**\n     * Function triggered the first time the component is rendering inside DOM\n     */\n    postCreation() { }\n    /**\n     * Find a parent by tagname if exist\n     */\n    findParentByTag(tagname, untilNode) {\n        return ElementExtension.findParentByTag(this, tagname, untilNode);\n    }\n    /**\n     * Find a parent by class name if exist\n     */\n    findParentByClass(classname, untilNode) {\n        return ElementExtension.findParentByClass(this, classname, untilNode);\n    }\n    /**\n     * Find a parent by type if exist\n     */\n    findParentByType(type, untilNode) {\n        return ElementExtension.findParentByType(this, type, untilNode);\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    findParents(tagname, untilNode) {\n        return ElementExtension.findParents(this, tagname, untilNode);\n    }\n    /**\n     * Check if element contains a child\n     */\n    containsChild(el) {\n        return ElementExtension.containsChild(this, el);\n    }\n    /**\n     * Get element inside slot\n     */\n    getElementsInSlot(slotName = null) {\n        return ElementExtension.getElementsInSlot(this, slotName);\n    }\n}\n","dependances":[{"fullName":"HTMLElement","isStrong":true},{"fullName":"Aventus.DefaultComponent","isStrong":true},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.WebComponentTemplate","isStrong":false},{"fullName":"Aventus.WebComponentTemplateInstance","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false},{"fullName":"Aventus.Style","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"Date","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.ElementExtension","isStrong":false},{"fullName":"Aventus.WebComponentInstance","isStrong":true}],"fullName":"Aventus.WebComponent","required":false,"type":1,"isExported":true},{"code":"class WebComponentInstance {\n    static __allDefinitions = [];\n    static __allInstances = [];\n    /**\n     * Last definition insert datetime\n     */\n    static lastDefinition = 0;\n    static registerDefinition(def) {\n        WebComponentInstance.lastDefinition = Date.now();\n        WebComponentInstance.__allDefinitions.push(def);\n    }\n    /**\n     * Get all sub classes of type\n     */\n    static getAllClassesOf(type) {\n        let result = [];\n        for (let def of WebComponentInstance.__allDefinitions) {\n            if (def.prototype instanceof type) {\n                result.push(def);\n            }\n        }\n        return result;\n    }\n    /**\n     * Get all registered definitions\n     */\n    static getAllDefinitions() {\n        return WebComponentInstance.__allDefinitions;\n    }\n    static addInstance(instance) {\n        this.__allInstances.push(instance);\n    }\n    static removeInstance(instance) {\n        let index = this.__allInstances.indexOf(instance);\n        if (index > -1) {\n            this.__allInstances.splice(index, 1);\n        }\n    }\n    static getAllInstances(type) {\n        let result = [];\n        for (let instance of this.__allInstances) {\n            if (instance instanceof type) {\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"WebComponent","isStrong":false}],"fullName":"Aventus.WebComponentInstance","required":false,"type":1,"isExported":true},{"code":"class Style {\n    static instance;\n    static defaultStyleSheets = {\n        \"@general\": `:host{display:inline-block;box-sizing:border-box}:host *{box-sizing:border-box}`\n    };\n    static store(name, content) {\n        this.getInstance().store(name, content);\n    }\n    static get(name) {\n        return this.getInstance().get(name);\n    }\n    static load(name, url) {\n        return this.getInstance().load(name, url);\n    }\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new Style();\n        }\n        return this.instance;\n    }\n    constructor() {\n        for (let name in Style.defaultStyleSheets) {\n            this.store(name, Style.defaultStyleSheets[name]);\n        }\n    }\n    stylesheets = new Map();\n    async load(name, url) {\n        try {\n            if (!this.stylesheets.has(name) || this.stylesheets.get(name).cssRules.length == 0) {\n                let txt = await (await fetch(url)).text();\n                this.store(name, txt);\n            }\n        }\n        catch (e) {\n        }\n    }\n    store(name, content) {\n        if (!this.stylesheets.has(name)) {\n            const sheet = new CSSStyleSheet();\n            sheet.replaceSync(content);\n            this.stylesheets.set(name, sheet);\n        }\n        else {\n            this.stylesheets.get(name).replaceSync(content);\n        }\n    }\n    get(name) {\n        if (!this.stylesheets.has(name)) {\n            this.store(name, \"\");\n        }\n        return this.stylesheets.get(name);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false}],"fullName":"Aventus.Style","required":false,"type":1,"isExported":true},{"code":"class ElementExtension {\n    /**\n     * Find a parent by tagname if exist Static.findParentByTag(this, \"av-img\")\n     */\n    static findParentByTag(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let checkFunc = (el) => {\n            return tagname.indexOf((el.nodeName || el.tagName).toLowerCase()) != -1;\n        };\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by class name if exist Static.findParentByClass(this, \"my-class-img\") = querySelector('.my-class-img')\n     */\n    static findParentByClass(element, classname, untilNode) {\n        let el = element;\n        if (!Array.isArray(classname)) {\n            classname = [classname];\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            for (let classnameTemp of classname) {\n                if (el['classList'] && el['classList'].contains(classnameTemp)) {\n                    return el;\n                }\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by type if exist Static.findParentyType(this, Aventus.Img)\n     */\n    static findParentByType(element, type, untilNode) {\n        let el = element;\n        let checkFunc = (el) => {\n            return false;\n        };\n        if (typeof type == \"function\" && type['prototype']['constructor']) {\n            checkFunc = (el) => {\n                if (el instanceof type) {\n                    return true;\n                }\n                return false;\n            };\n        }\n        else {\n            console.error(\"you must provide a class inside this function\");\n            return null;\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    static findParents(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let result = [];\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (tagname.indexOf((el.nodeName || el['tagName']).toLowerCase()) != -1) {\n                result.push(el);\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Check if element contains a child\n     */\n    static containsChild(element, child) {\n        var rootScope = element.getRootNode();\n        var elScope = child.getRootNode();\n        while (elScope != rootScope) {\n            if (!elScope['host']) {\n                return false;\n            }\n            child = elScope['host'];\n            elScope = elScope['host'].getRootNode();\n        }\n        return element.contains(child);\n    }\n    /**\n     * Get element inside slot\n     */\n    static getElementsInSlot(element, slotName = null) {\n        if (element.shadowRoot) {\n            let slotEl;\n            if (slotName) {\n                slotEl = element.shadowRoot.querySelector('slot[name=\"' + slotName + '\"]');\n            }\n            else {\n                slotEl = element.shadowRoot.querySelector(\"slot\");\n            }\n            while (true) {\n                if (!slotEl) {\n                    return [];\n                }\n                var listChild = Array.from(slotEl.assignedElements());\n                if (!listChild) {\n                    return [];\n                }\n                let slotFound = false;\n                for (let i = 0; i < listChild.length; i++) {\n                    if (listChild[i].nodeName == \"SLOT\") {\n                        slotEl = listChild[i];\n                        slotFound = true;\n                        break;\n                    }\n                }\n                if (!slotFound) {\n                    return listChild;\n                }\n            }\n        }\n        return [];\n    }\n    /**\n     * Get deeper element inside dom at the position X and Y\n     */\n    static getElementAtPosition(x, y, startFrom = null) {\n        var _realTarget = (el, i = 0) => {\n            if (i == 50) {\n                debugger;\n            }\n            if (el.shadowRoot && x !== undefined && y !== undefined) {\n                var newEl = el.shadowRoot.elementFromPoint(x, y);\n                if (newEl && newEl != el) {\n                    return _realTarget(newEl, i + 1);\n                }\n            }\n            return el;\n        };\n        if (startFrom == null) {\n            startFrom = document.body;\n        }\n        return _realTarget(startFrom);\n    }\n}\n","dependances":[{"fullName":"Element","isStrong":false},{"fullName":"ShadowRoot","isStrong":false},{"fullName":"HTMLSlotElement","isStrong":false},{"fullName":"HTMLElement","isStrong":false}],"fullName":"Aventus.ElementExtension","required":false,"type":1,"isExported":true},{"code":"function uuidv4() {\n    let uid = '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));\n    return uid;\n}\n","dependances":[],"fullName":"Aventus.uuidv4","required":false,"type":4,"isExported":true},{"code":"function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","dependances":[],"fullName":"Aventus.sleep","required":false,"type":4,"isExported":true},{"code":"class Mutex {\n    waitingList = [];\n    isLocked = false;\n    /**\n     * Wait the mutex to be free then get it\n     */\n    waitOne() {\n        return new Promise((resolve) => {\n            if (this.isLocked) {\n                this.waitingList.push(() => {\n                    resolve();\n                });\n            }\n            else {\n                this.isLocked = true;\n                resolve();\n            }\n        });\n    }\n    /**\n     * Release the mutex\n     */\n    release() {\n        let nextFct = this.waitingList.shift();\n        if (nextFct) {\n            nextFct();\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Clear mutex\n     */\n    dispose() {\n        this.waitingList = [];\n        this.isLocked = false;\n    }\n}\n","dependances":[],"fullName":"Aventus.Mutex","required":false,"type":1,"isExported":true},{"code":"function compareObject(obj1, obj2) {\n    if (Array.isArray(obj1)) {\n        if (!obj2) {\n            obj2 = [];\n        }\n        else {\n            obj2 = obj2.slice();\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            let foundElement = false;\n            for (let j = 0; j < obj2.length; j++) {\n                if (compareObject(obj1[i], obj2[j])) {\n                    obj2.splice(j, 1);\n                    foundElement = true;\n                    break;\n                }\n            }\n            if (!foundElement) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (obj1 instanceof Date) {\n        return obj1.toString() === obj2.toString();\n    }\n    else if (typeof obj1 == 'object') {\n        if (!obj2) {\n            obj2 = {};\n        }\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (let key in obj1) {\n            if (!(key in obj2)) {\n                return false;\n            }\n            if (!compareObject(obj1[key], obj2[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return obj1 == obj2;\n    }\n}\n","dependances":[],"fullName":"Aventus.compareObject","required":false,"type":4,"isExported":true},{"code":"class StateManager {\n    subscribers = {};\n    static canBeActivate(statePattern, stateName) {\n        let stateInfo = this.prepareStateString(statePattern);\n        return stateInfo.regex.test(stateName);\n    }\n    activeState;\n    afterStateChanged = new Callback();\n    /**\n     * Subscribe actions for a state or a state list\n     */\n    subscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to subscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (!this.subscribers.hasOwnProperty(statePattern)) {\n                let res = StateManager.prepareStateString(statePattern);\n                let isActive = this.activeState !== undefined && res.regex.test(this.activeState.name);\n                this.subscribers[statePattern] = {\n                    \"regex\": res.regex,\n                    \"params\": res.params,\n                    \"callbacks\": {\n                        \"active\": [],\n                        \"inactive\": [],\n                        \"askChange\": [],\n                    },\n                    \"isActive\": isActive,\n                };\n            }\n            if (callbacks.active) {\n                if (!Array.isArray(callbacks.active)) {\n                    callbacks.active = [callbacks.active];\n                }\n                for (let activeFct of callbacks.active) {\n                    this.subscribers[statePattern].callbacks.active.push(activeFct);\n                    if (this.subscribers[statePattern].isActive) {\n                        let slugs = this.getInternalStateSlugs(this.subscribers[statePattern], this.activeState.name);\n                        activeFct(this.activeState, slugs);\n                    }\n                }\n            }\n            if (callbacks.inactive) {\n                if (!Array.isArray(callbacks.inactive)) {\n                    callbacks.inactive = [callbacks.inactive];\n                }\n                for (let inactiveFct of callbacks.inactive) {\n                    this.subscribers[statePattern].callbacks.inactive.push(inactiveFct);\n                }\n            }\n            if (callbacks.askChange) {\n                if (!Array.isArray(callbacks.askChange)) {\n                    callbacks.askChange = [callbacks.askChange];\n                }\n                for (let askChangeFct of callbacks.askChange) {\n                    this.subscribers[statePattern].callbacks.askChange.push(askChangeFct);\n                }\n            }\n        }\n    }\n    /**\n     * Unsubscribe actions for a state or a state list\n     */\n    unsubscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to unsubscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (this.subscribers[statePattern]) {\n                if (callbacks.active) {\n                    if (!Array.isArray(callbacks.active)) {\n                        callbacks.active = [callbacks.active];\n                    }\n                    for (let activeFct of callbacks.active) {\n                        let index = this.subscribers[statePattern].callbacks.active.indexOf(activeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.active.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.inactive) {\n                    if (!Array.isArray(callbacks.inactive)) {\n                        callbacks.inactive = [callbacks.inactive];\n                    }\n                    for (let inactiveFct of callbacks.inactive) {\n                        let index = this.subscribers[statePattern].callbacks.inactive.indexOf(inactiveFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.inactive.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.askChange) {\n                    if (!Array.isArray(callbacks.askChange)) {\n                        callbacks.askChange = [callbacks.askChange];\n                    }\n                    for (let askChangeFct of callbacks.askChange) {\n                        let index = this.subscribers[statePattern].callbacks.askChange.indexOf(askChangeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.askChange.splice(index, 1);\n                        }\n                    }\n                }\n                if (this.subscribers[statePattern].callbacks.active.length === 0 &&\n                    this.subscribers[statePattern].callbacks.inactive.length === 0 &&\n                    this.subscribers[statePattern].callbacks.askChange.length === 0) {\n                    delete this.subscribers[statePattern];\n                }\n            }\n        }\n    }\n    onAfterStateChanged(cb) {\n        this.afterStateChanged.add(cb);\n    }\n    offAfterStateChanged(cb) {\n        this.afterStateChanged.remove(cb);\n    }\n    static prepareStateString(stateName) {\n        let params = [];\n        let i = 0;\n        let regexState = stateName.replace(/{.*?}/g, (group, position) => {\n            group = group.slice(1, -1);\n            let splitted = group.split(\":\");\n            let name = splitted[0].trim();\n            let type = \"string\";\n            let result = \"([^\\\\/]+)\";\n            i++;\n            if (splitted.length > 1) {\n                if (splitted[1].trim() == \"number\") {\n                    result = \"([0-9]+)\";\n                    type = \"number\";\n                }\n            }\n            params.push({\n                name,\n                type,\n                position: i\n            });\n            return result;\n        });\n        regexState = regexState.replace(/\\*/g, \".*?\");\n        regexState = \"^\" + regexState + '$';\n        return {\n            regex: new RegExp(regexState),\n            params\n        };\n    }\n    /**\n     * Activate a current state\n     */\n    async setState(state) {\n        let stateToUse;\n        if (typeof state == \"string\") {\n            stateToUse = new EmptyState(state);\n        }\n        else {\n            stateToUse = state;\n        }\n        if (!stateToUse) {\n            this._log(\"state is undefined\", \"error\");\n            return false;\n        }\n        let canChange = true;\n        if (this.activeState) {\n            let activeToInactive = [];\n            let inactiveToActive = [];\n            let triggerActive = [];\n            canChange = await this.activeState.askChange(this.activeState, stateToUse);\n            if (canChange) {\n                for (let statePattern in this.subscribers) {\n                    let subscriber = this.subscribers[statePattern];\n                    if (subscriber.isActive) {\n                        let clone = [...subscriber.callbacks.askChange];\n                        let currentSlug = this.getInternalStateSlugs(subscriber, this.activeState.name);\n                        for (let i = 0; i < clone.length; i++) {\n                            let askChange = clone[i];\n                            if (!await askChange(this.activeState, stateToUse, currentSlug)) {\n                                canChange = false;\n                                break;\n                            }\n                        }\n                        let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                        if (slugs === null) {\n                            activeToInactive.push(subscriber);\n                        }\n                        else {\n                            triggerActive.push({\n                                subscriber: subscriber,\n                                params: slugs\n                            });\n                        }\n                    }\n                    else {\n                        let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                        if (slugs) {\n                            inactiveToActive.push({\n                                subscriber,\n                                params: slugs\n                            });\n                        }\n                    }\n                    if (!canChange) {\n                        break;\n                    }\n                }\n            }\n            if (canChange) {\n                const oldState = this.activeState;\n                this.activeState = stateToUse;\n                oldState.onInactivate(stateToUse);\n                for (let subscriber of activeToInactive) {\n                    subscriber.isActive = false;\n                    let oldSlug = this.getInternalStateSlugs(subscriber, oldState.name);\n                    [...subscriber.callbacks.inactive].forEach(callback => {\n                        callback(oldState, stateToUse, oldSlug);\n                    });\n                }\n                for (let trigger of triggerActive) {\n                    [...trigger.subscriber.callbacks.active].forEach(callback => {\n                        callback(stateToUse, trigger.params);\n                    });\n                }\n                for (let trigger of inactiveToActive) {\n                    trigger.subscriber.isActive = true;\n                    [...trigger.subscriber.callbacks.active].forEach(callback => {\n                        callback(stateToUse, trigger.params);\n                    });\n                }\n                stateToUse.onActivate();\n            }\n        }\n        else {\n            this.activeState = stateToUse;\n            for (let key in this.subscribers) {\n                let slugs = this.getInternalStateSlugs(this.subscribers[key], stateToUse.name);\n                if (slugs) {\n                    this.subscribers[key].isActive = true;\n                    [...this.subscribers[key].callbacks.active].forEach(callback => {\n                        callback(stateToUse, slugs);\n                    });\n                }\n            }\n            stateToUse.onActivate();\n        }\n        this.afterStateChanged.trigger([]);\n        return true;\n    }\n    getState() {\n        return this.activeState;\n    }\n    getInternalStateSlugs(subscriber, stateName) {\n        let matches = subscriber.regex.exec(stateName);\n        if (matches) {\n            let slugs = {};\n            for (let param of subscriber.params) {\n                if (param.type == \"number\") {\n                    slugs[param.name] = Number(matches[param.position]);\n                }\n                else {\n                    slugs[param.name] = matches[param.position];\n                }\n            }\n            return slugs;\n        }\n        return null;\n    }\n    /**\n     * Check if a state is in the subscribers and active, return true if it is, false otherwise\n     */\n    isStateActive(statePattern) {\n        return StateManager.prepareStateString(statePattern).regex.test(this.activeState.name);\n    }\n    /**\n     * Get slugs information for the current state, return null if state isn't active\n     */\n    getStateSlugs(statePattern) {\n        let prepared = StateManager.prepareStateString(statePattern);\n        return this.getInternalStateSlugs({\n            regex: prepared.regex,\n            params: prepared.params,\n            isActive: false,\n            callbacks: {\n                active: [],\n                inactive: [],\n                askChange: [],\n            }\n        }, this.activeState.name);\n    }\n    // 0 = error only / 1 = errors and warning / 2 = error, warning and logs (not implemented)\n    logLevel() {\n        return 0;\n    }\n    _log(msg, type) {\n        if (type === \"error\") {\n            console.error(msg);\n        }\n        else if (type === \"warning\" && this.logLevel() > 0) {\n            console.warn(msg);\n        }\n        else if (type === \"info\" && this.logLevel() > 1) {\n            console.log(msg);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Aventus.StateAction","isStrong":false},{"fullName":"Aventus.EmptyState","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false}],"fullName":"Aventus.StateManager","required":false,"type":1,"isExported":true},{"code":"class State {\n    /**\n     * Activate a custom state inside a specific manager\n     * It ll be a generic state with no information inside exept name\n     */\n    static async activate(stateName, manager) {\n        return await new EmptyState(stateName).activate(manager);\n    }\n    /**\n     * Activate this state inside a specific manager\n     */\n    async activate(manager) {\n        return await manager.setState(this);\n    }\n    onActivate() {\n    }\n    onInactivate(nextState) {\n    }\n    async askChange(state, nextState) {\n        return true;\n    }\n}\n","dependances":[{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"EmptyState","isStrong":false}],"fullName":"Aventus.State","required":false,"type":1,"isExported":true},{"code":"class EmptyState extends State {\n    localName;\n    constructor(stateName) {\n        super();\n        this.localName = stateName;\n    }\n    /**\n     * @inheritdoc\n     */\n    get name() {\n        return this.localName;\n    }\n}\n","dependances":[{"fullName":"Aventus.State","isStrong":true}],"fullName":"Aventus.EmptyState","required":false,"type":1,"isExported":true},{"code":"class GenericRam {\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    subscribers = {\n        created: [],\n        updated: [],\n        deleted: [],\n    };\n    recordsSubscribers = new Map();\n    /**\n     * List of stored item by index key\n     */\n    records = new Map();\n    constructor() {\n        if (this.constructor == GenericRam) {\n            throw \"can't instanciate an abstract class\";\n        }\n    }\n    /**\n     * Get item id\n     */\n    getIdWithError(item) {\n        let action = new ResultRamWithError();\n        let idTemp = item[this.defineIndexKey()];\n        if (idTemp !== undefined) {\n            action.result = idTemp;\n        }\n        else {\n            action.errors.push(new RamError(RamErrorCode.noId, \"no key found for item\"));\n        }\n        return action;\n    }\n    /**\n     * Get item id\n     */\n    getId(item) {\n        let result = this.getIdWithError(item);\n        if (result.success) {\n            return result.result;\n        }\n        return null;\n    }\n    /**\n     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete\n     */\n    addRamAction(Base) {\n        let that = this;\n        return class ActionClass extends Base {\n            async update(newData = {}) {\n                let id = that.getId(this);\n                let oldData = that.records.get(id);\n                if (oldData) {\n                    that.mergeObject(oldData, newData);\n                    let result = await that.update(oldData);\n                    return result;\n                }\n                return undefined;\n            }\n            onUpdate(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).updated.includes(callback)) {\n                    that.recordsSubscribers.get(id).updated.push(callback);\n                }\n            }\n            offUpdate(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).updated.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).updated.splice(index, 1);\n                    }\n                }\n            }\n            async delete() {\n                let id = that.getId(this);\n                await that.deleteById(id);\n            }\n            onDelete(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).deleted.includes(callback)) {\n                    that.recordsSubscribers.get(id).deleted.push(callback);\n                }\n            }\n            offDelete(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).deleted.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).deleted.splice(index, 1);\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Transform the object into the object stored inside Ram\n     */\n    getObjectForRam(objJson) {\n        let T = this.addRamAction(this.getTypeForData(objJson));\n        let item = new T();\n        this.mergeObject(item, objJson);\n        return item;\n    }\n    /**\n     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced\n     */\n    addOrUpdateData(item, result) {\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    this.mergeObject(this.records.get(id), item);\n                }\n                else {\n                    let realObject = this.getObjectForRam(item);\n                    this.records.set(id, realObject);\n                }\n                result.result = this.records.get(id);\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n            }\n        }\n        catch (e) {\n            result.errors.push(new RamError(RamErrorCode.unknow, e));\n        }\n    }\n    /**\n     * Merge object and create real instance of class\n     */\n    mergeObject(item, objJson) {\n        let realObject = DataManager.createObject(objJson);\n        let props = Object.getOwnPropertyNames(item);\n        for (let prop of props) {\n            if (realObject[prop] !== undefined) {\n                let propInfo = Object.getOwnPropertyDescriptor(item, prop);\n                if (propInfo.writable) {\n                    item[prop] = realObject[prop];\n                }\n            }\n        }\n    }\n    publish(type, data) {\n        [...this.subscribers[type]].forEach(callback => callback(data));\n        if (this.recordsSubscribers.has(this.getId(data))) {\n            [...this.recordsSubscribers.get(this.getId(data))[type]].forEach(callback => callback(data));\n        }\n    }\n    subscribe(type, cb) {\n        if (!this.subscribers[type].includes(cb)) {\n            this.subscribers[type].push(cb);\n        }\n    }\n    unsubscribe(type, cb) {\n        let index = this.subscribers[type].indexOf(cb);\n        if (index != -1) {\n            this.subscribers[type].splice(index, 1);\n        }\n    }\n    /**\n    * Add a callback that ll be triggered when a new item is stored\n    */\n    onCreated(cb) {\n        this.subscribe('created', cb);\n    }\n    /**\n     * Remove a created callback\n     */\n    offCreated(cb) {\n        this.unsubscribe('created', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is updated\n     */\n    onUpdated(cb) {\n        this.subscribe('updated', cb);\n    }\n    /**\n     * Remove an updated callback\n     */\n    offUpdated(cb) {\n        this.unsubscribe('updated', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is deleted\n     */\n    onDeleted(cb) {\n        this.subscribe('deleted', cb);\n    }\n    /**\n     * Remove an deleted callback\n     */\n    offDeleted(cb) {\n        this.unsubscribe('deleted', cb);\n    }\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async get(id) {\n        return await this.getById(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async getWithError(id) {\n        return await this.getByIdWithError(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist\n     */\n    async getById(id) {\n        let action = await this.getByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Get an item by id if exist\n     */\n    async getByIdWithError(id) {\n        let action = new ResultRamWithError();\n        await this.beforeGetById(id, action);\n        if (action.success) {\n            if (this.records.has(id)) {\n                action.result = this.records.get(id);\n                await this.afterGetById(action);\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before getting an item by id\n     */\n    async beforeGetById(id, result) { }\n    ;\n    /**\n     * Trigger after getting an item by id\n     */\n    async afterGetById(result) { }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIds(ids) {\n        let result = await this.getByIdsWithError(ids);\n        if (result.success) {\n            return result.result;\n        }\n        return [];\n    }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIdsWithError(ids) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeGetByIds(ids, action);\n        if (action.success) {\n            for (let id of ids) {\n                if (this.records.has(id)) {\n                    action.result.push(this.records.get(id));\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                }\n            }\n            if (action.success) {\n                await this.afterGetByIds(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting a list of items by id\n     */\n    async beforeGetByIds(ids, result) { }\n    ;\n    /**\n     * Trigger after getting a list of items by id\n     */\n    async afterGetByIds(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAll() {\n        let result = await this.getAllWithError();\n        if (result.success) {\n            return result.result;\n        }\n        return new Map();\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAllWithError() {\n        let action = new ResultRamWithError();\n        action.result = new Map();\n        await this.beforeGetAll(action);\n        if (action.success) {\n            action.result = this.records;\n            await this.afterGetAll(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting all items inside Ram\n     */\n    async beforeGetAll(result) { }\n    ;\n    /**\n     * Trigger after getting all items inside Ram\n     */\n    async afterGetAll(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getList() {\n        let data = await this.getAll();\n        return Array.from(data.values());\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getListWithError() {\n        let action = new ResultRamWithError();\n        action.result = [];\n        let result = await this.getAllWithError();\n        if (result.success) {\n            action.result = Object.values(result.result);\n        }\n        else {\n            action.errors = result.errors;\n        }\n        return action;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createList(list) {\n        let result = await this.createListWithError(list);\n        return result.result;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeCreateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._create(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterCreateList(action);\n            }\n        }\n        return action;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async create(item, ...args) {\n        let action = await this.createWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async createWithError(item, ...args) {\n        return await this._create(item, false);\n    }\n    async _create(item, fromList) {\n        let action = new ResultRamWithError();\n        await this.beforeCreateItem(item, fromList, action);\n        if (action.success) {\n            if (action.result) {\n                item = action.result;\n            }\n            let resultTemp = this.getIdWithError(item);\n            if (resultTemp.success) {\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterCreateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('created', action.result);\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before creating a list of items\n     */\n    async beforeCreateList(list, result) {\n    }\n    ;\n    /**\n     * Trigger before creating an item\n     */\n    async beforeCreateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after creating an item\n     */\n    async afterCreateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after creating a list of items\n     */\n    async afterCreateList(result) {\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateList(list) {\n        let result = await this.updateListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeUpdateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._update(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterUpdateList(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Update an item inside ram\n     */\n    async update(item, ...args) {\n        let action = await this.updateWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Update an item inside ram\n     */\n    async updateWithError(item, ...args) {\n        return await this._update(item, false);\n    }\n    async _update(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                await this.beforeUpdateItem(item, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                if (action.result) {\n                    item = action.result;\n                }\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterUpdateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('updated', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before updating a list of items\n     */\n    async beforeUpdateList(list, result) {\n    }\n    ;\n    /**\n    * Trigger before updating an item\n    */\n    async beforeUpdateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after updating an item\n     */\n    async afterUpdateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after updating a list of items\n     */\n    async afterUpdateList(result) {\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteList(list) {\n        let result = await this.deleteListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeDeleteList(list, action);\n        for (let item of list) {\n            let resultItem = await this._delete(item, true);\n            if (resultItem.success) {\n                action.result.push(resultItem.result);\n            }\n            else {\n                action.errors = [...action.errors, ...resultItem.errors];\n            }\n        }\n        if (action.success) {\n            await this.afterDeleteList(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Delete an item inside ram\n     */\n    async delete(item, ...args) {\n        let action = await this.deleteWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    ;\n    /**\n    * Delete an item inside ram\n    */\n    async deleteWithError(item, ...args) {\n        return await this._delete(item, false);\n    }\n    ;\n    /**\n     * Delete an item by id inside ram\n     */\n    async deleteById(id) {\n        let action = await this.deleteByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n    * Delete an item by id inside ram\n    */\n    async deleteByIdWithError(id) {\n        if (this.records.has(id)) {\n            let item = this.records.get(id);\n            return await this._delete(item, false);\n        }\n        let result = new ResultRamWithError();\n        result.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + id + \" because it wasn't found inside ram\"));\n        return result;\n    }\n    async _delete(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                let oldItem = this.records.get(key);\n                await this.beforeDeleteItem(oldItem, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                this.records.delete(key);\n                action.result = oldItem;\n                await this.afterDeleteItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('deleted', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    /**\n     * Trigger before deleting a list of items\n     */\n    async beforeDeleteList(list, result) { }\n    ;\n    /**\n     * Trigger before deleting an item\n     */\n    async beforeDeleteItem(item, fromList, result) { }\n    ;\n    /**\n     * Trigger after deleting an item\n     */\n    async afterDeleteItem(result, fromList) { }\n    ;\n    /**\n     * Trigger after deleting a list of items\n     */\n    async afterDeleteList(result) { }\n}\n","dependances":[{"fullName":"Aventus.IRam","isStrong":true},{"fullName":"Aventus.RamSubscribers","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Base","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.DataManager","isStrong":false}],"fullName":"Aventus.GenericRam","required":false,"type":1,"isExported":true},{"code":"class Ram extends GenericRam {\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true}],"fullName":"Aventus.Ram","required":false,"type":1,"isExported":true},{"code":"class GenericRamWs extends GenericRam {\n    wsRoutes;\n    ws;\n    getAllDone = false;\n    constructor() {\n        super();\n        if (this.constructor == GenericRamWs) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.init();\n    }\n    init() {\n        this.ws = this.getWebSocket();\n        this.createRoutes();\n        this.addSocketCallback();\n    }\n    createRoutes() {\n        const socketActions = {\n            get: \"get\",\n            getAll: \"get/all\",\n            create: \"create\",\n            created: \"created\",\n            update: \"update\",\n            updated: \"updated\",\n            delete: \"delete\",\n            deleted: \"deleted\"\n        };\n        let temp = {};\n        let wsRouteBase = this.getWebSocketRoute();\n        if (wsRouteBase.endsWith(\"/\")) {\n            wsRouteBase = wsRouteBase.slice(0, -1);\n        }\n        for (const [key, name] of Object.entries(socketActions)) {\n            temp[key] = {\n                request: `${wsRouteBase}/${name}`,\n                multiple: `${wsRouteBase}/${name}/multiple`,\n                success: `${wsRouteBase}/${name}/success`,\n                error: `${wsRouteBase}/${name}/error`,\n            };\n        }\n        this.wsRoutes = temp;\n    }\n    addSocketCallback() {\n        let createdRoute = {\n            channel: this.wsRoutes.created.request,\n            callback: response => {\n                if (response.data) {\n                    for (let obj of response.data) {\n                        let id = this.getId(obj);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            this.addOrUpdateData(obj, result);\n                            if (result.success) {\n                                this.publish('created', this.records.get(id));\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(createdRoute);\n        let updatedRoute = {\n            channel: this.wsRoutes.updated.request,\n            callback: response => {\n                if (response.data) {\n                    for (let newData of response.data) {\n                        let id = this.getId(newData);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            if (this.records.has(id)) {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('updated', this.records.get(id));\n                                }\n                            }\n                            else {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('created', this.records.get(id));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(updatedRoute);\n        let deletedRoute = {\n            channel: this.wsRoutes.deleted.request,\n            callback: response => {\n                if (response.data) {\n                    for (let data of response.data) {\n                        let id = this.getId(data);\n                        if (this.records.has(id)) {\n                            let oldData = this.records.get(id);\n                            this.records.delete(id);\n                            this.publish('deleted', oldData);\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(deletedRoute);\n    }\n    /**\n     * Send a msg through the websocket\n     */\n    sendMsg(route, params, callbacks) {\n        this.ws.sendMessageAndWait(route, params, callbacks);\n    }\n    uniqueMsgWaiting = {};\n    /**\n     * Send a unique msg through the websocket and wait answer\n     */\n    sendUniqueMsg(route, params, callbacks) {\n        let uniqueKey = route + JSON.stringify(params);\n        if (this.uniqueMsgWaiting[uniqueKey]) {\n            for (let name in callbacks) {\n                if (this.uniqueMsgWaiting[uniqueKey][name]) {\n                    this.uniqueMsgWaiting[uniqueKey][name].push(callbacks[name]);\n                }\n                else {\n                    this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n                }\n            }\n        }\n        else {\n            let callbacksToAdd = {};\n            const createCallback = (name) => {\n                callbacksToAdd[name] = (data) => {\n                    for (let fct of this.uniqueMsgWaiting[uniqueKey][name]) {\n                        fct(data);\n                    }\n                    delete this.uniqueMsgWaiting[uniqueKey];\n                };\n            };\n            this.uniqueMsgWaiting[uniqueKey] = {};\n            for (let name in callbacks) {\n                createCallback(name);\n                this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n            }\n            this.ws.sendMessageAndWait(route, params, callbacksToAdd);\n        }\n    }\n    addRoute(newRoute) {\n        this.ws.addRoute(newRoute);\n    }\n    beforeGetById(id, result) {\n        return new Promise((resolve, reject) => {\n            if (this.records.has(id)) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.get.request, {\n                    [this.defineIndexKey()]: id\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            let resultTemp = new ResultRamWithError();\n                            this.addOrUpdateData(response.data, resultTemp);\n                            if (!resultTemp.success) {\n                                result.errors = [...result.errors, ...resultTemp.errors];\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeGetByIds(ids, result) {\n        return new Promise((resolve, reject) => {\n            let missingIds = [];\n            for (let id of ids) {\n                if (!this.records.has(id)) {\n                    missingIds.push(id);\n                }\n            }\n            if (missingIds.length > 0) {\n                this.sendUniqueMsg(this.wsRoutes.get.multiple, {\n                    [this.defineIndexKey()]: ids\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeGetAll(result) {\n        return new Promise((resolve, reject) => {\n            if (this.getAllDone) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.getAll.request, {}, {\n                    [this.wsRoutes.getAll.success]: (response) => {\n                        if (response.data) {\n                            this.getAllDone = true;\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.getAll.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeCreateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.create.request, item, {\n                    [this.wsRoutes.create.success]: (response) => {\n                        let element = response.created[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.create.error]: (response) => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeCreateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.create.multiple, list, {\n                [this.wsRoutes.create.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.created) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.create.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeUpdateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.update.request, item, {\n                    [this.wsRoutes.update.success]: (response) => {\n                        let element = response.updated[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.update.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeUpdateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.update.multiple, list, {\n                [this.wsRoutes.update.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.updated) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.update.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeDeleteItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.delete.request, item, {\n                    [this.wsRoutes.delete.success]: (response) => {\n                        resolve();\n                    },\n                    [this.wsRoutes.delete.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeDeleteList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.delete.multiple, list, {\n                [this.wsRoutes.delete.success]: (response) => {\n                    resolve();\n                },\n                [this.wsRoutes.delete.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true},{"fullName":"Aventus.RamWsRoutes","isStrong":false},{"fullName":"Aventus.Socket","isStrong":false},{"fullName":"Aventus.RamWsCallback","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Map","isStrong":false}],"fullName":"Aventus.GenericRamWs","required":false,"type":1,"isExported":true},{"code":"class RamWs extends GenericRamWs {\n}\n","dependances":[{"fullName":"Aventus.GenericRamWs","isStrong":true}],"fullName":"Aventus.RamWs","required":false,"type":1,"isExported":true},{"code":"class ResultWithError {\n    /**\n     * Determine if the action is a success\n     */\n    get success() {\n        return this.errors.length == 0;\n    }\n    /**\n     * Result\n     */\n    result;\n    /**\n     * List of errors\n     */\n    errors = [];\n}\n","dependances":[],"fullName":"Aventus.ResultWithError","required":false,"type":1,"isExported":true},{"code":"var RamErrorCode;\n(function (RamErrorCode) {\n    RamErrorCode[RamErrorCode[\"unknow\"] = 0] = \"unknow\";\n    RamErrorCode[RamErrorCode[\"noId\"] = 1] = \"noId\";\n    RamErrorCode[RamErrorCode[\"noItemInsideRam\"] = 2] = \"noItemInsideRam\";\n})(RamErrorCode || (RamErrorCode = {}));\n","dependances":[],"fullName":"Aventus.RamErrorCode","required":false,"type":6,"isExported":true},{"code":"class GenericError {\n    /**\n     * Code for the error\n     */\n    code;\n    /**\n     * Description of the error\n     */\n    message;\n    constructor(code, message) {\n        this.code = code;\n        this.message = message;\n    }\n}\n","dependances":[],"fullName":"Aventus.GenericError","required":false,"type":1,"isExported":true},{"code":"class Watcher {\n    static __maxProxyData = 0;\n    /**\n     * Transform object into a watcher\n     */\n    static get(obj, onDataChanged) {\n        if (obj == undefined) {\n            console.error(\"You must define an objet / array for your proxy\");\n            return;\n        }\n        if (obj.__isProxy) {\n            obj.__subscribe(onDataChanged);\n            return obj;\n        }\n        Watcher.__maxProxyData++;\n        let setProxyPath = (newProxy, newPath) => {\n            if (newProxy instanceof Object && newProxy.__isProxy) {\n                newProxy.__path = newPath;\n                if (!newProxy.__proxyData) {\n                    newProxy.__proxyData = {};\n                }\n                if (!newProxy.__proxyData[newPath]) {\n                    newProxy.__proxyData[newPath] = [];\n                }\n                if (newProxy.__proxyData[newPath].indexOf(proxyData) == -1) {\n                    newProxy.__proxyData[newPath].push(proxyData);\n                }\n            }\n        };\n        let removeProxyPath = (oldValue, pathToDelete, recursive = true) => {\n            if (oldValue instanceof Object && oldValue.__isProxy) {\n                let allProxies = oldValue.__proxyData;\n                for (let triggerPath in allProxies) {\n                    if (triggerPath == pathToDelete) {\n                        for (let i = 0; i < allProxies[triggerPath].length; i++) {\n                            if (allProxies[triggerPath][i] == proxyData) {\n                                allProxies[triggerPath].splice(i, 1);\n                                i--;\n                            }\n                        }\n                        if (allProxies[triggerPath].length == 0) {\n                            delete allProxies[triggerPath];\n                            if (Object.keys(allProxies).length == 0) {\n                                delete oldValue.__proxyData;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        let jsonReplacer = (key, value) => {\n            if (key == \"__path\")\n                return undefined;\n            else if (key == \"__proxyData\")\n                return undefined;\n            else\n                return value;\n        };\n        let currentTrace = new Error().stack.split(\"\\n\");\n        currentTrace.shift();\n        currentTrace.shift();\n        let onlyDuringInit = true;\n        let proxyData = {\n            baseData: {},\n            id: Watcher.__maxProxyData,\n            callbacks: [onDataChanged],\n            avoidUpdate: [],\n            pathToRemove: [],\n            history: [{\n                    object: JSON.parse(JSON.stringify(obj, jsonReplacer)),\n                    trace: currentTrace,\n                    action: 'init',\n                    path: ''\n                }],\n            useHistory: false,\n            getProxyObject(target, element, prop) {\n                let newProxy;\n                if (element instanceof Object && element.__isProxy) {\n                    newProxy = element;\n                }\n                else {\n                    try {\n                        if (element instanceof Object) {\n                            newProxy = new Proxy(element, this);\n                        }\n                        else {\n                            return element;\n                        }\n                    }\n                    catch {\n                        return element;\n                    }\n                }\n                let newPath = '';\n                if (Array.isArray(target)) {\n                    if (prop != \"length\") {\n                        if (target.__path) {\n                            newPath = target.__path;\n                        }\n                        newPath += \"[\" + prop + \"]\";\n                        setProxyPath(newProxy, newPath);\n                    }\n                }\n                else if (element instanceof Date) {\n                    return element;\n                }\n                else {\n                    if (target.__path) {\n                        newPath = target.__path + '.';\n                    }\n                    newPath += prop;\n                    setProxyPath(newProxy, newPath);\n                }\n                return newProxy;\n            },\n            tryCustomFunction(target, prop, receiver) {\n                if (prop == \"__isProxy\") {\n                    return true;\n                }\n                else if (prop == \"__subscribe\") {\n                    return (cb) => {\n                        this.callbacks.push(cb);\n                    };\n                }\n                else if (prop == \"__unsubscribe\") {\n                    return (cb) => {\n                        let index = this.callbacks.indexOf(cb);\n                        if (index > -1) {\n                            this.callbacks.splice(index, 1);\n                        }\n                    };\n                }\n                else if (prop == \"__proxyId\") {\n                    return this.id;\n                }\n                else if (prop == \"getHistory\") {\n                    return () => {\n                        return this.history;\n                    };\n                }\n                else if (prop == \"clearHistory\") {\n                    this.history = [];\n                }\n                else if (prop == \"enableHistory\") {\n                    return () => {\n                        this.useHistory = true;\n                    };\n                }\n                else if (prop == \"disableHistory\") {\n                    return () => {\n                        this.useHistory = false;\n                    };\n                }\n                else if (prop == \"__getTarget\" && onlyDuringInit) {\n                    return () => {\n                        return target;\n                    };\n                }\n                return undefined;\n            },\n            get(target, prop, receiver) {\n                if (prop == \"__proxyData\") {\n                    return target[prop];\n                }\n                let customResult = this.tryCustomFunction(target, prop, receiver);\n                if (customResult !== undefined) {\n                    return customResult;\n                }\n                let element = target[prop];\n                if (typeof (element) == 'object') {\n                    return this.getProxyObject(target, element, prop);\n                }\n                else if (typeof (element) == 'function') {\n                    if (Array.isArray(target)) {\n                        let result;\n                        if (prop == 'push') {\n                            if (target.__isProxy) {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    return index;\n                                };\n                            }\n                            else {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    let proxyEl = this.getProxyObject(target, el, (index - 1));\n                                    target.splice(target.length - 1, 1, proxyEl);\n                                    trigger('CREATED', target, receiver, proxyEl, \"[\" + (index - 1) + \"]\");\n                                    return index;\n                                };\n                            }\n                        }\n                        else if (prop == 'splice') {\n                            if (target.__isProxy) {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    let path = target.__path ? target.__path : '';\n                                    for (let i = 0; i < res.length; i++) {\n                                        trigger('DELETED', target, receiver, res[i], \"[\" + index + \"]\");\n                                        removeProxyPath(res[i], path + \"[\" + (index + i) + \"]\");\n                                    }\n                                    for (let i = 0; i < insert.length; i++) {\n                                        let proxyEl = this.getProxyObject(target, insert[i], (index + i));\n                                        target.splice((index + i), 1, proxyEl);\n                                        trigger('CREATED', target, receiver, proxyEl, \"[\" + (index + i) + \"]\");\n                                    }\n                                    let fromIndex = index + insert.length;\n                                    let baseDiff = index - insert.length + res.length + 1;\n                                    for (let i = fromIndex, j = 0; i < target.length; i++, j++) {\n                                        let oldPath = path + \"[\" + (j + baseDiff) + \"]\";\n                                        removeProxyPath(target[i], oldPath, false);\n                                        let proxyEl = this.getProxyObject(target, target[i], i);\n                                        let recuUpdate = (childEl) => {\n                                            if (Array.isArray(childEl)) {\n                                                for (let i = 0; i < childEl.length; i++) {\n                                                    if (childEl[i] instanceof Object && childEl[i].__path) {\n                                                        let oldPathRecu = proxyEl[i].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[i], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[i], i);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                            else if (childEl instanceof Object && !(childEl instanceof Date)) {\n                                                for (let key in childEl) {\n                                                    if (childEl[key] instanceof Object && childEl[key].__path) {\n                                                        let oldPathRecu = proxyEl[key].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[key], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[key], key);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                        };\n                                        recuUpdate(proxyEl);\n                                    }\n                                    return res;\n                                };\n                            }\n                        }\n                        else if (prop == 'pop') {\n                            if (target.__isProxy) {\n                                result = () => {\n                                    let res = target.pop();\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = () => {\n                                    let index = target.length - 1;\n                                    let res = target.pop();\n                                    let path = target.__path ? target.__path : '';\n                                    trigger('DELETED', target, receiver, res, \"[\" + index + \"]\");\n                                    removeProxyPath(res, path + \"[\" + index + \"]\");\n                                    return res;\n                                };\n                            }\n                        }\n                        else {\n                            result = element.bind(target);\n                        }\n                        return result;\n                    }\n                    return element.bind(target);\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n                let triggerChange = false;\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        let oldValue = Reflect.get(target, prop, receiver);\n                        if (oldValue !== value) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.set(target, prop, value, receiver);\n                if (triggerChange) {\n                    let index = this.avoidUpdate.indexOf(prop);\n                    if (index == -1) {\n                        trigger('UPDATED', target, receiver, value, prop);\n                    }\n                    else {\n                        this.avoidUpdate.splice(index, 1);\n                    }\n                }\n                return result;\n            },\n            deleteProperty(target, prop) {\n                let triggerChange = false;\n                let pathToDelete = '';\n                if (prop != \"__path\") {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                pathToDelete = target.__path;\n                            }\n                            pathToDelete += \"[\" + prop + \"]\";\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            pathToDelete = target.__path + '.';\n                        }\n                        pathToDelete += prop;\n                        triggerChange = true;\n                    }\n                }\n                if (target.hasOwnProperty(prop)) {\n                    let oldValue = target[prop];\n                    delete target[prop];\n                    if (triggerChange) {\n                        trigger('DELETED', target, null, oldValue, prop);\n                        removeProxyPath(oldValue, pathToDelete);\n                    }\n                    return true;\n                }\n                return false;\n            },\n            defineProperty(target, prop, descriptor) {\n                let triggerChange = false;\n                let newPath = '';\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                newPath = target.__path;\n                            }\n                            newPath += \"[\" + prop + \"]\";\n                            if (!target.hasOwnProperty(prop)) {\n                                triggerChange = true;\n                            }\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            newPath = target.__path + '.';\n                        }\n                        newPath += prop;\n                        if (!target.hasOwnProperty(prop)) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.defineProperty(target, prop, descriptor);\n                if (triggerChange) {\n                    this.avoidUpdate.push(prop);\n                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);\n                    target[prop] = proxyEl;\n                    trigger('CREATED', target, null, proxyEl, prop);\n                }\n                return result;\n            }\n        };\n        const trigger = (type, target, receiver, value, prop) => {\n            if (target.__isProxy) {\n                return;\n            }\n            let allProxies = target.__proxyData;\n            let receiverId = 0;\n            if (receiver == null) {\n                receiverId = proxyData.id;\n            }\n            else {\n                receiverId = receiver.__proxyId;\n            }\n            if (proxyData.id == receiverId) {\n                let stacks = [];\n                let allStacks = new Error().stack.split(\"\\n\");\n                for (let i = allStacks.length - 1; i >= 0; i--) {\n                    let current = allStacks[i].trim().replace(\"at \", \"\");\n                    if (current.startsWith(\"Object.set\") || current.startsWith(\"Proxy.result\")) {\n                        break;\n                    }\n                    stacks.push(current);\n                }\n                for (let triggerPath in allProxies) {\n                    for (let currentProxyData of allProxies[triggerPath]) {\n                        let pathToSend = triggerPath;\n                        if (pathToSend != \"\") {\n                            if (Array.isArray(target)) {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \"[\" + prop + \"]\";\n                                }\n                                else {\n                                    pathToSend += prop;\n                                }\n                            }\n                            else {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \".\";\n                                }\n                                pathToSend += prop;\n                            }\n                        }\n                        else {\n                            pathToSend = prop;\n                        }\n                        if (proxyData.useHistory) {\n                            proxyData.history.push({\n                                object: JSON.parse(JSON.stringify(currentProxyData.baseData, jsonReplacer)),\n                                trace: stacks.reverse(),\n                                action: WatchAction[type],\n                                path: pathToSend\n                            });\n                        }\n                        [...currentProxyData.callbacks].forEach((cb) => {\n                            cb(WatchAction[type], pathToSend, value);\n                        });\n                    }\n                }\n            }\n        };\n        var realProxy = new Proxy(obj, proxyData);\n        proxyData.baseData = realProxy.__getTarget();\n        onlyDuringInit = false;\n        setProxyPath(realProxy, '');\n        return realProxy;\n    }\n}\n","dependances":[{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Watcher","required":false,"type":1,"isExported":true},{"code":"var WatchAction;\n(function (WatchAction) {\n    WatchAction[WatchAction[\"CREATED\"] = 0] = \"CREATED\";\n    WatchAction[WatchAction[\"UPDATED\"] = 1] = \"UPDATED\";\n    WatchAction[WatchAction[\"DELETED\"] = 2] = \"DELETED\";\n})(WatchAction || (WatchAction = {}));\n","dependances":[],"fullName":"Aventus.WatchAction","required":false,"type":6,"isExported":true},{"code":"class ResourceLoader {\n    static headerLoaded = {};\n    static headerWaiting = {};\n    /**\n     * Load the resource inside the head tag\n     */\n    static async loadInHead(options) {\n        const _options = this.prepareOptions(options);\n        if (this.headerLoaded[_options.url]) {\n            return true;\n        }\n        else if (this.headerWaiting.hasOwnProperty(_options.url)) {\n            return await this.awaitFctHead(_options.url);\n        }\n        else {\n            this.headerWaiting[_options.url] = [];\n            let tagEl;\n            if (_options.type == \"js\") {\n                tagEl = document.createElement(\"SCRIPT\");\n            }\n            else if (_options.type == \"css\") {\n                tagEl = document.createElement(\"LINK\");\n                tagEl.setAttribute(\"rel\", \"stylesheet\");\n            }\n            else {\n                throw \"unknow type \" + _options.type + \" to append into head\";\n            }\n            document.head.appendChild(tagEl);\n            let result = await this.loadTag(tagEl, _options.url);\n            this.headerLoaded[_options.url] = true;\n            this.releaseAwaitFctHead(_options.url, result);\n            return result;\n        }\n    }\n    static loadTag(tagEl, url) {\n        return new Promise((resolve, reject) => {\n            tagEl.addEventListener(\"load\", (e) => {\n                resolve(true);\n            });\n            tagEl.addEventListener(\"error\", (e) => {\n                resolve(false);\n            });\n            if (tagEl instanceof HTMLLinkElement) {\n                tagEl.setAttribute(\"href\", url);\n            }\n            else {\n                tagEl.setAttribute('src', url);\n            }\n        });\n    }\n    static releaseAwaitFctHead(url, result) {\n        if (this.headerWaiting[url]) {\n            for (let i = 0; i < this.headerWaiting[url].length; i++) {\n                this.headerWaiting[url][i](result);\n            }\n            delete this.headerWaiting[url];\n        }\n    }\n    static awaitFctHead(url) {\n        return new Promise((resolve) => {\n            this.headerWaiting[url].push((result) => {\n                resolve(result);\n            });\n        });\n    }\n    static requestLoaded = {};\n    static requestWaiting = {};\n    /**\n     *\n    */\n    static async load(options) {\n        options = this.prepareOptions(options);\n        if (this.requestLoaded[options.url]) {\n            return this.requestLoaded[options.url];\n        }\n        else if (this.requestWaiting.hasOwnProperty(options.url)) {\n            await this.awaitFct(options.url);\n            return this.requestLoaded[options.url];\n        }\n        else {\n            this.requestWaiting[options.url] = [];\n            let blob = false;\n            if (options.type == \"img\") {\n                blob = true;\n            }\n            let content = await this.fetching(options.url, blob);\n            this.requestLoaded[options.url] = content;\n            this.releaseAwaitFct(options.url);\n            return content;\n        }\n    }\n    static releaseAwaitFct(url) {\n        if (this.requestWaiting[url]) {\n            for (let i = 0; i < this.requestWaiting[url].length; i++) {\n                this.requestWaiting[url][i]();\n            }\n            delete this.requestWaiting[url];\n        }\n    }\n    static awaitFct(url) {\n        return new Promise((resolve) => {\n            this.requestWaiting[url].push(() => {\n                resolve('');\n            });\n        });\n    }\n    static async fetching(url, useBlob = false) {\n        if (useBlob) {\n            let result = await fetch(url, {\n                headers: {\n                    responseType: 'blob'\n                }\n            });\n            let blob = await result.blob();\n            return await this.readFile(blob);\n        }\n        else {\n            let result = await fetch(url);\n            return await result.text();\n        }\n    }\n    static readFile(blob) {\n        return new Promise((resolve) => {\n            var reader = new FileReader();\n            reader.onloadend = function () {\n                resolve(reader.result);\n            };\n            reader.readAsDataURL(blob);\n        });\n    }\n    static imgExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\"];\n    static prepareOptions(options) {\n        let result;\n        if (typeof options === 'string' || options instanceof String) {\n            result = {\n                url: options,\n                type: 'js'\n            };\n            let splittedURI = result.url.split('.');\n            let extension = splittedURI[splittedURI.length - 1];\n            extension = extension.split(\"?\")[0];\n            if (extension == \"svg\") {\n                result.type = 'svg';\n            }\n            else if (extension == \"js\") {\n                result.type = 'js';\n            }\n            else if (extension == \"css\") {\n                result.type = 'css';\n            }\n            else if (this.imgExtensions.indexOf(extension) != -1) {\n                result.type = 'img';\n            }\n            else {\n                throw 'unknow extension found :' + extension + \". Please define your extension inside options\";\n            }\n        }\n        else {\n            result = options;\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.ResourceLoaderHeadOptions","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.ResourceLoaderOptions","isStrong":false},{"fullName":"Blob","isStrong":false}],"fullName":"Aventus.ResourceLoader","required":false,"type":1,"isExported":true},{"code":"class ResizeObserver {\n    callback;\n    targets;\n    fpsInterval;\n    nextFrame;\n    entriesChangedEvent;\n    willTrigger;\n    static resizeObserverClassByObject = {};\n    static uniqueInstance;\n    static getUniqueInstance() {\n        if (!ResizeObserver.uniqueInstance) {\n            ResizeObserver.uniqueInstance = new window.ResizeObserver(entries => {\n                let allClasses = [];\n                for (let j = 0; j < entries.length; j++) {\n                    let entry = entries[j];\n                    let index = entry.target['sourceIndex'];\n                    if (ResizeObserver.resizeObserverClassByObject[index]) {\n                        for (let i = 0; i < ResizeObserver.resizeObserverClassByObject[index].length; i++) {\n                            let classTemp = ResizeObserver.resizeObserverClassByObject[index][i];\n                            classTemp.entryChanged(entry);\n                            if (allClasses.indexOf(classTemp) == -1) {\n                                allClasses.push(classTemp);\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < allClasses.length; i++) {\n                    allClasses[i].triggerCb();\n                }\n            });\n        }\n        return ResizeObserver.uniqueInstance;\n    }\n    constructor(options) {\n        let realOption;\n        if (options instanceof Function) {\n            realOption = {\n                callback: options,\n            };\n        }\n        else {\n            realOption = options;\n        }\n        this.callback = realOption.callback;\n        this.targets = [];\n        if (!realOption.fps) {\n            realOption.fps = 60;\n        }\n        if (realOption.fps != -1) {\n            this.fpsInterval = 1000 / realOption.fps;\n        }\n        this.nextFrame = 0;\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n    }\n    /**\n     * Observe size changing for the element\n     */\n    observe(target) {\n        if (!target[\"sourceIndex\"]) {\n            target[\"sourceIndex\"] = Math.random().toString(36);\n            this.targets.push(target);\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]] = [];\n            ResizeObserver.getUniqueInstance().observe(target);\n        }\n        if (ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].indexOf(this) == -1) {\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].push(this);\n        }\n    }\n    /**\n     * Stop observing size changing for the element\n     */\n    unobserve(target) {\n        for (let i = 0; this.targets.length; i++) {\n            let tempTarget = this.targets[i];\n            if (tempTarget == target) {\n                let position = ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].indexOf(this);\n                if (position != -1) {\n                    ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].splice(position, 1);\n                }\n                if (ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].length == 0) {\n                    delete ResizeObserver.resizeObserverClassByObject[target['sourceIndex']];\n                }\n                ResizeObserver.getUniqueInstance().unobserve(target);\n                this.targets.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Destroy the resize observer\n     */\n    disconnect() {\n        for (let i = 0; this.targets.length; i++) {\n            this.unobserve(this.targets[i]);\n        }\n    }\n    entryChanged(entry) {\n        let index = entry.target.sourceIndex;\n        this.entriesChangedEvent[index] = entry;\n    }\n    triggerCb() {\n        if (!this.willTrigger) {\n            this.willTrigger = true;\n            this._triggerCb();\n        }\n    }\n    _triggerCb() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (this.fpsInterval != -1 && elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => {\n                this._triggerCb();\n            });\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        let changed = Object.values(this.entriesChangedEvent);\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n        setTimeout(() => {\n            this.callback(changed);\n        }, 0);\n    }\n}\n","dependances":[{"fullName":"CallableFunction","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.WindowResizeObserver","isStrong":false},{"fullName":"Aventus.ResizeObserverOptions","isStrong":false}],"fullName":"Aventus.ResizeObserver","required":false,"type":1,"isExported":true},{"code":"class Instance {\n    static elements = new Map();\n    static get(type) {\n        let result = this.elements.get(type);\n        if (!result) {\n            let cst = type.prototype['constructor'];\n            result = new cst();\n            this.elements.set(type, result);\n        }\n        return result;\n    }\n    static set(el) {\n        let cst = el.constructor;\n        if (this.elements.get(cst)) {\n            return false;\n        }\n        this.elements.set(cst, el);\n        return true;\n    }\n    static destroy(el) {\n        let cst = el.constructor;\n        return this.elements.delete(cst);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.Instance","required":false,"type":1,"isExported":true},{"code":"class HttpRequest {\n    options = {};\n    url = '';\n    /**\n     * Get the right http method inside enum\n     */\n    static getMethod(method) {\n        let genericMethod = method.toLowerCase().trim();\n        if (genericMethod == \"get\") {\n            return HttpRequestMethod.GET;\n        }\n        if (genericMethod == \"post\") {\n            return HttpRequestMethod.POST;\n        }\n        if (genericMethod == \"delete\") {\n            return HttpRequestMethod.DELETE;\n        }\n        if (genericMethod == \"put\") {\n            return HttpRequestMethod.PUT;\n        }\n        if (genericMethod == \"option\") {\n            return HttpRequestMethod.OPTION;\n        }\n        console.error(\"unknow type \" + method + \". I ll return GET by default\");\n        return HttpRequestMethod.GET;\n    }\n    /**\n     * Get http method in string\n     */\n    getMethod(method) {\n        if (method == HttpRequestMethod.GET)\n            return \"GET\";\n        if (method == HttpRequestMethod.POST)\n            return \"POST\";\n        if (method == HttpRequestMethod.DELETE)\n            return \"DELETE\";\n        if (method == HttpRequestMethod.OPTION)\n            return \"OPTION\";\n        if (method == HttpRequestMethod.PUT)\n            return \"PUT\";\n        return \"GET\";\n    }\n    constructor(options) {\n        options = {\n            ...new DefaultHttpRequestOptions(),\n            ...options\n        };\n        let optionsToSend = {\n            method: this.getMethod(options.method),\n        };\n        if (options.data) {\n            if (!options.useJSON) {\n                if (options.data instanceof FormData) {\n                    optionsToSend.body = options.data;\n                }\n                else {\n                    let formData = new FormData();\n                    this.recuFillFormData(options.data, \"\", formData);\n                    optionsToSend.body = formData;\n                }\n            }\n            else {\n                optionsToSend.body = JSON.stringify(options.data);\n                optionsToSend.headers = {};\n                optionsToSend.headers['Content-Type'] = \"application/json\";\n            }\n        }\n        this.options = optionsToSend;\n        this.url = options.url;\n    }\n    recuFillFormData(data, key, form) {\n        if (typeof data === 'object' && data !== null) {\n            if (Array.isArray(data)) {\n                for (let i = 0; i < data.length; i++) {\n                    this.recuFillFormData(data[i], key + '[' + i + ']', form);\n                }\n            }\n            else if (data instanceof Date) {\n                form.append(key, data.toISOString());\n            }\n            else {\n                let props = Object.getOwnPropertyNames(data);\n                for (let prop of props) {\n                    let newKey = key === \"\" ? prop : key + '.' + prop;\n                    this.recuFillFormData(data[prop], newKey, form);\n                }\n            }\n        }\n        else {\n            form.append(key, data);\n        }\n    }\n    /**\n     * Send the http request\n     */\n    async send() {\n        let result = await fetch(this.url, this.options);\n        return result;\n    }\n    /**\n     * Send a get request\n     */\n    static async get(url) {\n        return await fetch(url, {\n            method: \"GET\"\n        });\n    }\n    /**\n     * Send a post request and wait a result in JSON format\n     */\n    static async post(url, data) {\n        let formData = new FormData();\n        for (let key in data) {\n            formData.append(key, data[key]);\n        }\n        const response = await fetch(url, {\n            method: \"POST\",\n            body: formData\n        });\n        const content = await response.json();\n        return new Promise((resolve, reject) => {\n            if (response.ok) {\n                resolve(content);\n            }\n            else {\n                reject(content);\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"RequestInit","isStrong":false},{"fullName":"Aventus.HttpRequestMethod","isStrong":false},{"fullName":"Aventus.DefaultHttpRequestOptions","isStrong":false},{"fullName":"FormData","isStrong":false}],"fullName":"Aventus.HttpRequest","required":false,"type":1,"isExported":true},{"code":"var HttpRequestMethod;\n(function (HttpRequestMethod) {\n    HttpRequestMethod[HttpRequestMethod[\"GET\"] = 0] = \"GET\";\n    HttpRequestMethod[HttpRequestMethod[\"POST\"] = 1] = \"POST\";\n    HttpRequestMethod[HttpRequestMethod[\"DELETE\"] = 2] = \"DELETE\";\n    HttpRequestMethod[HttpRequestMethod[\"PUT\"] = 3] = \"PUT\";\n    HttpRequestMethod[HttpRequestMethod[\"OPTION\"] = 4] = \"OPTION\";\n})(HttpRequestMethod || (HttpRequestMethod = {}));\n","dependances":[],"fullName":"Aventus.HttpRequestMethod","required":false,"type":6,"isExported":true},{"code":"class DefaultHttpRequestOptions {\n    url = \"\";\n    method = HttpRequestMethod.GET;\n    useJSON = false;\n}\n","dependances":[{"fullName":"Aventus.HttpRequestOptions","isStrong":true},{"fullName":"Aventus.HttpRequestMethod","isStrong":false}],"fullName":"Aventus.DefaultHttpRequestOptions","required":false,"type":1,"isExported":true},{"code":"class DragAndDrop {\n    /**\n     * Default offset before drag element\n     */\n    static defaultOffsetDrag = 20;\n    pressManager;\n    options;\n    startCursorPosition;\n    startElementPosition;\n    isEnable = true;\n    constructor(options) {\n        this.options = this.getDefaultOptions();\n        this.mergeProperties(options);\n        this.mergeFunctions(options);\n        this.init();\n    }\n    getDefaultOptions() {\n        return {\n            applyDrag: true,\n            element: null,\n            elementTrigger: null,\n            offsetDrag: DragAndDrop.defaultOffsetDrag,\n            shadow: {\n                enable: false,\n                container: document.body,\n                removeOnStop: true,\n                transform: () => { }\n            },\n            strict: false,\n            targets: [],\n            usePercent: false,\n            isDragEnable: () => true,\n            getZoom: () => 1,\n            getOffsetX: () => 0,\n            getOffsetY: () => 0,\n            onPointerDown: (e) => { },\n            onPointerUp: (e) => { },\n            onStart: (e) => { },\n            onMove: (e) => { },\n            onStop: (e) => { },\n            onDrop: (element, targets) => { }\n        };\n    }\n    mergeProperties(options) {\n        if (options.element === void 0) {\n            throw \"You must define the element for the drag&drop\";\n        }\n        this.options.element = options.element;\n        if (options.elementTrigger === void 0) {\n            this.options.elementTrigger = this.options.element;\n        }\n        else {\n            this.options.elementTrigger = options.elementTrigger;\n        }\n        this.defaultMerge(options, \"applyDrag\");\n        this.defaultMerge(options, \"offsetDrag\");\n        this.defaultMerge(options, \"strict\");\n        this.defaultMerge(options, \"targets\");\n        this.defaultMerge(options, \"usePercent\");\n        if (options.shadow !== void 0) {\n            this.options.shadow.enable = options.shadow.enable;\n            if (options.shadow.container !== void 0) {\n                this.options.shadow.container = options.shadow.container;\n            }\n            else {\n                this.options.shadow.container = document.body;\n            }\n            if (options.shadow.removeOnStop !== void 0) {\n                this.options.shadow.removeOnStop = options.shadow.removeOnStop;\n            }\n            if (options.shadow.transform !== void 0) {\n                this.options.shadow.transform = options.shadow.transform;\n            }\n        }\n    }\n    mergeFunctions(options) {\n        this.defaultMerge(options, \"isDragEnable\");\n        this.defaultMerge(options, \"getZoom\");\n        this.defaultMerge(options, \"getOffsetX\");\n        this.defaultMerge(options, \"getOffsetY\");\n        this.defaultMerge(options, \"onPointerDown\");\n        this.defaultMerge(options, \"onPointerUp\");\n        this.defaultMerge(options, \"onStart\");\n        this.defaultMerge(options, \"onMove\");\n        this.defaultMerge(options, \"onStop\");\n        this.defaultMerge(options, \"onDrop\");\n    }\n    defaultMerge(options, name) {\n        if (options[name] !== void 0) {\n            this.options[name] = options[name];\n        }\n    }\n    init() {\n        this.pressManager = new PressManager({\n            element: this.options.elementTrigger,\n            onPressStart: this.onPressStart.bind(this),\n            onPressEnd: this.onPressEnd.bind(this),\n            onDragStart: this.onDragStart.bind(this),\n            onDrag: this.onDrag.bind(this),\n            onDragEnd: this.onDragEnd.bind(this),\n            offsetDrag: this.options.offsetDrag\n        });\n    }\n    draggableElement;\n    positionShadowRelativeToElement;\n    onPressStart(e) {\n        this.options.onPointerDown(e);\n    }\n    onPressEnd(e) {\n        this.options.onPointerUp(e);\n    }\n    onDragStart(e) {\n        this.isEnable = this.options.isDragEnable();\n        if (!this.isEnable) {\n            return;\n        }\n        this.draggableElement = this.options.element;\n        this.startCursorPosition = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        this.startElementPosition = {\n            x: this.draggableElement.offsetLeft,\n            y: this.draggableElement.offsetTop\n        };\n        if (this.options.shadow.enable) {\n            this.draggableElement = this.options.element.cloneNode(true);\n            let elBox = this.options.element.getBoundingClientRect();\n            let containerBox = this.options.shadow.container.getBoundingClientRect();\n            this.positionShadowRelativeToElement = {\n                x: elBox.x - containerBox.x,\n                y: elBox.y - containerBox.y\n            };\n            if (this.options.applyDrag) {\n                this.draggableElement.style.position = \"absolute\";\n                this.draggableElement.style.top = this.positionShadowRelativeToElement.y + this.options.getOffsetY() + 'px';\n                this.draggableElement.style.left = this.positionShadowRelativeToElement.x + this.options.getOffsetX() + 'px';\n            }\n            this.options.shadow.transform(this.draggableElement);\n            this.options.shadow.container.appendChild(this.draggableElement);\n        }\n        this.options.onStart(e);\n    }\n    onDrag(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let zoom = this.options.getZoom();\n        let diff = {\n            x: 0,\n            y: 0\n        };\n        if (this.options.shadow.enable) {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) + this.positionShadowRelativeToElement.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) + this.positionShadowRelativeToElement.y + this.options.getOffsetY(),\n            };\n        }\n        else {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) / zoom + this.startElementPosition.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) / zoom + this.startElementPosition.y + this.options.getOffsetY()\n            };\n        }\n        let newPos = this.setPosition(diff);\n        this.options.onMove(e, newPos);\n    }\n    onDragEnd(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let targets = this.getMatchingTargets();\n        if (this.options.shadow.enable && this.options.shadow.removeOnStop) {\n            this.draggableElement.parentNode?.removeChild(this.draggableElement);\n        }\n        if (targets.length > 0) {\n            this.options.onDrop(this.draggableElement, targets);\n        }\n        this.options.onStop(e);\n    }\n    setPosition(position) {\n        if (this.options.usePercent) {\n            let elementParent = this.draggableElement.offsetParent;\n            const percentLeft = (position.x / elementParent.offsetWidth) * 100;\n            const percentTop = (position.y / elementParent.offsetHeight) * 100;\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = percentLeft + '%';\n                this.draggableElement.style.top = percentTop + '%';\n            }\n            return {\n                x: percentLeft,\n                y: percentTop\n            };\n        }\n        else {\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = position.x + 'px';\n                this.draggableElement.style.top = position.y + 'px';\n            }\n        }\n        return position;\n    }\n    /**\n     * Get targets within the current element position is matching\n     */\n    getMatchingTargets() {\n        let matchingTargets = [];\n        for (let target of this.options.targets) {\n            const elementCoordinates = this.draggableElement.getBoundingClientRect();\n            const targetCoordinates = target.getBoundingClientRect();\n            let offsetX = this.options.getOffsetX();\n            let offsetY = this.options.getOffsetY();\n            let zoom = this.options.getZoom();\n            targetCoordinates.x += offsetX;\n            targetCoordinates.y += offsetY;\n            targetCoordinates.width *= zoom;\n            targetCoordinates.height *= zoom;\n            if (this.options.strict) {\n                if ((elementCoordinates.x >= targetCoordinates.x && elementCoordinates.x + elementCoordinates.width <= targetCoordinates.x + targetCoordinates.width) &&\n                    (elementCoordinates.y >= targetCoordinates.y && elementCoordinates.y + elementCoordinates.height <= targetCoordinates.y + targetCoordinates.height)) {\n                    matchingTargets.push(target);\n                }\n            }\n            else {\n                let elementLeft = elementCoordinates.x;\n                let elementRight = elementCoordinates.x + elementCoordinates.width;\n                let elementTop = elementCoordinates.y;\n                let elementBottom = elementCoordinates.y + elementCoordinates.height;\n                let targetLeft = targetCoordinates.x;\n                let targetRight = targetCoordinates.x + targetCoordinates.width;\n                let targetTop = targetCoordinates.y;\n                let targetBottom = targetCoordinates.y + targetCoordinates.height;\n                if (!(elementRight < targetLeft ||\n                    elementLeft > targetRight ||\n                    elementBottom < targetTop ||\n                    elementTop > targetBottom)) {\n                    matchingTargets.push(target);\n                }\n            }\n        }\n        return matchingTargets;\n    }\n    /**\n     * Get element currently dragging\n     */\n    getElementDrag() {\n        return this.draggableElement;\n    }\n    /**\n     * Set targets where to drop\n     */\n    setTargets(targets) {\n        this.options.targets = targets;\n    }\n    /**\n     * Destroy the current drag&drop instance\n     */\n    destroy() {\n        this.pressManager.destroy();\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.Coordinate","isStrong":false},{"fullName":"Aventus.DragAndDropOptions","isStrong":false}],"fullName":"Aventus.DragAndDrop","required":false,"type":1,"isExported":true},{"code":"class PressManager {\n    options;\n    element;\n    subPressManager = [];\n    delayDblPress = 150;\n    delayLongPress = 700;\n    nbPress = 0;\n    offsetDrag = 20;\n    state = {\n        oneActionTriggered: false,\n        isMoving: false,\n    };\n    startPosition = { x: 0, y: 0 };\n    customFcts = {};\n    timeoutDblPress = 0;\n    timeoutLongPress = 0;\n    downEventSaved;\n    actionsName = {\n        press: \"press\",\n        longPress: \"longPress\",\n        dblPress: \"dblPress\",\n        drag: \"drag\"\n    };\n    useDblPress = false;\n    functionsBinded = {\n        downAction: (e) => { },\n        upAction: (e) => { },\n        moveAction: (e) => { },\n        childPressStart: (e) => { },\n        childPressEnd: (e) => { },\n        childPress: (e) => { },\n        childDblPress: (e) => { },\n        childLongPress: (e) => { },\n        childDragStart: (e) => { },\n    };\n    /**\n     * @param {*} options - The options\n     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage\n     */\n    constructor(options) {\n        if (options.element === void 0) {\n            throw 'You must provide an element';\n        }\n        if (Array.isArray(options.element)) {\n            for (let el of options.element) {\n                let cloneOpt = { ...options };\n                cloneOpt.element = el;\n                this.subPressManager.push(new PressManager(cloneOpt));\n            }\n        }\n        else {\n            this.element = options.element;\n            this.checkDragConstraint(options);\n            this.assignValueOption(options);\n            this.options = options;\n            this.init();\n        }\n    }\n    /**\n     * Get the current element focused by the PressManager\n     */\n    getElement() {\n        return this.element;\n    }\n    checkDragConstraint(options) {\n        if (options.onDrag !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragStart !== void 0) {\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragEnd !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n        }\n    }\n    assignValueOption(options) {\n        if (options.delayDblPress !== undefined) {\n            this.delayDblPress = options.delayDblPress;\n        }\n        if (options.delayLongPress !== undefined) {\n            this.delayLongPress = options.delayLongPress;\n        }\n        if (options.offsetDrag !== undefined) {\n            this.offsetDrag = options.offsetDrag;\n        }\n        if (options.onDblPress !== undefined) {\n            this.useDblPress = true;\n        }\n        if (options.forceDblPress) {\n            this.useDblPress = true;\n        }\n    }\n    bindAllFunction() {\n        this.functionsBinded.downAction = this.downAction.bind(this);\n        this.functionsBinded.moveAction = this.moveAction.bind(this);\n        this.functionsBinded.upAction = this.upAction.bind(this);\n        this.functionsBinded.childDblPress = this.childDblPress.bind(this);\n        this.functionsBinded.childDragStart = this.childDragStart.bind(this);\n        this.functionsBinded.childLongPress = this.childLongPress.bind(this);\n        this.functionsBinded.childPress = this.childPress.bind(this);\n        this.functionsBinded.childPressStart = this.childPressStart.bind(this);\n        this.functionsBinded.childPressEnd = this.childPressEnd.bind(this);\n    }\n    init() {\n        this.bindAllFunction();\n        this.element.addEventListener(\"pointerdown\", this.functionsBinded.downAction);\n        this.element.addEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n        this.element.addEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n        this.element.addEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n        this.element.addEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n        this.element.addEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n        this.element.addEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n    }\n    downAction(e) {\n        this.downEventSaved = e;\n        e.stopImmediatePropagation();\n        this.customFcts = {};\n        if (this.nbPress == 0) {\n            this.state.oneActionTriggered = false;\n            clearTimeout(this.timeoutDblPress);\n        }\n        this.startPosition = { x: e.pageX, y: e.pageY };\n        document.addEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.addEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        this.timeoutLongPress = setTimeout(() => {\n            if (!this.state.oneActionTriggered) {\n                if (this.options.onLongPress) {\n                    this.state.oneActionTriggered = true;\n                    this.options.onLongPress(e, this);\n                    this.triggerEventToParent(this.actionsName.longPress, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"longpress\", e);\n                }\n            }\n        }, this.delayLongPress);\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e, this);\n            this.emitTriggerFunction(\"pressstart\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressstart\", e);\n        }\n    }\n    upAction(e) {\n        e.stopImmediatePropagation();\n        document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        clearTimeout(this.timeoutLongPress);\n        if (this.state.isMoving) {\n            this.state.isMoving = false;\n            if (this.options.onDragEnd) {\n                this.options.onDragEnd(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDragEnd) {\n                this.customFcts.onDragEnd(e, this.customFcts.src);\n            }\n        }\n        else {\n            if (this.useDblPress) {\n                this.nbPress++;\n                if (this.nbPress == 2) {\n                    if (!this.state.oneActionTriggered) {\n                        this.state.oneActionTriggered = true;\n                        this.nbPress = 0;\n                        if (this.options.onDblPress) {\n                            this.options.onDblPress(e, this);\n                            this.triggerEventToParent(this.actionsName.dblPress, e);\n                        }\n                        else {\n                            this.emitTriggerFunction(\"dblpress\", e);\n                        }\n                    }\n                }\n                else if (this.nbPress == 1) {\n                    this.timeoutDblPress = setTimeout(() => {\n                        this.nbPress = 0;\n                        if (!this.state.oneActionTriggered) {\n                            if (this.options.onPress) {\n                                this.state.oneActionTriggered = true;\n                                this.options.onPress(e, this);\n                                this.triggerEventToParent(this.actionsName.press, e);\n                            }\n                            else {\n                                this.emitTriggerFunction(\"press\", e);\n                            }\n                        }\n                    }, this.delayDblPress);\n                }\n            }\n            else {\n                if (!this.state.oneActionTriggered) {\n                    if (this.options.onPress) {\n                        this.state.oneActionTriggered = true;\n                        this.options.onPress(e, this);\n                        this.triggerEventToParent(this.actionsName.press, e);\n                    }\n                    else {\n                        this.emitTriggerFunction(\"press\", e);\n                    }\n                }\n            }\n        }\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e, this);\n            this.emitTriggerFunction(\"pressend\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressend\", e);\n        }\n    }\n    moveAction(e) {\n        if (!this.state.isMoving && !this.state.oneActionTriggered) {\n            e.stopImmediatePropagation();\n            let xDist = e.pageX - this.startPosition.x;\n            let yDist = e.pageY - this.startPosition.y;\n            let distance = Math.sqrt(xDist * xDist + yDist * yDist);\n            if (distance > this.offsetDrag) {\n                this.state.oneActionTriggered = true;\n                if (this.options.onDragStart) {\n                    this.state.isMoving = true;\n                    this.options.onDragStart(this.downEventSaved, this);\n                    this.triggerEventToParent(this.actionsName.drag, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"dragstart\", this.downEventSaved);\n                }\n            }\n        }\n        else if (this.state.isMoving) {\n            if (this.options.onDrag) {\n                this.options.onDrag(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDrag) {\n                this.customFcts.onDrag(e, this.customFcts.src);\n            }\n        }\n    }\n    triggerEventToParent(eventName, pointerEvent) {\n        if (this.element.parentNode) {\n            this.element.parentNode.dispatchEvent(new CustomEvent(\"pressaction_trigger\", {\n                bubbles: true,\n                cancelable: false,\n                composed: true,\n                detail: {\n                    target: this.element,\n                    eventName: eventName,\n                    realEvent: pointerEvent\n                }\n            }));\n        }\n    }\n    childPressStart(e) {\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e.detail.realEvent, this);\n        }\n    }\n    childPressEnd(e) {\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e.detail.realEvent, this);\n        }\n    }\n    childPress(e) {\n        if (this.options.onPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.press, e.detail.realEvent);\n        }\n    }\n    childDblPress(e) {\n        if (this.options.onDblPress) {\n            e.stopImmediatePropagation();\n            if (e.detail.state) {\n                e.detail.state.oneActionTriggered = true;\n            }\n            this.options.onDblPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.dblPress, e.detail.realEvent);\n        }\n    }\n    childLongPress(e) {\n        if (this.options.onLongPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onLongPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.longPress, e.detail.realEvent);\n        }\n    }\n    childDragStart(e) {\n        if (this.options.onDragStart) {\n            e.stopImmediatePropagation();\n            e.detail.state.isMoving = true;\n            e.detail.customFcts.src = this;\n            e.detail.customFcts.onDrag = this.options.onDrag;\n            e.detail.customFcts.onDragEnd = this.options.onDragEnd;\n            e.detail.customFcts.offsetDrag = this.options.offsetDrag;\n            this.options.onDragStart(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.drag, e.detail.realEvent);\n        }\n    }\n    emitTriggerFunction(action, e, el = null) {\n        let ev = new CustomEvent(\"trigger_pointer_\" + action, {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n            detail: {\n                state: this.state,\n                customFcts: this.customFcts,\n                realEvent: e\n            }\n        });\n        if (!el) {\n            el = this.element;\n        }\n        el.dispatchEvent(ev);\n    }\n    /**\n     * Destroy the Press instance byremoving all events\n     */\n    destroy() {\n        for (let sub of this.subPressManager) {\n            sub.destroy();\n        }\n        if (this.element) {\n            this.element.removeEventListener(\"pointerdown\", this.functionsBinded.downAction);\n            this.element.removeEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n            this.element.removeEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n            this.element.removeEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n            this.element.removeEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n            this.element.removeEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n            this.element.removeEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.PressManagerState","isStrong":false},{"fullName":"Aventus.InternalCustomFunction","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.InternalPointerEvent","isStrong":false}],"fullName":"Aventus.PressManager","required":false,"type":1,"isExported":true},{"code":"class Callback {\n    callbacks = [];\n    /**\n     * Clear all callbacks\n     */\n    clear() {\n        this.callbacks = [];\n    }\n    /**\n     * Add a callback\n     */\n    add(cb) {\n        this.callbacks.push(cb);\n    }\n    /**\n     * Remove a callback\n     */\n    remove(cb) {\n        let index = this.callbacks.indexOf(cb);\n        if (index != -1) {\n            this.callbacks.splice(index, 1);\n        }\n    }\n    /**\n     * Trigger all callbacks\n     */\n    trigger(args) {\n        let result = [];\n        for (let callback of this.callbacks) {\n            result.push(callback.apply(null, args));\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.Callback","required":false,"type":1,"isExported":true},{"code":"class CallbackGroup {\n    callbacks = {};\n    /**\n     * Clear all callbacks\n     */\n    clearAll() {\n        this.callbacks = {};\n    }\n    /**\n     * Clear all callbacks for a specific group\n     */\n    clear(group) {\n        delete this.callbacks[group];\n    }\n    /**\n     * Add a callback for a group\n     */\n    add(group, cb) {\n        if (!this.callbacks[group]) {\n            this.callbacks[group] = [];\n        }\n        this.callbacks[group].push(cb);\n    }\n    /**\n     * Remove a callback for a group\n     */\n    remove(group, cb) {\n        if (this.callbacks[group]) {\n            let index = this.callbacks[group].indexOf(cb);\n            if (index != -1) {\n                this.callbacks[group].splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Trigger all callbacks inside a group\n     */\n    trigger(group, args) {\n        if (this.callbacks[group]) {\n            for (let callback of this.callbacks[group]) {\n                callback.apply(null, args);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.CallbackGroup","required":false,"type":1,"isExported":true},{"code":"class Animation {\n    /**\n     * Default FPS for all Animation if not set inside options\n     */\n    static FPS_DEFAULT = 60;\n    options;\n    nextFrame;\n    fpsInterval;\n    continueAnimation = false;\n    constructor(options) {\n        if (!options.animate) {\n            options.animate = () => { };\n        }\n        if (!options.stopped) {\n            options.stopped = () => { };\n        }\n        if (!options.fps) {\n            options.fps = Animation.FPS_DEFAULT;\n        }\n        this.options = options;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    animate() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => this.animate());\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        setTimeout(() => {\n            this.options.animate();\n        }, 0);\n        if (this.continueAnimation) {\n            requestAnimationFrame(() => this.animate());\n        }\n        else {\n            this.options.stopped();\n        }\n    }\n    /**\n     * Start the of animation\n     */\n    start() {\n        if (this.continueAnimation == false) {\n            this.continueAnimation = true;\n            this.nextFrame = window.performance.now();\n            this.animate();\n        }\n    }\n    /**\n     * Stop the animation\n     */\n    stop() {\n        this.continueAnimation = false;\n    }\n    /**\n     * Get the FPS\n     */\n    getFPS() {\n        return this.options.fps;\n    }\n    /**\n     * Set the FPS\n     */\n    setFPS(fps) {\n        this.options.fps = fps;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    /**\n     * Get the animation status (true if animation is running)\n     */\n    isStarted() {\n        return this.continueAnimation;\n    }\n}\n","dependances":[{"fullName":"Aventus.AnimationOptions","isStrong":false}],"fullName":"Aventus.Animation","required":false,"type":1,"isExported":true},{"code":"class DataManager {\n    static info = new Map();\n    /**\n     * Register a unique string type for a data\n     */\n    static register($type, cst) {\n        this.info.set($type, cst);\n    }\n    /**\n     * Get the contructor for the unique string type\n     */\n    static getConstructor($type) {\n        let result = this.info.get($type);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Clone the object to keep real type\n     */\n    static clone(data) {\n        return this.createObject(JSON.parse(JSON.stringify(data)));\n    }\n    /**\n     * Create an object with the type management\n     * Usefull to convert object from JSON into Js class\n     */\n    static createObject(data, transfromToDate = false) {\n        if (typeof data === 'object' && data !== null) {\n            if (data instanceof Date) {\n                return data;\n            }\n            if (Array.isArray(data)) {\n                let result = [];\n                for (let element of data) {\n                    result.push(this.createObject(element));\n                }\n                return result;\n            }\n            if (data.$type) {\n                let cst = DataManager.getConstructor(data.$type);\n                if (cst) {\n                    let obj = new cst();\n                    let props = Object.getOwnPropertyNames(obj);\n                    for (let prop of props) {\n                        if (data[prop] !== undefined) {\n                            let propInfo = Object.getOwnPropertyDescriptor(obj, prop);\n                            if (propInfo.writable) {\n                                if (obj[prop] instanceof Date) {\n                                    obj[prop] = this.createObject(data[prop], true);\n                                }\n                                else {\n                                    obj[prop] = this.createObject(data[prop]);\n                                }\n                            }\n                        }\n                    }\n                    return obj;\n                }\n            }\n            else {\n                let result = {};\n                for (let key in data) {\n                    result[key] = this.createObject(data[key]);\n                }\n                return result;\n            }\n        }\n        else if (transfromToDate && typeof data === \"string\") {\n            return new Date(data);\n        }\n        return data;\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.DataManager","required":false,"type":1,"isExported":true},{"code":"class Data {\n    /**\n     * The schema for the class\n     */\n    static get $schema() { return {}; }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * Get the name of the class\n     */\n    get className() {\n        return this.constructor.name;\n    }\n    /**\n     * Get a JSON for the current object\n     */\n    toJSON() {\n        let result = { $type: this.$type };\n        let props = Object.getOwnPropertyNames(this);\n        for (let prop of props) {\n            let propInfo = Object.getOwnPropertyDescriptor(this, prop);\n            if (propInfo.writable) {\n                result[prop] = this[prop];\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Aventus.DataManager","isStrong":true}],"fullName":"Aventus.Data","required":false,"type":1,"isExported":true},{"code":"class RamError extends GenericError {\n}\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Aventus.RamErrorCode","isStrong":true}],"fullName":"Aventus.RamError","required":false,"type":1,"isExported":true},{"code":"class ResultRamWithError extends ResultWithError {\n}\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"Aventus.RamError","isStrong":true}],"fullName":"Aventus.ResultRamWithError","required":false,"type":1,"isExported":true},{"code":"class Socket {\n    options;\n    waitingList = {};\n    multipltWaitingList = {};\n    timeoutError;\n    memoryBeforeOpen = [];\n    socket;\n    constructor() {\n        this._configure(this.configure({}));\n    }\n    /**\n     * Configure a new Websocket\n     */\n    _configure(options = {}) {\n        if (!options.host) {\n            options.host = window.location.hostname;\n        }\n        if (!options.hasOwnProperty('useHttps')) {\n            options.useHttps = window.location.protocol == \"https:\";\n        }\n        if (!options.port) {\n            if (window.location.port) {\n                options.port = parseInt(window.location.port);\n            }\n            else {\n                options.port = options.useHttps ? 443 : 80;\n            }\n        }\n        if (!options.routes) {\n            options.routes = {};\n        }\n        if (!options.socketName) {\n            options.socketName = \"\";\n        }\n        this.options = options;\n    }\n    /**\n     * Add a new route to listen to the websocket\n     */\n    addRoute(newRoute) {\n        if (!this.options.routes.hasOwnProperty(newRoute.channel)) {\n            this.options.routes[newRoute.channel] = [];\n        }\n        this.options.routes[newRoute.channel].push(newRoute);\n    }\n    /**\n     * The route to remove\n     * @param route - The route to remove\n     */\n    removeRoute(route) {\n        let index = this.options.routes[route.channel].indexOf(route);\n        if (index != -1) {\n            this.options.routes[route.channel].splice(index, 1);\n        }\n    }\n    openCallback;\n    /**\n     * Try to open the websocket\n     */\n    open() {\n        return new Promise((resolve) => {\n            try {\n                if (this.socket) {\n                    this.socket.close();\n                }\n                let protocol = \"ws\";\n                if (this.options.useHttps) {\n                    protocol = \"wss\";\n                }\n                let url = protocol + \"://\" + this.options.host + \":\" + this.options.port + \"/ws/\" + this.options.socketName;\n                this.log(url);\n                this.openCallback = (isOpen) => {\n                    resolve(isOpen);\n                };\n                this.socket = new WebSocket(url);\n                this.socket.onopen = this._onOpen.bind(this);\n                this.socket.onclose = this._onClose.bind(this);\n                this.socket.onerror = this._onError.bind(this);\n                this.socket.onmessage = this.onMessage.bind(this);\n            }\n            catch (e) {\n                console.log(e);\n                resolve(false);\n            }\n        });\n    }\n    jsonReplacer(key, value) {\n        if (this[key] instanceof Date && this[key].getFullYear() < 100) {\n            return \"0001-01-01T00:00:00\";\n        }\n        return value;\n    }\n    /**\n     * Send a message though the websocket\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param options the options to add to the message (typically the uid)\n     */\n    sendMessage(channelName, data = null, options = {}) {\n        if (this.socket && this.socket.readyState == 1) {\n            let message = {\n                channel: channelName,\n            };\n            for (let key in options) {\n                message[key] = options[key];\n            }\n            if (data) {\n                message.data = data;\n                this.log(message);\n                if (typeof data != 'string') {\n                    message.data = JSON.stringify(data, this.jsonReplacer);\n                }\n            }\n            else {\n                this.log(message);\n            }\n            this.socket.send(JSON.stringify(message));\n        }\n        else {\n            this.log('Socket not ready ! Please ensure that it is open and ready to send message');\n            this.memoryBeforeOpen.push({\n                channelName: channelName,\n                data: data,\n                options: options\n            });\n        }\n    }\n    /**\n     * Send a message though the websocket and wait one answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWait(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.waitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    ;\n    /**\n     * Send a message though the websocket and wait answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWaitMultiple(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.multipltWaitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    /**\n     * Check if socket is ready\n     */\n    isReady() {\n        if (this.socket && this.socket.readyState == 1) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Callback when the websocket connection is open\n     */\n    onOpen() {\n    }\n    _onOpen() {\n        if (this.socket && this.socket.readyState == 1) {\n            if (this.openCallback) {\n                this.openCallback(true);\n                this.openCallback = null;\n            }\n            this.log('Connection successfully established !' + this.options.host + \":\" + this.options.port);\n            window.clearTimeout(this.timeoutError);\n            this.onOpen();\n            for (let i = 0; i < this.memoryBeforeOpen.length; i++) {\n                this.sendMessage(this.memoryBeforeOpen[i].channelName, this.memoryBeforeOpen[i].data, this.memoryBeforeOpen[i].options);\n            }\n            this.memoryBeforeOpen = [];\n        }\n        else {\n            if (this.openCallback) {\n                this.openCallback(false);\n                this.openCallback = null;\n            }\n        }\n    }\n    errorOccur;\n    /**\n     * Callback called when the socket as an error\n     */\n    onError(event) {\n    }\n    _onError(event) {\n        this.errorOccur = true;\n        if (this.openCallback) {\n            this.openCallback(false);\n            this.openCallback = null;\n            return;\n        }\n        this.log('An error has occured');\n        this.onError(event);\n    }\n    /**\n     * Callback called when the connection closed without calling the close function\n     * By default the socket will try to reconnect each 5000ms\n     */\n    onClose(event) {\n        let reopenInterval = setInterval(async () => {\n            console.warn(\"try reopen socket \");\n            if (await this.open()) {\n                clearInterval(reopenInterval);\n            }\n        }, 5000);\n    }\n    _onClose(event) {\n        if (this.errorOccur) {\n            this.errorOccur = false;\n            return;\n        }\n        this.log('Closing connection');\n        this.onClose(event);\n    }\n    /**\n     * Close the current connection\n     */\n    close() {\n        if (this.socket) {\n            this.socket.onclose = null;\n            this.socket.onerror = null;\n            this.socket.onmessage = null;\n            this.socket.onopen = null;\n            this.socket.close();\n            delete this.socket;\n        }\n    }\n    onMessage(event) {\n        let response = JSON.parse(event.data);\n        this.log(response);\n        response.data = JSON.parse(response.data);\n        if (this.options.routes.hasOwnProperty(response.channel)) {\n            this.options.routes[response.channel].forEach(element => {\n                element.callback(response.data);\n            });\n        }\n        if (response.uid) {\n            if (this.waitingList.hasOwnProperty(response.uid)) {\n                let group = this.waitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    group[response.channel](response.data);\n                }\n                delete this.waitingList[response.uid];\n            }\n            else if (this.multipltWaitingList.hasOwnProperty(response.uid)) {\n                let group = this.multipltWaitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    try {\n                        group[response.channel](response.data);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                }\n                delete this.multipltWaitingList[response.uid];\n            }\n        }\n    }\n    /**\n     * Print a msg inside the console\n     */\n    log(message) {\n        if (this.options.log) {\n            const now = new Date();\n            const hours = (now.getHours()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const minutes = (now.getMinutes()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const seconds = (now.getSeconds()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            if (message instanceof Object) {\n                let cloneMessage = JSON.parse(JSON.stringify(message, this.jsonReplacer));\n                if (cloneMessage.data && typeof cloneMessage.data == 'string') {\n                    cloneMessage.data = JSON.parse(cloneMessage.data);\n                }\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, cloneMessage);\n            }\n            else {\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, message);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.ISocket","isStrong":true},{"fullName":"Aventus.SocketOptions","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.SocketMessage","isStrong":false},{"fullName":"Event","isStrong":false},{"fullName":"MessageEvent","isStrong":false}],"fullName":"Aventus.Socket","required":false,"type":1,"isExported":true}],"existing":[{"fullName":"Aventus.Loop","dependances":[]},{"fullName":"Aventus.ActionEventCallback","dependances":[]},{"fullName":"Aventus.ActionEventListener","dependances":[]},{"fullName":"Aventus.ActionBindings","dependances":[]},{"fullName":"Aventus.ActionInjection","dependances":[]},{"fullName":"Aventus.ActionChange","dependances":[]},{"fullName":"Aventus.ActionEvent","dependances":[]},{"fullName":"Aventus.ContextValues","dependances":[]},{"fullName":"Aventus.Actions","dependances":[]},{"fullName":"Aventus.ContextSchema","dependances":[]},{"fullName":"Aventus.WebComponentTemplateHTML","dependances":[]},{"fullName":"Aventus.DefaultComponent","dependances":[]},{"fullName":"Aventus.DebuggerConfig","dependances":[]},{"fullName":"Aventus.Subscriber","dependances":[]},{"fullName":"Aventus.StateAskChangeFct","dependances":[]},{"fullName":"Aventus.StateInactivationFct","dependances":[]},{"fullName":"Aventus.StateActivationFct","dependances":[]},{"fullName":"Aventus.StateSlug","dependances":[]},{"fullName":"Aventus.StateAction","dependances":[]},{"fullName":"Aventus.SocketMessage","dependances":[]},{"fullName":"Aventus.SocketRoute","dependances":[]},{"fullName":"Aventus.SocketOptions","dependances":[]},{"fullName":"Aventus.ISocket","dependances":[]},{"fullName":"Aventus.RamWsCallback","dependances":[]},{"fullName":"Aventus.RamWsRoute","dependances":[]},{"fullName":"Aventus.RamWsRoutes","dependances":[]},{"fullName":"Aventus.KeysObject","dependances":[]},{"fullName":"Aventus.RamItem","dependances":[]},{"fullName":"Aventus.RamSubscribers","dependances":[]},{"fullName":"Aventus.IRamAction","dependances":[]},{"fullName":"Aventus.IRam","dependances":[]},{"fullName":"Aventus.ResourceLoaderHeadOptions","dependances":[]},{"fullName":"Aventus.ResourceLoaderOptions","dependances":[]},{"fullName":"Aventus.WindowResizeObserver","dependances":[]},{"fullName":"Aventus.ResizeObserverOptions","dependances":[]},{"fullName":"Aventus.Pointer","dependances":[]},{"fullName":"Aventus.HttpRequestOptions","dependances":[]},{"fullName":"Aventus.InternalPointerEvent","dependances":[{"fullName":"Event","isStrong":true}]},{"fullName":"Aventus.InternalCustomFunction","dependances":[]},{"fullName":"Aventus.PressManagerState","dependances":[]},{"fullName":"Aventus.PressManagerOptions","dependances":[]},{"fullName":"Aventus.Coordinate","dependances":[]},{"fullName":"Aventus.DragAndDropOptions","dependances":[]},{"fullName":"Aventus.AnimationOptions","dependances":[]},{"fullName":"Aventus.IData","dependances":[]}]}
>>>>>>> ae504ff (WIP)
=======
{"namespace":"Aventus","available":[{"code":"Object.defineProperty(window, \"AvInstance\", {\r\n\tget() {return Aventus.Instance;}\r\n})","dependances":[],"fullName":"!staticClass_1f694879-2a92-466d-83ed-3abc8cdfe10f","required":true,"noNamespace":"before","type":0,"isExported":false,"convertibleName":""},{"code":" ","dependances":[],"fullName":"!staticClass_9a055541-a3f6-4064-91dd-f04e0ee270d3","required":true,"noNamespace":"before","type":0,"isExported":false,"convertibleName":""},{"code":"class WebComponentTemplateInstance {\n    context;\n    content;\n    actions;\n    component;\n    _components;\n    firstRenderUniqueCb = {};\n    firstRenderCb = [];\n    fctsToRemove = [];\n    loopRegisteries = {};\n    firstChild;\n    lastChild;\n    loops = [];\n    constructor(context, content, actions, component, loops) {\n        this.context = context;\n        this.content = content;\n        this.actions = actions;\n        this.component = component;\n        this.loops = loops;\n        this.firstChild = content.firstChild;\n        this.lastChild = content.lastChild;\n        this.transformActionsListening();\n        this.selectElements();\n        this.bindEvents();\n    }\n    render() {\n        for (let cb of this.firstRenderCb) {\n            cb();\n        }\n        for (let key in this.firstRenderUniqueCb) {\n            this.firstRenderUniqueCb[key]();\n        }\n        this.renderSubTemplate();\n        this.context.isRendered = true;\n    }\n    destructor() {\n        this.firstChild.remove();\n        this.context.destructor();\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__watchActions'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__watchActions'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    selectElements() {\n        this._components = {};\n        let idEls = Array.from(this.content.querySelectorAll('[_id]'));\n        for (let idEl of idEls) {\n            let id = idEl.attributes['_id'].value;\n            if (!this._components[id]) {\n                this._components[id] = [];\n            }\n            this._components[id].push(idEl);\n        }\n        if (this.actions.elements) {\n            for (let element of this.actions.elements) {\n                let components = [];\n                for (let id of element.ids) {\n                    if (this._components[id]) {\n                        components = [...components, ...this._components[id]];\n                    }\n                }\n                if (element.isArray) {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components);\n                }\n                else {\n                    WebComponentTemplate.setValueToItem(element.name, this.component, components[0]);\n                }\n            }\n        }\n    }\n    bindEvents() {\n        if (this.actions.events) {\n            for (let event of this.actions.events) {\n                this.bindEvent(event);\n            }\n        }\n        if (this.actions.pressEvents) {\n            for (let event of this.actions.pressEvents) {\n                this.bindPressEvent(event);\n            }\n        }\n    }\n    bindEvent(event) {\n        if (event.isCallback) {\n            for (let el of this._components[event.id]) {\n                let cb = WebComponentTemplate.getValueFromItem(event.eventName, el);\n                cb?.add((...args) => {\n                    event.fct(this.context, args);\n                });\n            }\n        }\n        else {\n            for (let el of this._components[event.id]) {\n                el.addEventListener(event.eventName, (e) => { event.fct(e, this.context); });\n            }\n        }\n    }\n    bindPressEvent(event) {\n        let id = event['id'];\n        if (id) {\n            let clone = {};\n            for (let temp in event) {\n                if (temp != 'id') {\n                    if (event[temp] instanceof Function) {\n                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };\n                    }\n                    else {\n                        clone[temp] = event[temp];\n                    }\n                }\n            }\n            clone.element = this._components[id];\n            new PressManager(clone);\n        }\n    }\n    transformActionsListening() {\n        if (this.actions.content) {\n            for (let name in this.actions.content) {\n                for (let change of this.actions.content[name]) {\n                    this.transformChangeAction(name, change);\n                }\n            }\n        }\n        if (this.actions.injection) {\n            for (let name in this.actions.injection) {\n                for (let injection of this.actions.injection[name]) {\n                    this.transformInjectionAction(name, injection);\n                }\n            }\n        }\n        if (this.actions.bindings) {\n            for (let name in this.actions.bindings) {\n                for (let binding of this.actions.bindings[name]) {\n                    this.transformBindigAction(name, binding);\n                }\n            }\n        }\n    }\n    transformChangeAction(name, change) {\n        let key = change.id + \"_\" + change.attrName;\n        if (change.attrName == \"@HTML\") {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.innerHTML = change.render(this.context.c);\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.innerHTML = change.render(this.context.c);\n                    }\n                };\n            }\n        }\n        else if (change.isBool) {\n            this.context.addChange(name, () => {\n                for (const el of this._components[change.id]) {\n                    if (this.context.c[name]) {\n                        el.setAttribute(change.attrName, \"true\");\n                    }\n                    else {\n                        el.removeAttribute(change.attrName);\n                    }\n                }\n            });\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        if (this.context.c[name]) {\n                            el.setAttribute(change.attrName, \"true\");\n                        }\n                        else {\n                            el.removeAttribute(change.attrName);\n                        }\n                    }\n                };\n            }\n        }\n        else {\n            if (change.path) {\n                this.context.addChange(name, (path) => {\n                    if (WebComponentTemplate.validatePath(path, change.path)) {\n                        for (const el of this._components[change.id]) {\n                            el.setAttribute(change.attrName, change.render(this.context.c));\n                        }\n                    }\n                });\n            }\n            else {\n                this.context.addChange(name, (path) => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                });\n            }\n            if (!this.firstRenderUniqueCb[key]) {\n                this.firstRenderUniqueCb[key] = () => {\n                    for (const el of this._components[change.id]) {\n                        el.setAttribute(change.attrName, change.render(this.context.c));\n                    }\n                };\n            }\n        }\n    }\n    transformInjectionAction(name, injection) {\n        if (injection.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, injection.path)) {\n                    for (const el of this._components[injection.id]) {\n                        el[injection.injectionName] = injection.inject(this.context.c);\n                    }\n                }\n            });\n        }\n        else {\n            this.context.addChange(name, (path) => {\n                for (const el of this._components[injection.id]) {\n                    el[injection.injectionName] = injection.inject(this.context.c);\n                }\n            });\n        }\n        this.firstRenderCb.push(() => {\n            for (const el of this._components[injection.id]) {\n                el[injection.injectionName] = injection.inject(this.context.c);\n            }\n        });\n    }\n    transformBindigAction(name, binding) {\n        if (binding.path) {\n            this.context.addChange(name, (path) => {\n                if (WebComponentTemplate.validatePath(path, binding.path)) {\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    for (const el of this._components[binding.id]) {\n                        WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                    }\n                }\n            });\n        }\n        else {\n            binding.path = name;\n            this.context.addChange(name, (path) => {\n                let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                for (const el of this._components[binding.id]) {\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        if (binding.isCallback) {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        let cb = WebComponentTemplate.getValueFromItem(fct, el);\n                        cb?.add((value) => {\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, value);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n        else {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        el.addEventListener(fct, (e) => {\n                            let valueToSet = WebComponentTemplate.getValueFromItem(binding.valueName, e.target);\n                            WebComponentTemplate.setValueToItem(binding.path, this.context.c, valueToSet);\n                        });\n                    }\n                    let valueToSet = WebComponentTemplate.getValueFromItem(binding.path, this.context.c);\n                    WebComponentTemplate.setValueToItem(binding.valueName, el, valueToSet);\n                }\n            });\n        }\n    }\n    renderSubTemplate() {\n        for (let loop of this.loops) {\n            let localContext = JSON.parse(JSON.stringify(this.context.schema));\n            localContext.loops.push({\n                data: loop.data,\n                index: loop.index,\n                item: loop.item\n            });\n            this.renderLoop(loop, localContext);\n            this.registerLoopWatchEvent(loop, localContext);\n        }\n    }\n    renderLoop(loop, localContext) {\n        if (this.loopRegisteries[loop.anchorId]) {\n            for (let item of this.loopRegisteries[loop.anchorId]) {\n                item.destructor();\n            }\n        }\n        this.loopRegisteries[loop.anchorId] = [];\n        let result = WebComponentTemplate.getValueFromItem(loop.data, this.context.c);\n        let anchor = this._components[loop.anchorId][0];\n        for (let i = 0; i < result.length; i++) {\n            let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: i }]);\n            let content = loop.template.template.content.cloneNode(true);\n            let actions = loop.template.actions;\n            let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n            instance.render();\n            anchor.parentNode.insertBefore(instance.content, anchor);\n            this.loopRegisteries[loop.anchorId].push(instance);\n        }\n    }\n    registerLoopWatchEvent(loop, localContext) {\n        let fullPath = loop.data;\n        let watchName = fullPath.split(\".\")[0];\n        if (!this.component['__watchActions'][watchName]) {\n            this.component['__watchActions'][watchName] = [];\n        }\n        let regex = new RegExp(fullPath.replace(/\\./g, \"\\\\.\") + \"\\\\[(\\\\d+?)\\\\]$\");\n        this.component['__watchActions'][watchName].push((element, action, path, value) => {\n            if (path == fullPath) {\n                this.renderLoop(loop, localContext);\n                return;\n            }\n            regex.lastIndex = 0;\n            let result = regex.exec(path);\n            if (result) {\n                let registry = this.loopRegisteries[loop.anchorId];\n                let index = Number(result[1]);\n                if (action == WatchAction.CREATED) {\n                    let context = new WebComponentTemplateContext(this.component, localContext, [{ name: loop.index, value: index }]);\n                    let content = loop.template.template.content.cloneNode(true);\n                    let actions = loop.template.actions;\n                    let instance = new WebComponentTemplateInstance(context, content, actions, this.component, loop.template.loops);\n                    instance.render();\n                    let anchor;\n                    if (index < registry.length) {\n                        anchor = registry[index].firstChild;\n                    }\n                    else {\n                        anchor = this._components[loop.anchorId][0];\n                    }\n                    anchor.parentNode.insertBefore(instance.content, anchor);\n                    registry.splice(index, 0, instance);\n                    for (let i = index + 1; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] + 1;\n                    }\n                }\n                else if (action == WatchAction.UPDATED) {\n                    registry[index].render();\n                }\n                else if (action == WatchAction.DELETED) {\n                    registry[index].destructor();\n                    registry.splice(index, 1);\n                    for (let i = index; i < registry.length; i++) {\n                        registry[i].context.c[loop.index] = registry[i].context.c[loop.index] - 1;\n                    }\n                }\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.ActionEvent","isStrong":false},{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.ActionChange","isStrong":false},{"fullName":"Aventus.ActionInjection","isStrong":false},{"fullName":"Aventus.ActionBindings","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateInstance","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class WebComponentTemplate {\n    static setValueToItem(path, obj, value) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (!obj[split]) {\n                obj[split] = {};\n            }\n            obj = obj[split];\n        }\n        obj[splitted[splitted.length - 1]] = value;\n    }\n    static getValueFromItem(path, obj) {\n        let splitted = path.split(\".\");\n        for (let i = 0; i < splitted.length - 1; i++) {\n            let split = splitted[i];\n            if (typeof obj[split] !== 'object') {\n                return undefined;\n            }\n            obj = obj[split];\n        }\n        return obj[splitted[splitted.length - 1]];\n    }\n    static validatePath(path, pathToCheck) {\n        if (path.startsWith(pathToCheck)) {\n            return true;\n        }\n        return false;\n    }\n    htmlParts = [];\n    setHTML(data) {\n        this.htmlParts.push(data);\n    }\n    generateTemplate() {\n        this.template = document.createElement('template');\n        let currentHTML = \"<slot></slot>\";\n        let previousSlots = {\n            default: '<slot></slot>'\n        };\n        for (let htmlPart of this.htmlParts) {\n            for (let blockName in htmlPart.blocks) {\n                if (!previousSlots.hasOwnProperty(blockName)) {\n                    throw \"can't found slot with name \" + blockName;\n                }\n                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);\n            }\n            for (let slotName in htmlPart.slots) {\n                previousSlots[slotName] = htmlPart.slots[slotName];\n            }\n        }\n        this.template.innerHTML = currentHTML;\n    }\n    setTemplate(template) {\n        this.template = document.createElement('template');\n        this.template.innerHTML = template;\n    }\n    contextSchema = {\n        globals: [],\n        locals: [],\n        loops: []\n    };\n    template;\n    actions = {};\n    loops = [];\n    setActions(actions) {\n        if (!this.actions) {\n            this.actions = actions;\n        }\n        else {\n            if (actions.elements) {\n                if (!this.actions.elements) {\n                    this.actions.elements = [];\n                }\n                this.actions.elements = [...actions.elements, ...this.actions.elements];\n            }\n            if (actions.events) {\n                if (!this.actions.events) {\n                    this.actions.events = [];\n                }\n                this.actions.events = [...actions.events, ...this.actions.events];\n            }\n            if (actions.pressEvents) {\n                if (!this.actions.pressEvents) {\n                    this.actions.pressEvents = [];\n                }\n                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];\n            }\n            if (actions.content) {\n                if (!this.actions.content) {\n                    this.actions.content = actions.content;\n                }\n                else {\n                    for (let contextProp in actions.content) {\n                        if (!this.actions.content[contextProp]) {\n                            this.actions.content[contextProp] = actions.content[contextProp];\n                        }\n                        else {\n                            this.actions.content[contextProp] = { ...actions.content[contextProp], ...this.actions.content[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.injection) {\n                if (!this.actions.injection) {\n                    this.actions.injection = actions.injection;\n                }\n                else {\n                    for (let contextProp in actions.injection) {\n                        if (!this.actions.injection[contextProp]) {\n                            this.actions.injection[contextProp] = actions.injection[contextProp];\n                        }\n                        else {\n                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.bindings) {\n                if (!this.actions.bindings) {\n                    this.actions.bindings = actions.bindings;\n                }\n                else {\n                    for (let contextProp in actions.bindings) {\n                        if (!this.actions.bindings[contextProp]) {\n                            this.actions.bindings[contextProp] = actions.bindings[contextProp];\n                        }\n                        else {\n                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };\n                        }\n                    }\n                }\n            }\n        }\n    }\n    setSchema(contextSchema) {\n        if (contextSchema.globals) {\n            this.contextSchema.globals = [...this.contextSchema.globals, ...contextSchema.globals];\n        }\n        if (contextSchema.locals) {\n            this.contextSchema.locals = [...this.contextSchema.locals, ...contextSchema.locals];\n        }\n        if (contextSchema.loops) {\n            this.contextSchema.loops = [...this.contextSchema.loops, ...contextSchema.loops];\n        }\n    }\n    createInstance(component) {\n        let context = new WebComponentTemplateContext(component, this.contextSchema, []);\n        let content = this.template.content.cloneNode(true);\n        let actions = this.actions;\n        let instance = new WebComponentTemplateInstance(context, content, actions, component, this.loops);\n        return instance;\n    }\n    addLoop(loop) {\n        this.loops.push(loop);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponentTemplateHTML","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false},{"fullName":"HTMLTemplateElement","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.WebComponentTemplateContext","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"WebComponentTemplateInstance","isStrong":false}],"fullName":"Aventus.WebComponentTemplate","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class WebComponentTemplateContext {\n    __changes = {};\n    component;\n    fctsToRemove = [];\n    c = {};\n    isRendered = false;\n    schema;\n    constructor(component, schema, locals) {\n        this.component = component;\n        this.schema = { ...schema };\n        this.schema.locals = [...this.schema.locals, ...locals];\n        5;\n        this.buildSchema();\n    }\n    destructor() {\n        for (let toRemove of this.fctsToRemove) {\n            let index = this.component['__onChangeFct'][toRemove.name].indexOf(toRemove.fct);\n            if (index != -1) {\n                this.component['__onChangeFct'][toRemove.name].splice(index, 1);\n            }\n        }\n    }\n    buildSchema() {\n        for (let global of this.schema.globals) {\n            this.createGlobal(global);\n        }\n        for (let loop of this.schema.loops) {\n            this.createLoop(loop);\n        }\n        for (let local of this.schema.locals) {\n            this.createLocal(local);\n        }\n    }\n    createGlobal(global) {\n        let comp = this.component;\n        Object.defineProperty(this.c, global, {\n            get() {\n                return WebComponentTemplate.getValueFromItem(global, comp);\n            },\n            set(value) {\n                WebComponentTemplate.setValueToItem(global, comp, value);\n            }\n        });\n        let name = global.split(\".\")[0];\n        this.__changes[name] = [];\n        if (!this.component['__onChangeFct'][name]) {\n            this.component['__onChangeFct'][name] = [];\n        }\n        let fct = (path) => {\n            if (this.isRendered) {\n                for (let change of this.__changes[name]) {\n                    change(path);\n                }\n            }\n        };\n        this.fctsToRemove.push({ name, fct });\n        this.component['__onChangeFct'][name].push(fct);\n    }\n    createLoop(loop) {\n        Object.defineProperty(this.c, loop.item, {\n            get() {\n                let indexValue = this[loop.index];\n                return WebComponentTemplate.getValueFromItem(loop.data, this)[indexValue];\n            }\n        });\n        let name = loop.data.split(\".\")[0];\n        this.__changes[loop.item] = [];\n        this.__changes[name].push((path) => {\n            if (this.isRendered) {\n                let currentPath = `${loop.data}[${this.c[loop.index]}]`;\n                if (path.startsWith(currentPath)) {\n                    let localPath = path.replace(currentPath, loop.item);\n                    for (let change of this.__changes[loop.item]) {\n                        change(localPath);\n                    }\n                }\n            }\n        });\n    }\n    createLocal(local) {\n        let localValue = local.value;\n        let changes = this.__changes;\n        Object.defineProperty(this.c, local.name, {\n            get() {\n                return localValue;\n            },\n            set(value) {\n                localValue = value;\n                if (changes[local.name]) {\n                    for (let change of changes[local.name]) {\n                        change(local.name);\n                    }\n                }\n            }\n        });\n    }\n    addChange(on, fct) {\n        if (!this.__changes[on]) {\n            this.__changes[on] = [];\n        }\n        this.__changes[on].push(fct);\n    }\n}\n","dependances":[{"fullName":"Aventus.WebComponent","isStrong":false},{"fullName":"Aventus.ContextValues","isStrong":false},{"fullName":"Aventus.ContextSchema","isStrong":false}],"fullName":"Aventus.WebComponentTemplateContext","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class WebComponent extends HTMLElement {\n    /**\n     * Add attributes informations\n     */\n    static get observedAttributes() {\n        return [];\n    }\n    _first;\n    _isReady;\n    /**\n     * Determine if the component is ready (postCreation done)\n     */\n    get isReady() {\n        return this._isReady;\n    }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the name of the component class\n     */\n    getClassName() {\n        return this.constructor.name;\n    }\n    /**\n    * Get the unique type for the data. Define it as the namespace + class name\n    */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    __onChangeFct = {};\n    __watch;\n    __watchActions = {};\n    __watchActionsCb = {};\n    __pressManagers = [];\n    __isDefaultState = true;\n    __defaultActiveState = new Map();\n    __defaultInactiveState = new Map();\n    __statesList = {};\n    constructor() {\n        super();\n        if (this.constructor == WebComponent) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this._first = true;\n        this._isReady = false;\n        this.__renderTemplate();\n        this.__registerWatchesActions();\n        this.__registerPropertiesActions();\n        this.__createStates();\n        this.__subscribeState();\n    }\n    /**\n     * Remove all listeners\n     * State + press\n     */\n    destructor() {\n        WebComponentInstance.removeInstance(this);\n        this.__unsubscribeState();\n        for (let press of this.__pressManagers) {\n            press.destroy();\n        }\n        // TODO add missing info for destructor();\n    }\n    __addWatchesActions(name, fct) {\n        if (!this.__watchActions[name]) {\n            this.__watchActions[name] = [];\n            this.__watchActionsCb[name] = (action, path, value) => {\n                for (let fct of this.__watchActions[name]) {\n                    fct(this, action, path, value);\n                }\n                if (this.__onChangeFct[name]) {\n                    for (let fct of this.__onChangeFct[name]) {\n                        fct(path);\n                    }\n                }\n            };\n        }\n        if (fct) {\n            this.__watchActions[name].push(fct);\n        }\n    }\n    __registerWatchesActions() {\n        if (Object.keys(this.__watchActions).length > 0) {\n            if (!this.__watch) {\n                this.__watch = Watcher.get({}, (type, path, element) => {\n                    let action = this.__watchActionsCb[path.split(\".\")[0]] || this.__watchActionsCb[path.split(\"[\")[0]];\n                    action(type, path, element);\n                });\n            }\n        }\n    }\n    __addPropertyActions(name, fct) {\n        if (!this.__onChangeFct[name]) {\n            this.__onChangeFct[name] = [];\n        }\n        if (fct) {\n            this.__onChangeFct[name].push(() => {\n                fct(this);\n            });\n        }\n    }\n    __registerPropertiesActions() { }\n    static __style = ``;\n    static __template;\n    __templateInstance;\n    styleBefore() {\n        return [\"@general\"];\n    }\n    styleAfter() {\n        return [];\n    }\n    __getStyle() {\n        return [WebComponent.__style];\n    }\n    __getHtml() { }\n    __getStatic() {\n        return WebComponent;\n    }\n    static __styleSheets = {};\n    __renderStyles() {\n        let sheets = {};\n        let befores = this.styleBefore();\n        for (let before of befores) {\n            let sheet = Style.get(before);\n            if (sheet) {\n                sheets[before] = sheet;\n            }\n        }\n        let localStyle = new CSSStyleSheet();\n        let styleTxt = this.__getStyle().join(\"\\r\\n\");\n        if (styleTxt.length > 0) {\n            localStyle.replace(styleTxt);\n            sheets['@local'] = localStyle;\n        }\n        let afters = this.styleAfter();\n        for (let after of afters) {\n            let sheet = Style.get(after);\n            if (sheet) {\n                sheets[after] = sheet;\n            }\n        }\n        return sheets;\n    }\n    __renderTemplate() {\n        let staticInstance = this.__getStatic();\n        if (!staticInstance.__template) {\n            staticInstance.__template = new WebComponentTemplate();\n            this.__getHtml();\n            this.__registerTemplateAction();\n            staticInstance.__template.generateTemplate();\n            staticInstance.__styleSheets = this.__renderStyles();\n        }\n        this.__templateInstance = staticInstance.__template.createInstance(this);\n        let shadowRoot = this.attachShadow({ mode: 'open' });\n        shadowRoot.adoptedStyleSheets = Object.values(staticInstance.__styleSheets);\n        this.shadowRoot.appendChild(this.__templateInstance.content);\n        customElements.upgrade(this.shadowRoot);\n    }\n    __registerTemplateAction() {\n    }\n    connectedCallback() {\n        if (this._first) {\n            WebComponentInstance.addInstance(this);\n            this._first = false;\n            this.__defaultValues();\n            this.__upgradeAttributes();\n            this.__templateInstance.render();\n            setTimeout(() => {\n                this.postCreation();\n                this._isReady = true;\n                this.dispatchEvent(new CustomEvent('postCreationDone'));\n            });\n        }\n    }\n    __defaultValues() { }\n    __upgradeAttributes() { }\n    __listBoolProps() {\n        return [];\n    }\n    __upgradeProperty(prop) {\n        let boolProps = this.__listBoolProps();\n        if (boolProps.indexOf(prop) != -1) {\n            if (this.hasAttribute(prop) && (this.getAttribute(prop) === \"true\" || this.getAttribute(prop) === \"\")) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n            else {\n                this.removeAttribute(prop);\n                this[prop] = false;\n            }\n        }\n        else {\n            if (this.hasAttribute(prop)) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n        }\n    }\n    __getStateManager(managerClass) {\n        let mClass;\n        if (managerClass instanceof StateManager) {\n            mClass = managerClass;\n        }\n        else {\n            mClass = Instance.get(managerClass);\n        }\n        return mClass;\n    }\n    __addActiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultActiveState.has(mClass)) {\n            this.__defaultActiveState.set(mClass, []);\n        }\n        this.__defaultActiveState.get(mClass).push(cb);\n    }\n    __addInactiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultInactiveState.has(mClass)) {\n            this.__defaultInactiveState.set(mClass, []);\n        }\n        this.__defaultInactiveState.get(mClass).push(cb);\n    }\n    __addActiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).active.push(cb);\n    }\n    __addInactiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).inactive.push(cb);\n    }\n    __addAskChangeState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass).askChange.push(cb);\n    }\n    __createStates() { }\n    __createStatesList(statePattern, managerClass) {\n        if (!this.__statesList[statePattern]) {\n            this.__statesList[statePattern] = new Map();\n        }\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__statesList[statePattern].has(mClass)) {\n            this.__statesList[statePattern].set(mClass, {\n                active: [],\n                inactive: [],\n                askChange: []\n            });\n        }\n    }\n    __inactiveDefaultState(managerClass) {\n        if (this.__isDefaultState) {\n            this.__isDefaultState = false;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultInactiveState.has(mClass)) {\n                let fcts = this.__defaultInactiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __activeDefaultState(nextStep, managerClass) {\n        if (!this.__isDefaultState) {\n            for (let pattern in this.__statesList) {\n                if (StateManager.canBeActivate(pattern, nextStep)) {\n                    let mClass = this.__getStateManager(managerClass);\n                    if (this.__statesList[pattern].has(mClass)) {\n                        return;\n                    }\n                }\n            }\n            this.__isDefaultState = true;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultActiveState.has(mClass)) {\n                let fcts = this.__defaultActiveState.get(mClass);\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __subscribeState() {\n        if (!this.isReady && this.__stateCleared) {\n            return;\n        }\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.subscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n    }\n    __stateCleared;\n    __unsubscribeState() {\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                managerClass.unsubscribe(route, this.__statesList[route].get(managerClass));\n            }\n        }\n        this.__stateCleared = true;\n    }\n    dateToString(d) {\n        if (d instanceof Date) {\n            return new Date(d.getTime() - (d.getTimezoneOffset() * 60000)).toISOString().split(\"T\")[0];\n        }\n        return null;\n    }\n    dateTimeToString(dt) {\n        if (dt instanceof Date) {\n            return new Date(dt.getTime() - (dt.getTimezoneOffset() * 60000)).toISOString().slice(0, -1);\n        }\n        return null;\n    }\n    stringToDate(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    stringToDateTime(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    getBoolean(val) {\n        if (val === true || val === 1 || val === 'true' || val === '') {\n            return true;\n        }\n        else if (val === false || val === 0 || val === 'false' || val === null || val === undefined) {\n            return false;\n        }\n        console.error(\"error parsing boolean value \" + val);\n        return false;\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue !== newValue || !this.isReady) {\n            if (this.__onChangeFct.hasOwnProperty(name)) {\n                for (let fct of this.__onChangeFct[name]) {\n                    fct('');\n                }\n            }\n        }\n    }\n    remove() {\n        super.remove();\n        this.postDestruction();\n    }\n    /**\n     * Function triggered when the component is removed from the DOM\n     */\n    postDestruction() { }\n    /**\n     * Function triggered the first time the component is rendering inside DOM\n     */\n    postCreation() { }\n    /**\n     * Find a parent by tagname if exist\n     */\n    findParentByTag(tagname, untilNode) {\n        return ElementExtension.findParentByTag(this, tagname, untilNode);\n    }\n    /**\n     * Find a parent by class name if exist\n     */\n    findParentByClass(classname, untilNode) {\n        return ElementExtension.findParentByClass(this, classname, untilNode);\n    }\n    /**\n     * Find a parent by type if exist\n     */\n    findParentByType(type, untilNode) {\n        return ElementExtension.findParentByType(this, type, untilNode);\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    findParents(tagname, untilNode) {\n        return ElementExtension.findParents(this, tagname, untilNode);\n    }\n    /**\n     * Check if element contains a child\n     */\n    containsChild(el) {\n        return ElementExtension.containsChild(this, el);\n    }\n    /**\n     * Get element inside slot\n     */\n    getElementsInSlot(slotName = null) {\n        return ElementExtension.getElementsInSlot(this, slotName);\n    }\n}\n","dependances":[{"fullName":"HTMLElement","isStrong":true},{"fullName":"Aventus.DefaultComponent","isStrong":true},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.WebComponentTemplate","isStrong":false},{"fullName":"Aventus.WebComponentTemplateInstance","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false},{"fullName":"Aventus.Style","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"Date","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.ElementExtension","isStrong":false},{"fullName":"Aventus.WebComponentInstance","isStrong":true}],"fullName":"Aventus.WebComponent","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class WebComponentInstance {\n    static __allDefinitions = [];\n    static __allInstances = [];\n    /**\n     * Last definition insert datetime\n     */\n    static lastDefinition = 0;\n    static registerDefinition(def) {\n        WebComponentInstance.lastDefinition = Date.now();\n        WebComponentInstance.__allDefinitions.push(def);\n    }\n    /**\n     * Get all sub classes of type\n     */\n    static getAllClassesOf(type) {\n        let result = [];\n        for (let def of WebComponentInstance.__allDefinitions) {\n            if (def.prototype instanceof type) {\n                result.push(def);\n            }\n        }\n        return result;\n    }\n    /**\n     * Get all registered definitions\n     */\n    static getAllDefinitions() {\n        return WebComponentInstance.__allDefinitions;\n    }\n    static addInstance(instance) {\n        this.__allInstances.push(instance);\n    }\n    static removeInstance(instance) {\n        let index = this.__allInstances.indexOf(instance);\n        if (index > -1) {\n            this.__allInstances.splice(index, 1);\n        }\n    }\n    static getAllInstances(type) {\n        let result = [];\n        for (let instance of this.__allInstances) {\n            if (instance instanceof type) {\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"WebComponent","isStrong":false}],"fullName":"Aventus.WebComponentInstance","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Style {\n    static instance;\n    static defaultStyleSheets = {\n        \"@general\": `:host{display:inline-block;box-sizing:border-box}:host *{box-sizing:border-box}`\n    };\n    static store(name, content) {\n        this.getInstance().store(name, content);\n    }\n    static get(name) {\n        return this.getInstance().get(name);\n    }\n    static load(name, url) {\n        return this.getInstance().load(name, url);\n    }\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new Style();\n        }\n        return this.instance;\n    }\n    constructor() {\n        for (let name in Style.defaultStyleSheets) {\n            this.store(name, Style.defaultStyleSheets[name]);\n        }\n    }\n    stylesheets = new Map();\n    async load(name, url) {\n        try {\n            if (!this.stylesheets.has(name) || this.stylesheets.get(name).cssRules.length == 0) {\n                let txt = await (await fetch(url)).text();\n                this.store(name, txt);\n            }\n        }\n        catch (e) {\n        }\n    }\n    store(name, content) {\n        if (!this.stylesheets.has(name)) {\n            const sheet = new CSSStyleSheet();\n            sheet.replaceSync(content);\n            this.stylesheets.set(name, sheet);\n        }\n        else {\n            this.stylesheets.get(name).replaceSync(content);\n        }\n    }\n    get(name) {\n        if (!this.stylesheets.has(name)) {\n            this.store(name, \"\");\n        }\n        return this.stylesheets.get(name);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":false}],"fullName":"Aventus.Style","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class ElementExtension {\n    /**\n     * Find a parent by tagname if exist Static.findParentByTag(this, \"av-img\")\n     */\n    static findParentByTag(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let checkFunc = (el) => {\n            return tagname.indexOf((el.nodeName || el.tagName).toLowerCase()) != -1;\n        };\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by class name if exist Static.findParentByClass(this, \"my-class-img\") = querySelector('.my-class-img')\n     */\n    static findParentByClass(element, classname, untilNode) {\n        let el = element;\n        if (!Array.isArray(classname)) {\n            classname = [classname];\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            for (let classnameTemp of classname) {\n                if (el['classList'] && el['classList'].contains(classnameTemp)) {\n                    return el;\n                }\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a parent by type if exist Static.findParentyType(this, Aventus.Img)\n     */\n    static findParentByType(element, type, untilNode) {\n        let el = element;\n        let checkFunc = (el) => {\n            return false;\n        };\n        if (typeof type == \"function\" && type['prototype']['constructor']) {\n            checkFunc = (el) => {\n                if (el instanceof type) {\n                    return true;\n                }\n                return false;\n            };\n        }\n        else {\n            console.error(\"you must provide a class inside this function\");\n            return null;\n        }\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (checkFunc(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    static findParents(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let result = [];\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (tagname.indexOf((el.nodeName || el['tagName']).toLowerCase()) != -1) {\n                result.push(el);\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Check if element contains a child\n     */\n    static containsChild(element, child) {\n        var rootScope = element.getRootNode();\n        var elScope = child.getRootNode();\n        while (elScope != rootScope) {\n            if (!elScope['host']) {\n                return false;\n            }\n            child = elScope['host'];\n            elScope = elScope['host'].getRootNode();\n        }\n        return element.contains(child);\n    }\n    /**\n     * Get element inside slot\n     */\n    static getElementsInSlot(element, slotName = null) {\n        if (element.shadowRoot) {\n            let slotEl;\n            if (slotName) {\n                slotEl = element.shadowRoot.querySelector('slot[name=\"' + slotName + '\"]');\n            }\n            else {\n                slotEl = element.shadowRoot.querySelector(\"slot\");\n            }\n            while (true) {\n                if (!slotEl) {\n                    return [];\n                }\n                var listChild = Array.from(slotEl.assignedElements());\n                if (!listChild) {\n                    return [];\n                }\n                let slotFound = false;\n                for (let i = 0; i < listChild.length; i++) {\n                    if (listChild[i].nodeName == \"SLOT\") {\n                        slotEl = listChild[i];\n                        slotFound = true;\n                        break;\n                    }\n                }\n                if (!slotFound) {\n                    return listChild;\n                }\n            }\n        }\n        return [];\n    }\n    /**\n     * Get deeper element inside dom at the position X and Y\n     */\n    static getElementAtPosition(x, y, startFrom = null) {\n        var _realTarget = (el, i = 0) => {\n            if (i == 50) {\n                debugger;\n            }\n            if (el.shadowRoot && x !== undefined && y !== undefined) {\n                var newEl = el.shadowRoot.elementFromPoint(x, y);\n                if (newEl && newEl != el) {\n                    return _realTarget(newEl, i + 1);\n                }\n            }\n            return el;\n        };\n        if (startFrom == null) {\n            startFrom = document.body;\n        }\n        return _realTarget(startFrom);\n    }\n}\n","dependances":[{"fullName":"Element","isStrong":false},{"fullName":"ShadowRoot","isStrong":false},{"fullName":"HTMLSlotElement","isStrong":false},{"fullName":"HTMLElement","isStrong":false}],"fullName":"Aventus.ElementExtension","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"function uuidv4() {\n    let uid = '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));\n    return uid;\n}\n","dependances":[],"fullName":"Aventus.uuidv4","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n","dependances":[],"fullName":"Aventus.sleep","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"class Mutex {\n    waitingList = [];\n    isLocked = false;\n    /**\n     * Wait the mutex to be free then get it\n     */\n    waitOne() {\n        return new Promise((resolve) => {\n            if (this.isLocked) {\n                this.waitingList.push(() => {\n                    resolve();\n                });\n            }\n            else {\n                this.isLocked = true;\n                resolve();\n            }\n        });\n    }\n    /**\n     * Release the mutex\n     */\n    release() {\n        let nextFct = this.waitingList.shift();\n        if (nextFct) {\n            nextFct();\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Clear mutex\n     */\n    dispose() {\n        this.waitingList = [];\n        this.isLocked = false;\n    }\n}\n","dependances":[],"fullName":"Aventus.Mutex","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"function compareObject(obj1, obj2) {\n    if (Array.isArray(obj1)) {\n        if (!obj2) {\n            obj2 = [];\n        }\n        else {\n            obj2 = obj2.slice();\n        }\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            let foundElement = false;\n            for (let j = 0; j < obj2.length; j++) {\n                if (compareObject(obj1[i], obj2[j])) {\n                    obj2.splice(j, 1);\n                    foundElement = true;\n                    break;\n                }\n            }\n            if (!foundElement) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (obj1 instanceof Date) {\n        return obj1.toString() === obj2.toString();\n    }\n    else if (typeof obj1 == 'object') {\n        if (!obj2) {\n            obj2 = {};\n        }\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for (let key in obj1) {\n            if (!(key in obj2)) {\n                return false;\n            }\n            if (!compareObject(obj1[key], obj2[key])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else {\n        return obj1 == obj2;\n    }\n}\n","dependances":[],"fullName":"Aventus.compareObject","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"class StateManager {\n    subscribers = {};\n    static canBeActivate(statePattern, stateName) {\n        let stateInfo = this.prepareStateString(statePattern);\n        return stateInfo.regex.test(stateName);\n    }\n    activeState;\n    afterStateChanged = new Callback();\n    /**\n     * Subscribe actions for a state or a state list\n     */\n    subscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to subscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (!this.subscribers.hasOwnProperty(statePattern)) {\n                let res = StateManager.prepareStateString(statePattern);\n                let isActive = this.activeState !== undefined && res.regex.test(this.activeState.name);\n                this.subscribers[statePattern] = {\n                    \"regex\": res.regex,\n                    \"params\": res.params,\n                    \"callbacks\": {\n                        \"active\": [],\n                        \"inactive\": [],\n                        \"askChange\": [],\n                    },\n                    \"isActive\": isActive,\n                };\n            }\n            if (callbacks.active) {\n                if (!Array.isArray(callbacks.active)) {\n                    callbacks.active = [callbacks.active];\n                }\n                for (let activeFct of callbacks.active) {\n                    this.subscribers[statePattern].callbacks.active.push(activeFct);\n                    if (this.subscribers[statePattern].isActive) {\n                        let slugs = this.getInternalStateSlugs(this.subscribers[statePattern], this.activeState.name);\n                        activeFct(this.activeState, slugs);\n                    }\n                }\n            }\n            if (callbacks.inactive) {\n                if (!Array.isArray(callbacks.inactive)) {\n                    callbacks.inactive = [callbacks.inactive];\n                }\n                for (let inactiveFct of callbacks.inactive) {\n                    this.subscribers[statePattern].callbacks.inactive.push(inactiveFct);\n                }\n            }\n            if (callbacks.askChange) {\n                if (!Array.isArray(callbacks.askChange)) {\n                    callbacks.askChange = [callbacks.askChange];\n                }\n                for (let askChangeFct of callbacks.askChange) {\n                    this.subscribers[statePattern].callbacks.askChange.push(askChangeFct);\n                }\n            }\n        }\n    }\n    /**\n     * Unsubscribe actions for a state or a state list\n     */\n    unsubscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to unsubscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (this.subscribers[statePattern]) {\n                if (callbacks.active) {\n                    if (!Array.isArray(callbacks.active)) {\n                        callbacks.active = [callbacks.active];\n                    }\n                    for (let activeFct of callbacks.active) {\n                        let index = this.subscribers[statePattern].callbacks.active.indexOf(activeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.active.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.inactive) {\n                    if (!Array.isArray(callbacks.inactive)) {\n                        callbacks.inactive = [callbacks.inactive];\n                    }\n                    for (let inactiveFct of callbacks.inactive) {\n                        let index = this.subscribers[statePattern].callbacks.inactive.indexOf(inactiveFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.inactive.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.askChange) {\n                    if (!Array.isArray(callbacks.askChange)) {\n                        callbacks.askChange = [callbacks.askChange];\n                    }\n                    for (let askChangeFct of callbacks.askChange) {\n                        let index = this.subscribers[statePattern].callbacks.askChange.indexOf(askChangeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.askChange.splice(index, 1);\n                        }\n                    }\n                }\n                if (this.subscribers[statePattern].callbacks.active.length === 0 &&\n                    this.subscribers[statePattern].callbacks.inactive.length === 0 &&\n                    this.subscribers[statePattern].callbacks.askChange.length === 0) {\n                    delete this.subscribers[statePattern];\n                }\n            }\n        }\n    }\n    onAfterStateChanged(cb) {\n        this.afterStateChanged.add(cb);\n    }\n    offAfterStateChanged(cb) {\n        this.afterStateChanged.remove(cb);\n    }\n    static prepareStateString(stateName) {\n        let params = [];\n        let i = 0;\n        let regexState = stateName.replace(/{.*?}/g, (group, position) => {\n            group = group.slice(1, -1);\n            let splitted = group.split(\":\");\n            let name = splitted[0].trim();\n            let type = \"string\";\n            let result = \"([^\\\\/]+)\";\n            i++;\n            if (splitted.length > 1) {\n                if (splitted[1].trim() == \"number\") {\n                    result = \"([0-9]+)\";\n                    type = \"number\";\n                }\n            }\n            params.push({\n                name,\n                type,\n                position: i\n            });\n            return result;\n        });\n        regexState = regexState.replace(/\\*/g, \".*?\");\n        regexState = \"^\" + regexState + '$';\n        return {\n            regex: new RegExp(regexState),\n            params\n        };\n    }\n    /**\n     * Activate a current state\n     */\n    async setState(state) {\n        let stateToUse;\n        if (typeof state == \"string\") {\n            stateToUse = new EmptyState(state);\n        }\n        else {\n            stateToUse = state;\n        }\n        if (!stateToUse) {\n            this._log(\"state is undefined\", \"error\");\n            return false;\n        }\n        let canChange = true;\n        if (this.activeState) {\n            let activeToInactive = [];\n            let inactiveToActive = [];\n            let triggerActive = [];\n            canChange = await this.activeState.askChange(this.activeState, stateToUse);\n            if (canChange) {\n                for (let statePattern in this.subscribers) {\n                    let subscriber = this.subscribers[statePattern];\n                    if (subscriber.isActive) {\n                        let clone = [...subscriber.callbacks.askChange];\n                        let currentSlug = this.getInternalStateSlugs(subscriber, this.activeState.name);\n                        for (let i = 0; i < clone.length; i++) {\n                            let askChange = clone[i];\n                            if (!await askChange(this.activeState, stateToUse, currentSlug)) {\n                                canChange = false;\n                                break;\n                            }\n                        }\n                        let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                        if (slugs === null) {\n                            activeToInactive.push(subscriber);\n                        }\n                        else {\n                            triggerActive.push({\n                                subscriber: subscriber,\n                                params: slugs\n                            });\n                        }\n                    }\n                    else {\n                        let slugs = this.getInternalStateSlugs(subscriber, stateToUse.name);\n                        if (slugs) {\n                            inactiveToActive.push({\n                                subscriber,\n                                params: slugs\n                            });\n                        }\n                    }\n                    if (!canChange) {\n                        break;\n                    }\n                }\n            }\n            if (canChange) {\n                const oldState = this.activeState;\n                this.activeState = stateToUse;\n                oldState.onInactivate(stateToUse);\n                for (let subscriber of activeToInactive) {\n                    subscriber.isActive = false;\n                    let oldSlug = this.getInternalStateSlugs(subscriber, oldState.name);\n                    [...subscriber.callbacks.inactive].forEach(callback => {\n                        callback(oldState, stateToUse, oldSlug);\n                    });\n                }\n                for (let trigger of triggerActive) {\n                    [...trigger.subscriber.callbacks.active].forEach(callback => {\n                        callback(stateToUse, trigger.params);\n                    });\n                }\n                for (let trigger of inactiveToActive) {\n                    trigger.subscriber.isActive = true;\n                    [...trigger.subscriber.callbacks.active].forEach(callback => {\n                        callback(stateToUse, trigger.params);\n                    });\n                }\n                stateToUse.onActivate();\n            }\n        }\n        else {\n            this.activeState = stateToUse;\n            for (let key in this.subscribers) {\n                let slugs = this.getInternalStateSlugs(this.subscribers[key], stateToUse.name);\n                if (slugs) {\n                    this.subscribers[key].isActive = true;\n                    [...this.subscribers[key].callbacks.active].forEach(callback => {\n                        callback(stateToUse, slugs);\n                    });\n                }\n            }\n            stateToUse.onActivate();\n        }\n        this.afterStateChanged.trigger([]);\n        return true;\n    }\n    getState() {\n        return this.activeState;\n    }\n    getInternalStateSlugs(subscriber, stateName) {\n        let matches = subscriber.regex.exec(stateName);\n        if (matches) {\n            let slugs = {};\n            for (let param of subscriber.params) {\n                if (param.type == \"number\") {\n                    slugs[param.name] = Number(matches[param.position]);\n                }\n                else {\n                    slugs[param.name] = matches[param.position];\n                }\n            }\n            return slugs;\n        }\n        return null;\n    }\n    /**\n     * Check if a state is in the subscribers and active, return true if it is, false otherwise\n     */\n    isStateActive(statePattern) {\n        return StateManager.prepareStateString(statePattern).regex.test(this.activeState.name);\n    }\n    /**\n     * Get slugs information for the current state, return null if state isn't active\n     */\n    getStateSlugs(statePattern) {\n        let prepared = StateManager.prepareStateString(statePattern);\n        return this.getInternalStateSlugs({\n            regex: prepared.regex,\n            params: prepared.params,\n            isActive: false,\n            callbacks: {\n                active: [],\n                inactive: [],\n                askChange: [],\n            }\n        }, this.activeState.name);\n    }\n    // 0 = error only / 1 = errors and warning / 2 = error, warning and logs (not implemented)\n    logLevel() {\n        return 0;\n    }\n    _log(msg, type) {\n        if (type === \"error\") {\n            console.error(msg);\n        }\n        else if (type === \"warning\" && this.logLevel() > 0) {\n            console.warn(msg);\n        }\n        else if (type === \"info\" && this.logLevel() > 1) {\n            console.log(msg);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Aventus.StateAction","isStrong":false},{"fullName":"Aventus.EmptyState","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false}],"fullName":"Aventus.StateManager","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class State {\n    /**\n     * Activate a custom state inside a specific manager\n     * It ll be a generic state with no information inside exept name\n     */\n    static async activate(stateName, manager) {\n        return await new EmptyState(stateName).activate(manager);\n    }\n    /**\n     * Activate this state inside a specific manager\n     */\n    async activate(manager) {\n        return await manager.setState(this);\n    }\n    onActivate() {\n    }\n    onInactivate(nextState) {\n    }\n    async askChange(state, nextState) {\n        return true;\n    }\n}\n","dependances":[{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"EmptyState","isStrong":false}],"fullName":"Aventus.State","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class EmptyState extends State {\n    localName;\n    constructor(stateName) {\n        super();\n        this.localName = stateName;\n    }\n    /**\n     * @inheritdoc\n     */\n    get name() {\n        return this.localName;\n    }\n}\n","dependances":[{"fullName":"Aventus.State","isStrong":true}],"fullName":"Aventus.EmptyState","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class GenericRam {\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    subscribers = {\n        created: [],\n        updated: [],\n        deleted: [],\n    };\n    recordsSubscribers = new Map();\n    /**\n     * List of stored item by index key\n     */\n    records = new Map();\n    constructor() {\n        if (this.constructor == GenericRam) {\n            throw \"can't instanciate an abstract class\";\n        }\n    }\n    /**\n     * Get item id\n     */\n    getIdWithError(item) {\n        let action = new ResultRamWithError();\n        let idTemp = item[this.defineIndexKey()];\n        if (idTemp !== undefined) {\n            action.result = idTemp;\n        }\n        else {\n            action.errors.push(new RamError(RamErrorCode.noId, \"no key found for item\"));\n        }\n        return action;\n    }\n    /**\n     * Get item id\n     */\n    getId(item) {\n        let result = this.getIdWithError(item);\n        if (result.success) {\n            return result.result;\n        }\n        return null;\n    }\n    /**\n     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete\n     */\n    addRamAction(Base) {\n        let that = this;\n        return class ActionClass extends Base {\n            async update(newData = {}) {\n                let id = that.getId(this);\n                let oldData = that.records.get(id);\n                if (oldData) {\n                    that.mergeObject(oldData, newData);\n                    let result = await that.update(oldData);\n                    return result;\n                }\n                return undefined;\n            }\n            onUpdate(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).updated.includes(callback)) {\n                    that.recordsSubscribers.get(id).updated.push(callback);\n                }\n            }\n            offUpdate(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).updated.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).updated.splice(index, 1);\n                    }\n                }\n            }\n            async delete() {\n                let id = that.getId(this);\n                await that.deleteById(id);\n            }\n            onDelete(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                if (!that.recordsSubscribers.get(id).deleted.includes(callback)) {\n                    that.recordsSubscribers.get(id).deleted.push(callback);\n                }\n            }\n            offDelete(callback) {\n                let id = that.getId(this);\n                if (that.recordsSubscribers.has(id)) {\n                    let index = that.recordsSubscribers.get(id).deleted.indexOf(callback);\n                    if (index != -1) {\n                        that.recordsSubscribers.get(id).deleted.splice(index, 1);\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Transform the object into the object stored inside Ram\n     */\n    getObjectForRam(objJson) {\n        let T = this.addRamAction(this.getTypeForData(objJson));\n        let item = new T();\n        this.mergeObject(item, objJson);\n        return item;\n    }\n    /**\n     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced\n     */\n    addOrUpdateData(item, result) {\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    this.mergeObject(this.records.get(id), item);\n                }\n                else {\n                    let realObject = this.getObjectForRam(item);\n                    this.records.set(id, realObject);\n                }\n                result.result = this.records.get(id);\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n            }\n        }\n        catch (e) {\n            result.errors.push(new RamError(RamErrorCode.unknow, e));\n        }\n    }\n    /**\n     * Merge object and create real instance of class\n     */\n    mergeObject(item, objJson) {\n        let realObject = DataManager.createObject(objJson);\n        let props = Object.getOwnPropertyNames(item);\n        for (let prop of props) {\n            if (realObject[prop] !== undefined) {\n                let propInfo = Object.getOwnPropertyDescriptor(item, prop);\n                if (propInfo.writable) {\n                    item[prop] = realObject[prop];\n                }\n            }\n        }\n    }\n    publish(type, data) {\n        [...this.subscribers[type]].forEach(callback => callback(data));\n        if (this.recordsSubscribers.has(this.getId(data))) {\n            [...this.recordsSubscribers.get(this.getId(data))[type]].forEach(callback => callback(data));\n        }\n    }\n    subscribe(type, cb) {\n        if (!this.subscribers[type].includes(cb)) {\n            this.subscribers[type].push(cb);\n        }\n    }\n    unsubscribe(type, cb) {\n        let index = this.subscribers[type].indexOf(cb);\n        if (index != -1) {\n            this.subscribers[type].splice(index, 1);\n        }\n    }\n    /**\n    * Add a callback that ll be triggered when a new item is stored\n    */\n    onCreated(cb) {\n        this.subscribe('created', cb);\n    }\n    /**\n     * Remove a created callback\n     */\n    offCreated(cb) {\n        this.unsubscribe('created', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is updated\n     */\n    onUpdated(cb) {\n        this.subscribe('updated', cb);\n    }\n    /**\n     * Remove an updated callback\n     */\n    offUpdated(cb) {\n        this.unsubscribe('updated', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is deleted\n     */\n    onDeleted(cb) {\n        this.subscribe('deleted', cb);\n    }\n    /**\n     * Remove an deleted callback\n     */\n    offDeleted(cb) {\n        this.unsubscribe('deleted', cb);\n    }\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async get(id) {\n        return await this.getById(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async getWithError(id) {\n        return await this.getByIdWithError(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist\n     */\n    async getById(id) {\n        let action = await this.getByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Get an item by id if exist\n     */\n    async getByIdWithError(id) {\n        let action = new ResultRamWithError();\n        await this.beforeGetById(id, action);\n        if (action.success) {\n            if (this.records.has(id)) {\n                action.result = this.records.get(id);\n                await this.afterGetById(action);\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before getting an item by id\n     */\n    async beforeGetById(id, result) { }\n    ;\n    /**\n     * Trigger after getting an item by id\n     */\n    async afterGetById(result) { }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIds(ids) {\n        let result = await this.getByIdsWithError(ids);\n        if (result.success) {\n            return result.result;\n        }\n        return [];\n    }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIdsWithError(ids) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeGetByIds(ids, action);\n        if (action.success) {\n            for (let id of ids) {\n                if (this.records.has(id)) {\n                    action.result.push(this.records.get(id));\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                }\n            }\n            if (action.success) {\n                await this.afterGetByIds(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting a list of items by id\n     */\n    async beforeGetByIds(ids, result) { }\n    ;\n    /**\n     * Trigger after getting a list of items by id\n     */\n    async afterGetByIds(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAll() {\n        let result = await this.getAllWithError();\n        if (result.success) {\n            return result.result;\n        }\n        return new Map();\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAllWithError() {\n        let action = new ResultRamWithError();\n        action.result = new Map();\n        await this.beforeGetAll(action);\n        if (action.success) {\n            action.result = this.records;\n            await this.afterGetAll(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before getting all items inside Ram\n     */\n    async beforeGetAll(result) { }\n    ;\n    /**\n     * Trigger after getting all items inside Ram\n     */\n    async afterGetAll(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getList() {\n        let data = await this.getAll();\n        return Array.from(data.values());\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getListWithError() {\n        let action = new ResultRamWithError();\n        action.result = [];\n        let result = await this.getAllWithError();\n        if (result.success) {\n            action.result = Object.values(result.result);\n        }\n        else {\n            action.errors = result.errors;\n        }\n        return action;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createList(list) {\n        let result = await this.createListWithError(list);\n        return result.result;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeCreateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._create(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterCreateList(action);\n            }\n        }\n        return action;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async create(item, ...args) {\n        let action = await this.createWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async createWithError(item, ...args) {\n        return await this._create(item, false);\n    }\n    async _create(item, fromList) {\n        let action = new ResultRamWithError();\n        await this.beforeCreateItem(item, fromList, action);\n        if (action.success) {\n            if (action.result) {\n                item = action.result;\n            }\n            let resultTemp = this.getIdWithError(item);\n            if (resultTemp.success) {\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterCreateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('created', action.result);\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n        }\n        return action;\n    }\n    /**\n     * Trigger before creating a list of items\n     */\n    async beforeCreateList(list, result) {\n    }\n    ;\n    /**\n     * Trigger before creating an item\n     */\n    async beforeCreateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after creating an item\n     */\n    async afterCreateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after creating a list of items\n     */\n    async afterCreateList(result) {\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateList(list) {\n        let result = await this.updateListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeUpdateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n            }\n            for (let item of list) {\n                let resultItem = await this._update(item, true);\n                if (resultItem.success) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterUpdateList(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Update an item inside ram\n     */\n    async update(item, ...args) {\n        let action = await this.updateWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Update an item inside ram\n     */\n    async updateWithError(item, ...args) {\n        return await this._update(item, false);\n    }\n    async _update(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                await this.beforeUpdateItem(item, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                if (action.result) {\n                    item = action.result;\n                }\n                this.addOrUpdateData(item, action);\n                if (!action.success) {\n                    return action;\n                }\n                await this.afterUpdateItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('updated', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    ;\n    /**\n     * Trigger before updating a list of items\n     */\n    async beforeUpdateList(list, result) {\n    }\n    ;\n    /**\n    * Trigger before updating an item\n    */\n    async beforeUpdateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after updating an item\n     */\n    async afterUpdateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after updating a list of items\n     */\n    async afterUpdateList(result) {\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteList(list) {\n        let result = await this.deleteListWithError(list);\n        return result.result;\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteListWithError(list) {\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeDeleteList(list, action);\n        for (let item of list) {\n            let resultItem = await this._delete(item, true);\n            if (resultItem.success) {\n                action.result.push(resultItem.result);\n            }\n            else {\n                action.errors = [...action.errors, ...resultItem.errors];\n            }\n        }\n        if (action.success) {\n            await this.afterDeleteList(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Delete an item inside ram\n     */\n    async delete(item, ...args) {\n        let action = await this.deleteWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    ;\n    /**\n    * Delete an item inside ram\n    */\n    async deleteWithError(item, ...args) {\n        return await this._delete(item, false);\n    }\n    ;\n    /**\n     * Delete an item by id inside ram\n     */\n    async deleteById(id) {\n        let action = await this.deleteByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n    * Delete an item by id inside ram\n    */\n    async deleteByIdWithError(id) {\n        if (this.records.has(id)) {\n            let item = this.records.get(id);\n            return await this._delete(item, false);\n        }\n        let result = new ResultRamWithError();\n        result.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + id + \" because it wasn't found inside ram\"));\n        return result;\n    }\n    async _delete(item, fromList) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success) {\n            let key = resultTemp.result;\n            if (this.records.has(key)) {\n                let oldItem = this.records.get(key);\n                await this.beforeDeleteItem(oldItem, fromList, action);\n                if (!action.success) {\n                    return action;\n                }\n                this.records.delete(key);\n                action.result = oldItem;\n                await this.afterDeleteItem(action, fromList);\n                if (!action.success) {\n                    action.result = null;\n                }\n                else {\n                    this.publish('deleted', action.result);\n                }\n            }\n            else {\n                action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    /**\n     * Trigger before deleting a list of items\n     */\n    async beforeDeleteList(list, result) { }\n    ;\n    /**\n     * Trigger before deleting an item\n     */\n    async beforeDeleteItem(item, fromList, result) { }\n    ;\n    /**\n     * Trigger after deleting an item\n     */\n    async afterDeleteItem(result, fromList) { }\n    ;\n    /**\n     * Trigger after deleting a list of items\n     */\n    async afterDeleteList(result) { }\n}\n","dependances":[{"fullName":"Aventus.IRam","isStrong":true},{"fullName":"Aventus.RamSubscribers","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Base","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.DataManager","isStrong":false}],"fullName":"Aventus.GenericRam","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Ram extends GenericRam {\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true}],"fullName":"Aventus.Ram","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class GenericRamWs extends GenericRam {\n    wsRoutes;\n    ws;\n    getAllDone = false;\n    constructor() {\n        super();\n        if (this.constructor == GenericRamWs) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.init();\n    }\n    init() {\n        this.ws = this.getWebSocket();\n        this.createRoutes();\n        this.addSocketCallback();\n    }\n    createRoutes() {\n        const socketActions = {\n            get: \"get\",\n            getAll: \"get/all\",\n            create: \"create\",\n            created: \"created\",\n            update: \"update\",\n            updated: \"updated\",\n            delete: \"delete\",\n            deleted: \"deleted\"\n        };\n        let temp = {};\n        let wsRouteBase = this.getWebSocketRoute();\n        if (wsRouteBase.endsWith(\"/\")) {\n            wsRouteBase = wsRouteBase.slice(0, -1);\n        }\n        for (const [key, name] of Object.entries(socketActions)) {\n            temp[key] = {\n                request: `${wsRouteBase}/${name}`,\n                multiple: `${wsRouteBase}/${name}/multiple`,\n                success: `${wsRouteBase}/${name}/success`,\n                error: `${wsRouteBase}/${name}/error`,\n            };\n        }\n        this.wsRoutes = temp;\n    }\n    addSocketCallback() {\n        let createdRoute = {\n            channel: this.wsRoutes.created.request,\n            callback: response => {\n                if (response.data) {\n                    for (let obj of response.data) {\n                        let id = this.getId(obj);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            this.addOrUpdateData(obj, result);\n                            if (result.success) {\n                                this.publish('created', this.records.get(id));\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(createdRoute);\n        let updatedRoute = {\n            channel: this.wsRoutes.updated.request,\n            callback: response => {\n                if (response.data) {\n                    for (let newData of response.data) {\n                        let id = this.getId(newData);\n                        if (id !== undefined) {\n                            let result = new ResultRamWithError();\n                            if (this.records.has(id)) {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('updated', this.records.get(id));\n                                }\n                            }\n                            else {\n                                this.addOrUpdateData(newData, result);\n                                if (result.success) {\n                                    this.publish('created', this.records.get(id));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(updatedRoute);\n        let deletedRoute = {\n            channel: this.wsRoutes.deleted.request,\n            callback: response => {\n                if (response.data) {\n                    for (let data of response.data) {\n                        let id = this.getId(data);\n                        if (this.records.has(id)) {\n                            let oldData = this.records.get(id);\n                            this.records.delete(id);\n                            this.publish('deleted', oldData);\n                        }\n                    }\n                }\n            }\n        };\n        this.addRoute(deletedRoute);\n    }\n    /**\n     * Send a msg through the websocket\n     */\n    sendMsg(route, params, callbacks) {\n        this.ws.sendMessageAndWait(route, params, callbacks);\n    }\n    uniqueMsgWaiting = {};\n    /**\n     * Send a unique msg through the websocket and wait answer\n     */\n    sendUniqueMsg(route, params, callbacks) {\n        let uniqueKey = route + JSON.stringify(params);\n        if (this.uniqueMsgWaiting[uniqueKey]) {\n            for (let name in callbacks) {\n                if (this.uniqueMsgWaiting[uniqueKey][name]) {\n                    this.uniqueMsgWaiting[uniqueKey][name].push(callbacks[name]);\n                }\n                else {\n                    this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n                }\n            }\n        }\n        else {\n            let callbacksToAdd = {};\n            const createCallback = (name) => {\n                callbacksToAdd[name] = (data) => {\n                    for (let fct of this.uniqueMsgWaiting[uniqueKey][name]) {\n                        fct(data);\n                    }\n                    delete this.uniqueMsgWaiting[uniqueKey];\n                };\n            };\n            this.uniqueMsgWaiting[uniqueKey] = {};\n            for (let name in callbacks) {\n                createCallback(name);\n                this.uniqueMsgWaiting[uniqueKey][name] = [callbacks[name]];\n            }\n            this.ws.sendMessageAndWait(route, params, callbacksToAdd);\n        }\n    }\n    addRoute(newRoute) {\n        this.ws.addRoute(newRoute);\n    }\n    beforeGetById(id, result) {\n        return new Promise((resolve, reject) => {\n            if (this.records.has(id)) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.get.request, {\n                    [this.defineIndexKey()]: id\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            let resultTemp = new ResultRamWithError();\n                            this.addOrUpdateData(response.data, resultTemp);\n                            if (!resultTemp.success) {\n                                result.errors = [...result.errors, ...resultTemp.errors];\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeGetByIds(ids, result) {\n        return new Promise((resolve, reject) => {\n            let missingIds = [];\n            for (let id of ids) {\n                if (!this.records.has(id)) {\n                    missingIds.push(id);\n                }\n            }\n            if (missingIds.length > 0) {\n                this.sendUniqueMsg(this.wsRoutes.get.multiple, {\n                    [this.defineIndexKey()]: ids\n                }, {\n                    [this.wsRoutes.get.success]: (response) => {\n                        if (response.data) {\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.get.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeGetAll(result) {\n        return new Promise((resolve, reject) => {\n            if (this.getAllDone) {\n                resolve();\n            }\n            else {\n                this.sendUniqueMsg(this.wsRoutes.getAll.request, {}, {\n                    [this.wsRoutes.getAll.success]: (response) => {\n                        if (response.data) {\n                            this.getAllDone = true;\n                            for (let item of response.data) {\n                                let resultTemp = new ResultRamWithError();\n                                this.addOrUpdateData(item, resultTemp);\n                                if (!resultTemp.success) {\n                                    result.errors = [...result.errors, ...resultTemp.errors];\n                                }\n                            }\n                        }\n                        resolve();\n                    },\n                    [this.wsRoutes.getAll.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    beforeCreateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.create.request, item, {\n                    [this.wsRoutes.create.success]: (response) => {\n                        let element = response.created[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.create.error]: (response) => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeCreateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.create.multiple, list, {\n                [this.wsRoutes.create.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.created) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.create.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeUpdateItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.update.request, item, {\n                    [this.wsRoutes.update.success]: (response) => {\n                        let element = response.updated[0];\n                        result.result = this.getObjectForRam(element);\n                        resolve();\n                    },\n                    [this.wsRoutes.update.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeUpdateList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.update.multiple, list, {\n                [this.wsRoutes.update.success]: (response) => {\n                    result.result = [];\n                    for (let element of response.updated) {\n                        result.result.push(this.getObjectForRam(element));\n                    }\n                    resolve();\n                },\n                [this.wsRoutes.update.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n    beforeDeleteItem(item, fromList, result) {\n        return new Promise((resolve, reject) => {\n            if (!fromList) {\n                this.sendMsg(this.wsRoutes.delete.request, item, {\n                    [this.wsRoutes.delete.success]: (response) => {\n                        resolve();\n                    },\n                    [this.wsRoutes.delete.error]: response => {\n                        result.errors.push(new RamError(RamErrorCode.unknow, response));\n                        resolve();\n                    }\n                });\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    beforeDeleteList(list, result) {\n        return new Promise((resolve, reject) => {\n            this.sendMsg(this.wsRoutes.delete.multiple, list, {\n                [this.wsRoutes.delete.success]: (response) => {\n                    resolve();\n                },\n                [this.wsRoutes.delete.error]: response => {\n                    result.errors.push(new RamError(RamErrorCode.unknow, response));\n                    resolve();\n                }\n            });\n        });\n    }\n}\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true},{"fullName":"Aventus.RamWsRoutes","isStrong":false},{"fullName":"Aventus.Socket","isStrong":false},{"fullName":"Aventus.RamWsCallback","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Map","isStrong":false}],"fullName":"Aventus.GenericRamWs","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class RamWs extends GenericRamWs {\n}\n","dependances":[{"fullName":"Aventus.GenericRamWs","isStrong":true}],"fullName":"Aventus.RamWs","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class ResultWithError {\n    /**\n     * Determine if the action is a success\n     */\n    get success() {\n        return this.errors.length == 0;\n    }\n    /**\n     * Result\n     */\n    result;\n    /**\n     * List of errors\n     */\n    errors = [];\n}\n","dependances":[],"fullName":"Aventus.ResultWithError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"var RamErrorCode;\n(function (RamErrorCode) {\n    RamErrorCode[RamErrorCode[\"unknow\"] = 0] = \"unknow\";\n    RamErrorCode[RamErrorCode[\"noId\"] = 1] = \"noId\";\n    RamErrorCode[RamErrorCode[\"noItemInsideRam\"] = 2] = \"noItemInsideRam\";\n})(RamErrorCode || (RamErrorCode = {}));\n","dependances":[],"fullName":"Aventus.RamErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"class GenericError {\n    /**\n     * Code for the error\n     */\n    code;\n    /**\n     * Description of the error\n     */\n    message;\n    constructor(code, message) {\n        this.code = code;\n        this.message = message;\n    }\n}\n","dependances":[],"fullName":"Aventus.GenericError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Watcher {\n    static __maxProxyData = 0;\n    /**\n     * Transform object into a watcher\n     */\n    static get(obj, onDataChanged) {\n        if (obj == undefined) {\n            console.error(\"You must define an objet / array for your proxy\");\n            return;\n        }\n        if (obj.__isProxy) {\n            obj.__subscribe(onDataChanged);\n            return obj;\n        }\n        Watcher.__maxProxyData++;\n        let setProxyPath = (newProxy, newPath) => {\n            if (newProxy instanceof Object && newProxy.__isProxy) {\n                newProxy.__path = newPath;\n                if (!newProxy.__proxyData) {\n                    newProxy.__proxyData = {};\n                }\n                if (!newProxy.__proxyData[newPath]) {\n                    newProxy.__proxyData[newPath] = [];\n                }\n                if (newProxy.__proxyData[newPath].indexOf(proxyData) == -1) {\n                    newProxy.__proxyData[newPath].push(proxyData);\n                }\n            }\n        };\n        let removeProxyPath = (oldValue, pathToDelete, recursive = true) => {\n            if (oldValue instanceof Object && oldValue.__isProxy) {\n                let allProxies = oldValue.__proxyData;\n                for (let triggerPath in allProxies) {\n                    if (triggerPath == pathToDelete) {\n                        for (let i = 0; i < allProxies[triggerPath].length; i++) {\n                            if (allProxies[triggerPath][i] == proxyData) {\n                                allProxies[triggerPath].splice(i, 1);\n                                i--;\n                            }\n                        }\n                        if (allProxies[triggerPath].length == 0) {\n                            delete allProxies[triggerPath];\n                            if (Object.keys(allProxies).length == 0) {\n                                delete oldValue.__proxyData;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        let jsonReplacer = (key, value) => {\n            if (key == \"__path\")\n                return undefined;\n            else if (key == \"__proxyData\")\n                return undefined;\n            else\n                return value;\n        };\n        let currentTrace = new Error().stack.split(\"\\n\");\n        currentTrace.shift();\n        currentTrace.shift();\n        let onlyDuringInit = true;\n        let proxyData = {\n            baseData: {},\n            id: Watcher.__maxProxyData,\n            callbacks: [onDataChanged],\n            avoidUpdate: [],\n            pathToRemove: [],\n            history: [{\n                    object: JSON.parse(JSON.stringify(obj, jsonReplacer)),\n                    trace: currentTrace,\n                    action: 'init',\n                    path: ''\n                }],\n            useHistory: false,\n            getProxyObject(target, element, prop) {\n                let newProxy;\n                if (element instanceof Object && element.__isProxy) {\n                    newProxy = element;\n                }\n                else {\n                    try {\n                        if (element instanceof Object) {\n                            newProxy = new Proxy(element, this);\n                        }\n                        else {\n                            return element;\n                        }\n                    }\n                    catch {\n                        return element;\n                    }\n                }\n                let newPath = '';\n                if (Array.isArray(target)) {\n                    if (prop != \"length\") {\n                        if (target.__path) {\n                            newPath = target.__path;\n                        }\n                        newPath += \"[\" + prop + \"]\";\n                        setProxyPath(newProxy, newPath);\n                    }\n                }\n                else if (element instanceof Date) {\n                    return element;\n                }\n                else {\n                    if (target.__path) {\n                        newPath = target.__path + '.';\n                    }\n                    newPath += prop;\n                    setProxyPath(newProxy, newPath);\n                }\n                return newProxy;\n            },\n            tryCustomFunction(target, prop, receiver) {\n                if (prop == \"__isProxy\") {\n                    return true;\n                }\n                else if (prop == \"__subscribe\") {\n                    return (cb) => {\n                        this.callbacks.push(cb);\n                    };\n                }\n                else if (prop == \"__unsubscribe\") {\n                    return (cb) => {\n                        let index = this.callbacks.indexOf(cb);\n                        if (index > -1) {\n                            this.callbacks.splice(index, 1);\n                        }\n                    };\n                }\n                else if (prop == \"__proxyId\") {\n                    return this.id;\n                }\n                else if (prop == \"getHistory\") {\n                    return () => {\n                        return this.history;\n                    };\n                }\n                else if (prop == \"clearHistory\") {\n                    this.history = [];\n                }\n                else if (prop == \"enableHistory\") {\n                    return () => {\n                        this.useHistory = true;\n                    };\n                }\n                else if (prop == \"disableHistory\") {\n                    return () => {\n                        this.useHistory = false;\n                    };\n                }\n                else if (prop == \"__getTarget\" && onlyDuringInit) {\n                    return () => {\n                        return target;\n                    };\n                }\n                return undefined;\n            },\n            get(target, prop, receiver) {\n                if (prop == \"__proxyData\") {\n                    return target[prop];\n                }\n                let customResult = this.tryCustomFunction(target, prop, receiver);\n                if (customResult !== undefined) {\n                    return customResult;\n                }\n                let element = target[prop];\n                if (typeof (element) == 'object') {\n                    return this.getProxyObject(target, element, prop);\n                }\n                else if (typeof (element) == 'function') {\n                    if (Array.isArray(target)) {\n                        let result;\n                        if (prop == 'push') {\n                            if (target.__isProxy) {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    return index;\n                                };\n                            }\n                            else {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    let proxyEl = this.getProxyObject(target, el, (index - 1));\n                                    target.splice(target.length - 1, 1, proxyEl);\n                                    trigger('CREATED', target, receiver, proxyEl, \"[\" + (index - 1) + \"]\");\n                                    return index;\n                                };\n                            }\n                        }\n                        else if (prop == 'splice') {\n                            if (target.__isProxy) {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    let path = target.__path ? target.__path : '';\n                                    for (let i = 0; i < res.length; i++) {\n                                        trigger('DELETED', target, receiver, res[i], \"[\" + index + \"]\");\n                                        removeProxyPath(res[i], path + \"[\" + (index + i) + \"]\");\n                                    }\n                                    for (let i = 0; i < insert.length; i++) {\n                                        let proxyEl = this.getProxyObject(target, insert[i], (index + i));\n                                        target.splice((index + i), 1, proxyEl);\n                                        trigger('CREATED', target, receiver, proxyEl, \"[\" + (index + i) + \"]\");\n                                    }\n                                    let fromIndex = index + insert.length;\n                                    let baseDiff = index - insert.length + res.length + 1;\n                                    for (let i = fromIndex, j = 0; i < target.length; i++, j++) {\n                                        let oldPath = path + \"[\" + (j + baseDiff) + \"]\";\n                                        removeProxyPath(target[i], oldPath, false);\n                                        let proxyEl = this.getProxyObject(target, target[i], i);\n                                        let recuUpdate = (childEl) => {\n                                            if (Array.isArray(childEl)) {\n                                                for (let i = 0; i < childEl.length; i++) {\n                                                    if (childEl[i] instanceof Object && childEl[i].__path) {\n                                                        let oldPathRecu = proxyEl[i].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[i], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[i], i);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                            else if (childEl instanceof Object && !(childEl instanceof Date)) {\n                                                for (let key in childEl) {\n                                                    if (childEl[key] instanceof Object && childEl[key].__path) {\n                                                        let oldPathRecu = proxyEl[key].__path.replace(proxyEl.__path, oldPath);\n                                                        removeProxyPath(childEl[key], oldPathRecu, false);\n                                                        let newProxyEl = this.getProxyObject(childEl, childEl[key], key);\n                                                        recuUpdate(newProxyEl);\n                                                    }\n                                                }\n                                            }\n                                        };\n                                        recuUpdate(proxyEl);\n                                    }\n                                    return res;\n                                };\n                            }\n                        }\n                        else if (prop == 'pop') {\n                            if (target.__isProxy) {\n                                result = () => {\n                                    let res = target.pop();\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = () => {\n                                    let index = target.length - 1;\n                                    let res = target.pop();\n                                    let path = target.__path ? target.__path : '';\n                                    trigger('DELETED', target, receiver, res, \"[\" + index + \"]\");\n                                    removeProxyPath(res, path + \"[\" + index + \"]\");\n                                    return res;\n                                };\n                            }\n                        }\n                        else {\n                            result = element.bind(target);\n                        }\n                        return result;\n                    }\n                    return element.bind(target);\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n                let triggerChange = false;\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        let oldValue = Reflect.get(target, prop, receiver);\n                        if (oldValue !== value) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.set(target, prop, value, receiver);\n                if (triggerChange) {\n                    let index = this.avoidUpdate.indexOf(prop);\n                    if (index == -1) {\n                        trigger('UPDATED', target, receiver, value, prop);\n                    }\n                    else {\n                        this.avoidUpdate.splice(index, 1);\n                    }\n                }\n                return result;\n            },\n            deleteProperty(target, prop) {\n                let triggerChange = false;\n                let pathToDelete = '';\n                if (prop != \"__path\") {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                pathToDelete = target.__path;\n                            }\n                            pathToDelete += \"[\" + prop + \"]\";\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            pathToDelete = target.__path + '.';\n                        }\n                        pathToDelete += prop;\n                        triggerChange = true;\n                    }\n                }\n                if (target.hasOwnProperty(prop)) {\n                    let oldValue = target[prop];\n                    delete target[prop];\n                    if (triggerChange) {\n                        trigger('DELETED', target, null, oldValue, prop);\n                        removeProxyPath(oldValue, pathToDelete);\n                    }\n                    return true;\n                }\n                return false;\n            },\n            defineProperty(target, prop, descriptor) {\n                let triggerChange = false;\n                let newPath = '';\n                if ([\"__path\", \"__proxyData\"].indexOf(prop) == -1) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                newPath = target.__path;\n                            }\n                            newPath += \"[\" + prop + \"]\";\n                            if (!target.hasOwnProperty(prop)) {\n                                triggerChange = true;\n                            }\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            newPath = target.__path + '.';\n                        }\n                        newPath += prop;\n                        if (!target.hasOwnProperty(prop)) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.defineProperty(target, prop, descriptor);\n                if (triggerChange) {\n                    this.avoidUpdate.push(prop);\n                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);\n                    target[prop] = proxyEl;\n                    trigger('CREATED', target, null, proxyEl, prop);\n                }\n                return result;\n            }\n        };\n        const trigger = (type, target, receiver, value, prop) => {\n            if (target.__isProxy) {\n                return;\n            }\n            let allProxies = target.__proxyData;\n            let receiverId = 0;\n            if (receiver == null) {\n                receiverId = proxyData.id;\n            }\n            else {\n                receiverId = receiver.__proxyId;\n            }\n            if (proxyData.id == receiverId) {\n                let stacks = [];\n                let allStacks = new Error().stack.split(\"\\n\");\n                for (let i = allStacks.length - 1; i >= 0; i--) {\n                    let current = allStacks[i].trim().replace(\"at \", \"\");\n                    if (current.startsWith(\"Object.set\") || current.startsWith(\"Proxy.result\")) {\n                        break;\n                    }\n                    stacks.push(current);\n                }\n                for (let triggerPath in allProxies) {\n                    for (let currentProxyData of allProxies[triggerPath]) {\n                        let pathToSend = triggerPath;\n                        if (pathToSend != \"\") {\n                            if (Array.isArray(target)) {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \"[\" + prop + \"]\";\n                                }\n                                else {\n                                    pathToSend += prop;\n                                }\n                            }\n                            else {\n                                if (!prop.startsWith(\"[\")) {\n                                    pathToSend += \".\";\n                                }\n                                pathToSend += prop;\n                            }\n                        }\n                        else {\n                            pathToSend = prop;\n                        }\n                        if (proxyData.useHistory) {\n                            proxyData.history.push({\n                                object: JSON.parse(JSON.stringify(currentProxyData.baseData, jsonReplacer)),\n                                trace: stacks.reverse(),\n                                action: WatchAction[type],\n                                path: pathToSend\n                            });\n                        }\n                        [...currentProxyData.callbacks].forEach((cb) => {\n                            cb(WatchAction[type], pathToSend, value);\n                        });\n                    }\n                }\n            }\n        };\n        var realProxy = new Proxy(obj, proxyData);\n        proxyData.baseData = realProxy.__getTarget();\n        onlyDuringInit = false;\n        setProxyPath(realProxy, '');\n        return realProxy;\n    }\n}\n","dependances":[{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Watcher","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"var WatchAction;\n(function (WatchAction) {\n    WatchAction[WatchAction[\"CREATED\"] = 0] = \"CREATED\";\n    WatchAction[WatchAction[\"UPDATED\"] = 1] = \"UPDATED\";\n    WatchAction[WatchAction[\"DELETED\"] = 2] = \"DELETED\";\n})(WatchAction || (WatchAction = {}));\n","dependances":[],"fullName":"Aventus.WatchAction","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"class ResourceLoader {\n    static headerLoaded = {};\n    static headerWaiting = {};\n    /**\n     * Load the resource inside the head tag\n     */\n    static async loadInHead(options) {\n        const _options = this.prepareOptions(options);\n        if (this.headerLoaded[_options.url]) {\n            return true;\n        }\n        else if (this.headerWaiting.hasOwnProperty(_options.url)) {\n            return await this.awaitFctHead(_options.url);\n        }\n        else {\n            this.headerWaiting[_options.url] = [];\n            let tagEl;\n            if (_options.type == \"js\") {\n                tagEl = document.createElement(\"SCRIPT\");\n            }\n            else if (_options.type == \"css\") {\n                tagEl = document.createElement(\"LINK\");\n                tagEl.setAttribute(\"rel\", \"stylesheet\");\n            }\n            else {\n                throw \"unknow type \" + _options.type + \" to append into head\";\n            }\n            document.head.appendChild(tagEl);\n            let result = await this.loadTag(tagEl, _options.url);\n            this.headerLoaded[_options.url] = true;\n            this.releaseAwaitFctHead(_options.url, result);\n            return result;\n        }\n    }\n    static loadTag(tagEl, url) {\n        return new Promise((resolve, reject) => {\n            tagEl.addEventListener(\"load\", (e) => {\n                resolve(true);\n            });\n            tagEl.addEventListener(\"error\", (e) => {\n                resolve(false);\n            });\n            if (tagEl instanceof HTMLLinkElement) {\n                tagEl.setAttribute(\"href\", url);\n            }\n            else {\n                tagEl.setAttribute('src', url);\n            }\n        });\n    }\n    static releaseAwaitFctHead(url, result) {\n        if (this.headerWaiting[url]) {\n            for (let i = 0; i < this.headerWaiting[url].length; i++) {\n                this.headerWaiting[url][i](result);\n            }\n            delete this.headerWaiting[url];\n        }\n    }\n    static awaitFctHead(url) {\n        return new Promise((resolve) => {\n            this.headerWaiting[url].push((result) => {\n                resolve(result);\n            });\n        });\n    }\n    static requestLoaded = {};\n    static requestWaiting = {};\n    /**\n     *\n    */\n    static async load(options) {\n        options = this.prepareOptions(options);\n        if (this.requestLoaded[options.url]) {\n            return this.requestLoaded[options.url];\n        }\n        else if (this.requestWaiting.hasOwnProperty(options.url)) {\n            await this.awaitFct(options.url);\n            return this.requestLoaded[options.url];\n        }\n        else {\n            this.requestWaiting[options.url] = [];\n            let blob = false;\n            if (options.type == \"img\") {\n                blob = true;\n            }\n            let content = await this.fetching(options.url, blob);\n            this.requestLoaded[options.url] = content;\n            this.releaseAwaitFct(options.url);\n            return content;\n        }\n    }\n    static releaseAwaitFct(url) {\n        if (this.requestWaiting[url]) {\n            for (let i = 0; i < this.requestWaiting[url].length; i++) {\n                this.requestWaiting[url][i]();\n            }\n            delete this.requestWaiting[url];\n        }\n    }\n    static awaitFct(url) {\n        return new Promise((resolve) => {\n            this.requestWaiting[url].push(() => {\n                resolve('');\n            });\n        });\n    }\n    static async fetching(url, useBlob = false) {\n        if (useBlob) {\n            let result = await fetch(url, {\n                headers: {\n                    responseType: 'blob'\n                }\n            });\n            let blob = await result.blob();\n            return await this.readFile(blob);\n        }\n        else {\n            let result = await fetch(url);\n            return await result.text();\n        }\n    }\n    static readFile(blob) {\n        return new Promise((resolve) => {\n            var reader = new FileReader();\n            reader.onloadend = function () {\n                resolve(reader.result);\n            };\n            reader.readAsDataURL(blob);\n        });\n    }\n    static imgExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\"];\n    static prepareOptions(options) {\n        let result;\n        if (typeof options === 'string' || options instanceof String) {\n            result = {\n                url: options,\n                type: 'js'\n            };\n            let splittedURI = result.url.split('.');\n            let extension = splittedURI[splittedURI.length - 1];\n            extension = extension.split(\"?\")[0];\n            if (extension == \"svg\") {\n                result.type = 'svg';\n            }\n            else if (extension == \"js\") {\n                result.type = 'js';\n            }\n            else if (extension == \"css\") {\n                result.type = 'css';\n            }\n            else if (this.imgExtensions.indexOf(extension) != -1) {\n                result.type = 'img';\n            }\n            else {\n                throw 'unknow extension found :' + extension + \". Please define your extension inside options\";\n            }\n        }\n        else {\n            result = options;\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.ResourceLoaderHeadOptions","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"Aventus.ResourceLoaderOptions","isStrong":false},{"fullName":"Blob","isStrong":false}],"fullName":"Aventus.ResourceLoader","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class ResizeObserver {\n    callback;\n    targets;\n    fpsInterval;\n    nextFrame;\n    entriesChangedEvent;\n    willTrigger;\n    static resizeObserverClassByObject = {};\n    static uniqueInstance;\n    static getUniqueInstance() {\n        if (!ResizeObserver.uniqueInstance) {\n            ResizeObserver.uniqueInstance = new window.ResizeObserver(entries => {\n                let allClasses = [];\n                for (let j = 0; j < entries.length; j++) {\n                    let entry = entries[j];\n                    let index = entry.target['sourceIndex'];\n                    if (ResizeObserver.resizeObserverClassByObject[index]) {\n                        for (let i = 0; i < ResizeObserver.resizeObserverClassByObject[index].length; i++) {\n                            let classTemp = ResizeObserver.resizeObserverClassByObject[index][i];\n                            classTemp.entryChanged(entry);\n                            if (allClasses.indexOf(classTemp) == -1) {\n                                allClasses.push(classTemp);\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < allClasses.length; i++) {\n                    allClasses[i].triggerCb();\n                }\n            });\n        }\n        return ResizeObserver.uniqueInstance;\n    }\n    constructor(options) {\n        let realOption;\n        if (options instanceof Function) {\n            realOption = {\n                callback: options,\n            };\n        }\n        else {\n            realOption = options;\n        }\n        this.callback = realOption.callback;\n        this.targets = [];\n        if (!realOption.fps) {\n            realOption.fps = 60;\n        }\n        if (realOption.fps != -1) {\n            this.fpsInterval = 1000 / realOption.fps;\n        }\n        this.nextFrame = 0;\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n    }\n    /**\n     * Observe size changing for the element\n     */\n    observe(target) {\n        if (!target[\"sourceIndex\"]) {\n            target[\"sourceIndex\"] = Math.random().toString(36);\n            this.targets.push(target);\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]] = [];\n            ResizeObserver.getUniqueInstance().observe(target);\n        }\n        if (ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].indexOf(this) == -1) {\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].push(this);\n        }\n    }\n    /**\n     * Stop observing size changing for the element\n     */\n    unobserve(target) {\n        for (let i = 0; this.targets.length; i++) {\n            let tempTarget = this.targets[i];\n            if (tempTarget == target) {\n                let position = ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].indexOf(this);\n                if (position != -1) {\n                    ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].splice(position, 1);\n                }\n                if (ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].length == 0) {\n                    delete ResizeObserver.resizeObserverClassByObject[target['sourceIndex']];\n                }\n                ResizeObserver.getUniqueInstance().unobserve(target);\n                this.targets.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Destroy the resize observer\n     */\n    disconnect() {\n        for (let i = 0; this.targets.length; i++) {\n            this.unobserve(this.targets[i]);\n        }\n    }\n    entryChanged(entry) {\n        let index = entry.target.sourceIndex;\n        this.entriesChangedEvent[index] = entry;\n    }\n    triggerCb() {\n        if (!this.willTrigger) {\n            this.willTrigger = true;\n            this._triggerCb();\n        }\n    }\n    _triggerCb() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (this.fpsInterval != -1 && elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => {\n                this._triggerCb();\n            });\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        let changed = Object.values(this.entriesChangedEvent);\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n        setTimeout(() => {\n            this.callback(changed);\n        }, 0);\n    }\n}\n","dependances":[{"fullName":"CallableFunction","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.WindowResizeObserver","isStrong":false},{"fullName":"Aventus.ResizeObserverOptions","isStrong":false}],"fullName":"Aventus.ResizeObserver","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Instance {\n    static elements = new Map();\n    static get(type) {\n        let result = this.elements.get(type);\n        if (!result) {\n            let cst = type.prototype['constructor'];\n            result = new cst();\n            this.elements.set(type, result);\n        }\n        return result;\n    }\n    static set(el) {\n        let cst = el.constructor;\n        if (this.elements.get(cst)) {\n            return false;\n        }\n        this.elements.set(cst, el);\n        return true;\n    }\n    static destroy(el) {\n        let cst = el.constructor;\n        return this.elements.delete(cst);\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.Instance","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class HttpRequest {\n    options = {};\n    url = '';\n    /**\n     * Get the right http method inside enum\n     */\n    static getMethod(method) {\n        let genericMethod = method.toLowerCase().trim();\n        if (genericMethod == \"get\") {\n            return HttpRequestMethod.GET;\n        }\n        if (genericMethod == \"post\") {\n            return HttpRequestMethod.POST;\n        }\n        if (genericMethod == \"delete\") {\n            return HttpRequestMethod.DELETE;\n        }\n        if (genericMethod == \"put\") {\n            return HttpRequestMethod.PUT;\n        }\n        if (genericMethod == \"option\") {\n            return HttpRequestMethod.OPTION;\n        }\n        console.error(\"unknow type \" + method + \". I ll return GET by default\");\n        return HttpRequestMethod.GET;\n    }\n    /**\n     * Get http method in string\n     */\n    getMethod(method) {\n        if (method == HttpRequestMethod.GET)\n            return \"GET\";\n        if (method == HttpRequestMethod.POST)\n            return \"POST\";\n        if (method == HttpRequestMethod.DELETE)\n            return \"DELETE\";\n        if (method == HttpRequestMethod.OPTION)\n            return \"OPTION\";\n        if (method == HttpRequestMethod.PUT)\n            return \"PUT\";\n        return \"GET\";\n    }\n    constructor(options) {\n        options = {\n            ...new DefaultHttpRequestOptions(),\n            ...options\n        };\n        let optionsToSend = {\n            method: this.getMethod(options.method),\n        };\n        if (options.data) {\n            if (!options.useJSON) {\n                if (options.data instanceof FormData) {\n                    optionsToSend.body = options.data;\n                }\n                else {\n                    let formData = new FormData();\n                    this.recuFillFormData(options.data, \"\", formData);\n                    optionsToSend.body = formData;\n                }\n            }\n            else {\n                optionsToSend.body = JSON.stringify(options.data);\n                optionsToSend.headers = {};\n                optionsToSend.headers['Content-Type'] = \"application/json\";\n            }\n        }\n        this.options = optionsToSend;\n        this.url = options.url;\n    }\n    recuFillFormData(data, key, form) {\n        if (typeof data === 'object' && data !== null) {\n            if (Array.isArray(data)) {\n                for (let i = 0; i < data.length; i++) {\n                    this.recuFillFormData(data[i], key + '[' + i + ']', form);\n                }\n            }\n            else if (data instanceof Date) {\n                form.append(key, data.toISOString());\n            }\n            else {\n                let props = Object.getOwnPropertyNames(data);\n                for (let prop of props) {\n                    let newKey = key === \"\" ? prop : key + '.' + prop;\n                    this.recuFillFormData(data[prop], newKey, form);\n                }\n            }\n        }\n        else {\n            form.append(key, data);\n        }\n    }\n    /**\n     * Send the http request\n     */\n    async send() {\n        let result = await fetch(this.url, this.options);\n        return result;\n    }\n    /**\n     * Send a get request\n     */\n    static async get(url) {\n        return await fetch(url, {\n            method: \"GET\"\n        });\n    }\n    /**\n     * Send a post request and wait a result in JSON format\n     */\n    static async post(url, data) {\n        let formData = new FormData();\n        for (let key in data) {\n            formData.append(key, data[key]);\n        }\n        const response = await fetch(url, {\n            method: \"POST\",\n            body: formData\n        });\n        const content = await response.json();\n        return new Promise((resolve, reject) => {\n            if (response.ok) {\n                resolve(content);\n            }\n            else {\n                reject(content);\n            }\n        });\n    }\n}\n","dependances":[{"fullName":"RequestInit","isStrong":false},{"fullName":"Aventus.HttpRequestMethod","isStrong":false},{"fullName":"Aventus.DefaultHttpRequestOptions","isStrong":false},{"fullName":"FormData","isStrong":false}],"fullName":"Aventus.HttpRequest","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"var HttpRequestMethod;\n(function (HttpRequestMethod) {\n    HttpRequestMethod[HttpRequestMethod[\"GET\"] = 0] = \"GET\";\n    HttpRequestMethod[HttpRequestMethod[\"POST\"] = 1] = \"POST\";\n    HttpRequestMethod[HttpRequestMethod[\"DELETE\"] = 2] = \"DELETE\";\n    HttpRequestMethod[HttpRequestMethod[\"PUT\"] = 3] = \"PUT\";\n    HttpRequestMethod[HttpRequestMethod[\"OPTION\"] = 4] = \"OPTION\";\n})(HttpRequestMethod || (HttpRequestMethod = {}));\n","dependances":[],"fullName":"Aventus.HttpRequestMethod","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"class DefaultHttpRequestOptions {\n    url = \"\";\n    method = HttpRequestMethod.GET;\n    useJSON = false;\n}\n","dependances":[{"fullName":"Aventus.HttpRequestOptions","isStrong":true},{"fullName":"Aventus.HttpRequestMethod","isStrong":false}],"fullName":"Aventus.DefaultHttpRequestOptions","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class DragAndDrop {\n    /**\n     * Default offset before drag element\n     */\n    static defaultOffsetDrag = 20;\n    pressManager;\n    options;\n    startCursorPosition;\n    startElementPosition;\n    isEnable = true;\n    constructor(options) {\n        this.options = this.getDefaultOptions();\n        this.mergeProperties(options);\n        this.mergeFunctions(options);\n        this.init();\n    }\n    getDefaultOptions() {\n        return {\n            applyDrag: true,\n            element: null,\n            elementTrigger: null,\n            offsetDrag: DragAndDrop.defaultOffsetDrag,\n            shadow: {\n                enable: false,\n                container: document.body,\n                removeOnStop: true,\n                transform: () => { }\n            },\n            strict: false,\n            targets: [],\n            usePercent: false,\n            isDragEnable: () => true,\n            getZoom: () => 1,\n            getOffsetX: () => 0,\n            getOffsetY: () => 0,\n            onPointerDown: (e) => { },\n            onPointerUp: (e) => { },\n            onStart: (e) => { },\n            onMove: (e) => { },\n            onStop: (e) => { },\n            onDrop: (element, targets) => { }\n        };\n    }\n    mergeProperties(options) {\n        if (options.element === void 0) {\n            throw \"You must define the element for the drag&drop\";\n        }\n        this.options.element = options.element;\n        if (options.elementTrigger === void 0) {\n            this.options.elementTrigger = this.options.element;\n        }\n        else {\n            this.options.elementTrigger = options.elementTrigger;\n        }\n        this.defaultMerge(options, \"applyDrag\");\n        this.defaultMerge(options, \"offsetDrag\");\n        this.defaultMerge(options, \"strict\");\n        this.defaultMerge(options, \"targets\");\n        this.defaultMerge(options, \"usePercent\");\n        if (options.shadow !== void 0) {\n            this.options.shadow.enable = options.shadow.enable;\n            if (options.shadow.container !== void 0) {\n                this.options.shadow.container = options.shadow.container;\n            }\n            else {\n                this.options.shadow.container = document.body;\n            }\n            if (options.shadow.removeOnStop !== void 0) {\n                this.options.shadow.removeOnStop = options.shadow.removeOnStop;\n            }\n            if (options.shadow.transform !== void 0) {\n                this.options.shadow.transform = options.shadow.transform;\n            }\n        }\n    }\n    mergeFunctions(options) {\n        this.defaultMerge(options, \"isDragEnable\");\n        this.defaultMerge(options, \"getZoom\");\n        this.defaultMerge(options, \"getOffsetX\");\n        this.defaultMerge(options, \"getOffsetY\");\n        this.defaultMerge(options, \"onPointerDown\");\n        this.defaultMerge(options, \"onPointerUp\");\n        this.defaultMerge(options, \"onStart\");\n        this.defaultMerge(options, \"onMove\");\n        this.defaultMerge(options, \"onStop\");\n        this.defaultMerge(options, \"onDrop\");\n    }\n    defaultMerge(options, name) {\n        if (options[name] !== void 0) {\n            this.options[name] = options[name];\n        }\n    }\n    init() {\n        this.pressManager = new PressManager({\n            element: this.options.elementTrigger,\n            onPressStart: this.onPressStart.bind(this),\n            onPressEnd: this.onPressEnd.bind(this),\n            onDragStart: this.onDragStart.bind(this),\n            onDrag: this.onDrag.bind(this),\n            onDragEnd: this.onDragEnd.bind(this),\n            offsetDrag: this.options.offsetDrag\n        });\n    }\n    draggableElement;\n    positionShadowRelativeToElement;\n    onPressStart(e) {\n        this.options.onPointerDown(e);\n    }\n    onPressEnd(e) {\n        this.options.onPointerUp(e);\n    }\n    onDragStart(e) {\n        this.isEnable = this.options.isDragEnable();\n        if (!this.isEnable) {\n            return;\n        }\n        this.draggableElement = this.options.element;\n        this.startCursorPosition = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        this.startElementPosition = {\n            x: this.draggableElement.offsetLeft,\n            y: this.draggableElement.offsetTop\n        };\n        if (this.options.shadow.enable) {\n            this.draggableElement = this.options.element.cloneNode(true);\n            let elBox = this.options.element.getBoundingClientRect();\n            let containerBox = this.options.shadow.container.getBoundingClientRect();\n            this.positionShadowRelativeToElement = {\n                x: elBox.x - containerBox.x,\n                y: elBox.y - containerBox.y\n            };\n            if (this.options.applyDrag) {\n                this.draggableElement.style.position = \"absolute\";\n                this.draggableElement.style.top = this.positionShadowRelativeToElement.y + this.options.getOffsetY() + 'px';\n                this.draggableElement.style.left = this.positionShadowRelativeToElement.x + this.options.getOffsetX() + 'px';\n            }\n            this.options.shadow.transform(this.draggableElement);\n            this.options.shadow.container.appendChild(this.draggableElement);\n        }\n        this.options.onStart(e);\n    }\n    onDrag(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let zoom = this.options.getZoom();\n        let diff = {\n            x: 0,\n            y: 0\n        };\n        if (this.options.shadow.enable) {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) + this.positionShadowRelativeToElement.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) + this.positionShadowRelativeToElement.y + this.options.getOffsetY(),\n            };\n        }\n        else {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) / zoom + this.startElementPosition.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) / zoom + this.startElementPosition.y + this.options.getOffsetY()\n            };\n        }\n        let newPos = this.setPosition(diff);\n        this.options.onMove(e, newPos);\n    }\n    onDragEnd(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let targets = this.getMatchingTargets();\n        if (this.options.shadow.enable && this.options.shadow.removeOnStop) {\n            this.draggableElement.parentNode?.removeChild(this.draggableElement);\n        }\n        if (targets.length > 0) {\n            this.options.onDrop(this.draggableElement, targets);\n        }\n        this.options.onStop(e);\n    }\n    setPosition(position) {\n        if (this.options.usePercent) {\n            let elementParent = this.draggableElement.offsetParent;\n            const percentLeft = (position.x / elementParent.offsetWidth) * 100;\n            const percentTop = (position.y / elementParent.offsetHeight) * 100;\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = percentLeft + '%';\n                this.draggableElement.style.top = percentTop + '%';\n            }\n            return {\n                x: percentLeft,\n                y: percentTop\n            };\n        }\n        else {\n            if (this.options.applyDrag) {\n                this.draggableElement.style.left = position.x + 'px';\n                this.draggableElement.style.top = position.y + 'px';\n            }\n        }\n        return position;\n    }\n    /**\n     * Get targets within the current element position is matching\n     */\n    getMatchingTargets() {\n        let matchingTargets = [];\n        for (let target of this.options.targets) {\n            const elementCoordinates = this.draggableElement.getBoundingClientRect();\n            const targetCoordinates = target.getBoundingClientRect();\n            let offsetX = this.options.getOffsetX();\n            let offsetY = this.options.getOffsetY();\n            let zoom = this.options.getZoom();\n            targetCoordinates.x += offsetX;\n            targetCoordinates.y += offsetY;\n            targetCoordinates.width *= zoom;\n            targetCoordinates.height *= zoom;\n            if (this.options.strict) {\n                if ((elementCoordinates.x >= targetCoordinates.x && elementCoordinates.x + elementCoordinates.width <= targetCoordinates.x + targetCoordinates.width) &&\n                    (elementCoordinates.y >= targetCoordinates.y && elementCoordinates.y + elementCoordinates.height <= targetCoordinates.y + targetCoordinates.height)) {\n                    matchingTargets.push(target);\n                }\n            }\n            else {\n                let elementLeft = elementCoordinates.x;\n                let elementRight = elementCoordinates.x + elementCoordinates.width;\n                let elementTop = elementCoordinates.y;\n                let elementBottom = elementCoordinates.y + elementCoordinates.height;\n                let targetLeft = targetCoordinates.x;\n                let targetRight = targetCoordinates.x + targetCoordinates.width;\n                let targetTop = targetCoordinates.y;\n                let targetBottom = targetCoordinates.y + targetCoordinates.height;\n                if (!(elementRight < targetLeft ||\n                    elementLeft > targetRight ||\n                    elementBottom < targetTop ||\n                    elementTop > targetBottom)) {\n                    matchingTargets.push(target);\n                }\n            }\n        }\n        return matchingTargets;\n    }\n    /**\n     * Get element currently dragging\n     */\n    getElementDrag() {\n        return this.draggableElement;\n    }\n    /**\n     * Set targets where to drop\n     */\n    setTargets(targets) {\n        this.options.targets = targets;\n    }\n    /**\n     * Destroy the current drag&drop instance\n     */\n    destroy() {\n        this.pressManager.destroy();\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"HTMLElement","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.Coordinate","isStrong":false},{"fullName":"Aventus.DragAndDropOptions","isStrong":false}],"fullName":"Aventus.DragAndDrop","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class PressManager {\n    options;\n    element;\n    subPressManager = [];\n    delayDblPress = 150;\n    delayLongPress = 700;\n    nbPress = 0;\n    offsetDrag = 20;\n    state = {\n        oneActionTriggered: false,\n        isMoving: false,\n    };\n    startPosition = { x: 0, y: 0 };\n    customFcts = {};\n    timeoutDblPress = 0;\n    timeoutLongPress = 0;\n    downEventSaved;\n    actionsName = {\n        press: \"press\",\n        longPress: \"longPress\",\n        dblPress: \"dblPress\",\n        drag: \"drag\"\n    };\n    useDblPress = false;\n    functionsBinded = {\n        downAction: (e) => { },\n        upAction: (e) => { },\n        moveAction: (e) => { },\n        childPressStart: (e) => { },\n        childPressEnd: (e) => { },\n        childPress: (e) => { },\n        childDblPress: (e) => { },\n        childLongPress: (e) => { },\n        childDragStart: (e) => { },\n    };\n    /**\n     * @param {*} options - The options\n     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage\n     */\n    constructor(options) {\n        if (options.element === void 0) {\n            throw 'You must provide an element';\n        }\n        if (Array.isArray(options.element)) {\n            for (let el of options.element) {\n                let cloneOpt = { ...options };\n                cloneOpt.element = el;\n                this.subPressManager.push(new PressManager(cloneOpt));\n            }\n        }\n        else {\n            this.element = options.element;\n            this.checkDragConstraint(options);\n            this.assignValueOption(options);\n            this.options = options;\n            this.init();\n        }\n    }\n    /**\n     * Get the current element focused by the PressManager\n     */\n    getElement() {\n        return this.element;\n    }\n    checkDragConstraint(options) {\n        if (options.onDrag !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragStart !== void 0) {\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragEnd !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n        }\n    }\n    assignValueOption(options) {\n        if (options.delayDblPress !== undefined) {\n            this.delayDblPress = options.delayDblPress;\n        }\n        if (options.delayLongPress !== undefined) {\n            this.delayLongPress = options.delayLongPress;\n        }\n        if (options.offsetDrag !== undefined) {\n            this.offsetDrag = options.offsetDrag;\n        }\n        if (options.onDblPress !== undefined) {\n            this.useDblPress = true;\n        }\n        if (options.forceDblPress) {\n            this.useDblPress = true;\n        }\n    }\n    bindAllFunction() {\n        this.functionsBinded.downAction = this.downAction.bind(this);\n        this.functionsBinded.moveAction = this.moveAction.bind(this);\n        this.functionsBinded.upAction = this.upAction.bind(this);\n        this.functionsBinded.childDblPress = this.childDblPress.bind(this);\n        this.functionsBinded.childDragStart = this.childDragStart.bind(this);\n        this.functionsBinded.childLongPress = this.childLongPress.bind(this);\n        this.functionsBinded.childPress = this.childPress.bind(this);\n        this.functionsBinded.childPressStart = this.childPressStart.bind(this);\n        this.functionsBinded.childPressEnd = this.childPressEnd.bind(this);\n    }\n    init() {\n        this.bindAllFunction();\n        this.element.addEventListener(\"pointerdown\", this.functionsBinded.downAction);\n        this.element.addEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n        this.element.addEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n        this.element.addEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n        this.element.addEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n        this.element.addEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n        this.element.addEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n    }\n    downAction(e) {\n        this.downEventSaved = e;\n        e.stopImmediatePropagation();\n        this.customFcts = {};\n        if (this.nbPress == 0) {\n            this.state.oneActionTriggered = false;\n            clearTimeout(this.timeoutDblPress);\n        }\n        this.startPosition = { x: e.pageX, y: e.pageY };\n        document.addEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.addEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        this.timeoutLongPress = setTimeout(() => {\n            if (!this.state.oneActionTriggered) {\n                if (this.options.onLongPress) {\n                    this.state.oneActionTriggered = true;\n                    this.options.onLongPress(e, this);\n                    this.triggerEventToParent(this.actionsName.longPress, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"longpress\", e);\n                }\n            }\n        }, this.delayLongPress);\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e, this);\n            this.emitTriggerFunction(\"pressstart\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressstart\", e);\n        }\n    }\n    upAction(e) {\n        e.stopImmediatePropagation();\n        document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n        document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        clearTimeout(this.timeoutLongPress);\n        if (this.state.isMoving) {\n            this.state.isMoving = false;\n            if (this.options.onDragEnd) {\n                this.options.onDragEnd(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDragEnd) {\n                this.customFcts.onDragEnd(e, this.customFcts.src);\n            }\n        }\n        else {\n            if (this.useDblPress) {\n                this.nbPress++;\n                if (this.nbPress == 2) {\n                    if (!this.state.oneActionTriggered) {\n                        this.state.oneActionTriggered = true;\n                        this.nbPress = 0;\n                        if (this.options.onDblPress) {\n                            this.options.onDblPress(e, this);\n                            this.triggerEventToParent(this.actionsName.dblPress, e);\n                        }\n                        else {\n                            this.emitTriggerFunction(\"dblpress\", e);\n                        }\n                    }\n                }\n                else if (this.nbPress == 1) {\n                    this.timeoutDblPress = setTimeout(() => {\n                        this.nbPress = 0;\n                        if (!this.state.oneActionTriggered) {\n                            if (this.options.onPress) {\n                                this.state.oneActionTriggered = true;\n                                this.options.onPress(e, this);\n                                this.triggerEventToParent(this.actionsName.press, e);\n                            }\n                            else {\n                                this.emitTriggerFunction(\"press\", e);\n                            }\n                        }\n                    }, this.delayDblPress);\n                }\n            }\n            else {\n                if (!this.state.oneActionTriggered) {\n                    if (this.options.onPress) {\n                        this.state.oneActionTriggered = true;\n                        this.options.onPress(e, this);\n                        this.triggerEventToParent(this.actionsName.press, e);\n                    }\n                    else {\n                        this.emitTriggerFunction(\"press\", e);\n                    }\n                }\n            }\n        }\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e, this);\n            this.emitTriggerFunction(\"pressend\", e, this.element.parentElement);\n        }\n        else {\n            this.emitTriggerFunction(\"pressend\", e);\n        }\n    }\n    moveAction(e) {\n        if (!this.state.isMoving && !this.state.oneActionTriggered) {\n            e.stopImmediatePropagation();\n            let xDist = e.pageX - this.startPosition.x;\n            let yDist = e.pageY - this.startPosition.y;\n            let distance = Math.sqrt(xDist * xDist + yDist * yDist);\n            if (distance > this.offsetDrag) {\n                this.state.oneActionTriggered = true;\n                if (this.options.onDragStart) {\n                    this.state.isMoving = true;\n                    this.options.onDragStart(this.downEventSaved, this);\n                    this.triggerEventToParent(this.actionsName.drag, e);\n                }\n                else {\n                    this.emitTriggerFunction(\"dragstart\", this.downEventSaved);\n                }\n            }\n        }\n        else if (this.state.isMoving) {\n            if (this.options.onDrag) {\n                this.options.onDrag(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDrag) {\n                this.customFcts.onDrag(e, this.customFcts.src);\n            }\n        }\n    }\n    triggerEventToParent(eventName, pointerEvent) {\n        if (this.element.parentNode) {\n            this.element.parentNode.dispatchEvent(new CustomEvent(\"pressaction_trigger\", {\n                bubbles: true,\n                cancelable: false,\n                composed: true,\n                detail: {\n                    target: this.element,\n                    eventName: eventName,\n                    realEvent: pointerEvent\n                }\n            }));\n        }\n    }\n    childPressStart(e) {\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e.detail.realEvent, this);\n        }\n    }\n    childPressEnd(e) {\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e.detail.realEvent, this);\n        }\n    }\n    childPress(e) {\n        if (this.options.onPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.press, e.detail.realEvent);\n        }\n    }\n    childDblPress(e) {\n        if (this.options.onDblPress) {\n            e.stopImmediatePropagation();\n            if (e.detail.state) {\n                e.detail.state.oneActionTriggered = true;\n            }\n            this.options.onDblPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.dblPress, e.detail.realEvent);\n        }\n    }\n    childLongPress(e) {\n        if (this.options.onLongPress) {\n            e.stopImmediatePropagation();\n            e.detail.state.oneActionTriggered = true;\n            this.options.onLongPress(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.longPress, e.detail.realEvent);\n        }\n    }\n    childDragStart(e) {\n        if (this.options.onDragStart) {\n            e.stopImmediatePropagation();\n            e.detail.state.isMoving = true;\n            e.detail.customFcts.src = this;\n            e.detail.customFcts.onDrag = this.options.onDrag;\n            e.detail.customFcts.onDragEnd = this.options.onDragEnd;\n            e.detail.customFcts.offsetDrag = this.options.offsetDrag;\n            this.options.onDragStart(e.detail.realEvent, this);\n            this.triggerEventToParent(this.actionsName.drag, e.detail.realEvent);\n        }\n    }\n    emitTriggerFunction(action, e, el = null) {\n        let ev = new CustomEvent(\"trigger_pointer_\" + action, {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n            detail: {\n                state: this.state,\n                customFcts: this.customFcts,\n                realEvent: e\n            }\n        });\n        if (!el) {\n            el = this.element;\n        }\n        el.dispatchEvent(ev);\n    }\n    /**\n     * Destroy the Press instance byremoving all events\n     */\n    destroy() {\n        for (let sub of this.subPressManager) {\n            sub.destroy();\n        }\n        if (this.element) {\n            this.element.removeEventListener(\"pointerdown\", this.functionsBinded.downAction);\n            this.element.removeEventListener(\"trigger_pointer_press\", this.functionsBinded.childPress);\n            this.element.removeEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n            this.element.removeEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n            this.element.removeEventListener(\"trigger_pointer_dblpress\", this.functionsBinded.childDblPress);\n            this.element.removeEventListener(\"trigger_pointer_longpress\", this.functionsBinded.childLongPress);\n            this.element.removeEventListener(\"trigger_pointer_dragstart\", this.functionsBinded.childDragStart);\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Element","isStrong":false},{"fullName":"Aventus.PressManagerState","isStrong":false},{"fullName":"Aventus.InternalCustomFunction","isStrong":false},{"fullName":"PointerEvent","isStrong":false},{"fullName":"Aventus.InternalPointerEvent","isStrong":false}],"fullName":"Aventus.PressManager","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Callback {\n    callbacks = [];\n    /**\n     * Clear all callbacks\n     */\n    clear() {\n        this.callbacks = [];\n    }\n    /**\n     * Add a callback\n     */\n    add(cb) {\n        this.callbacks.push(cb);\n    }\n    /**\n     * Remove a callback\n     */\n    remove(cb) {\n        let index = this.callbacks.indexOf(cb);\n        if (index != -1) {\n            this.callbacks.splice(index, 1);\n        }\n    }\n    /**\n     * Trigger all callbacks\n     */\n    trigger(args) {\n        let result = [];\n        for (let callback of this.callbacks) {\n            result.push(callback.apply(null, args));\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.Callback","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class CallbackGroup {\n    callbacks = {};\n    /**\n     * Clear all callbacks\n     */\n    clearAll() {\n        this.callbacks = {};\n    }\n    /**\n     * Clear all callbacks for a specific group\n     */\n    clear(group) {\n        delete this.callbacks[group];\n    }\n    /**\n     * Add a callback for a group\n     */\n    add(group, cb) {\n        if (!this.callbacks[group]) {\n            this.callbacks[group] = [];\n        }\n        this.callbacks[group].push(cb);\n    }\n    /**\n     * Remove a callback for a group\n     */\n    remove(group, cb) {\n        if (this.callbacks[group]) {\n            let index = this.callbacks[group].indexOf(cb);\n            if (index != -1) {\n                this.callbacks[group].splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Trigger all callbacks inside a group\n     */\n    trigger(group, args) {\n        if (this.callbacks[group]) {\n            for (let callback of this.callbacks[group]) {\n                callback.apply(null, args);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.CallbackGroup","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Animation {\n    /**\n     * Default FPS for all Animation if not set inside options\n     */\n    static FPS_DEFAULT = 60;\n    options;\n    nextFrame;\n    fpsInterval;\n    continueAnimation = false;\n    constructor(options) {\n        if (!options.animate) {\n            options.animate = () => { };\n        }\n        if (!options.stopped) {\n            options.stopped = () => { };\n        }\n        if (!options.fps) {\n            options.fps = Animation.FPS_DEFAULT;\n        }\n        this.options = options;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    animate() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => this.animate());\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        setTimeout(() => {\n            this.options.animate();\n        }, 0);\n        if (this.continueAnimation) {\n            requestAnimationFrame(() => this.animate());\n        }\n        else {\n            this.options.stopped();\n        }\n    }\n    /**\n     * Start the of animation\n     */\n    start() {\n        if (this.continueAnimation == false) {\n            this.continueAnimation = true;\n            this.nextFrame = window.performance.now();\n            this.animate();\n        }\n    }\n    /**\n     * Stop the animation\n     */\n    stop() {\n        this.continueAnimation = false;\n    }\n    /**\n     * Get the FPS\n     */\n    getFPS() {\n        return this.options.fps;\n    }\n    /**\n     * Set the FPS\n     */\n    setFPS(fps) {\n        this.options.fps = fps;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    /**\n     * Get the animation status (true if animation is running)\n     */\n    isStarted() {\n        return this.continueAnimation;\n    }\n}\n","dependances":[{"fullName":"Aventus.AnimationOptions","isStrong":false}],"fullName":"Aventus.Animation","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class DataManager {\n    static info = new Map();\n    /**\n     * Register a unique string type for a data\n     */\n    static register($type, cst) {\n        this.info.set($type, cst);\n    }\n    /**\n     * Get the contructor for the unique string type\n     */\n    static getConstructor($type) {\n        let result = this.info.get($type);\n        if (result) {\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Clone the object to keep real type\n     */\n    static clone(data) {\n        return this.createObject(JSON.parse(JSON.stringify(data)));\n    }\n    /**\n     * Create an object with the type management\n     * Usefull to convert object from JSON into Js class\n     */\n    static createObject(data, transfromToDate = false) {\n        if (typeof data === 'object' && data !== null) {\n            if (data instanceof Date) {\n                return data;\n            }\n            if (Array.isArray(data)) {\n                let result = [];\n                for (let element of data) {\n                    result.push(this.createObject(element));\n                }\n                return result;\n            }\n            if (data.$type) {\n                let cst = DataManager.getConstructor(data.$type);\n                if (cst) {\n                    let obj = new cst();\n                    let props = Object.getOwnPropertyNames(obj);\n                    for (let prop of props) {\n                        if (data[prop] !== undefined) {\n                            let propInfo = Object.getOwnPropertyDescriptor(obj, prop);\n                            if (propInfo.writable) {\n                                if (obj[prop] instanceof Date) {\n                                    obj[prop] = this.createObject(data[prop], true);\n                                }\n                                else {\n                                    obj[prop] = this.createObject(data[prop]);\n                                }\n                            }\n                        }\n                    }\n                    return obj;\n                }\n            }\n            else {\n                let result = {};\n                for (let key in data) {\n                    result[key] = this.createObject(data[key]);\n                }\n                return result;\n            }\n        }\n        else if (transfromToDate && typeof data === \"string\") {\n            return new Date(data);\n        }\n        return data;\n    }\n}\n","dependances":[{"fullName":"Map","isStrong":false}],"fullName":"Aventus.DataManager","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Data {\n    /**\n     * The schema for the class\n     */\n    static get $schema() { return {}; }\n    /**\n     * The current namespace\n     */\n    static get Namespace() { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * Get the name of the class\n     */\n    get className() {\n        return this.constructor.name;\n    }\n    /**\n     * Get a JSON for the current object\n     */\n    toJSON() {\n        let result = { $type: this.$type };\n        let props = Object.getOwnPropertyNames(this);\n        for (let prop of props) {\n            let propInfo = Object.getOwnPropertyDescriptor(this, prop);\n            if (propInfo.writable) {\n                result[prop] = this[prop];\n            }\n        }\n        return result;\n    }\n}\n","dependances":[{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Aventus.DataManager","isStrong":true}],"fullName":"Aventus.Data","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class RamError extends GenericError {\n}\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Aventus.RamErrorCode","isStrong":true}],"fullName":"Aventus.RamError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class ResultRamWithError extends ResultWithError {\n}\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"Aventus.RamError","isStrong":true}],"fullName":"Aventus.ResultRamWithError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"class Socket {\n    options;\n    waitingList = {};\n    multipltWaitingList = {};\n    timeoutError;\n    memoryBeforeOpen = [];\n    socket;\n    constructor() {\n        this._configure(this.configure({}));\n    }\n    /**\n     * Configure a new Websocket\n     */\n    _configure(options = {}) {\n        if (!options.host) {\n            options.host = window.location.hostname;\n        }\n        if (!options.hasOwnProperty('useHttps')) {\n            options.useHttps = window.location.protocol == \"https:\";\n        }\n        if (!options.port) {\n            if (window.location.port) {\n                options.port = parseInt(window.location.port);\n            }\n            else {\n                options.port = options.useHttps ? 443 : 80;\n            }\n        }\n        if (!options.routes) {\n            options.routes = {};\n        }\n        if (!options.socketName) {\n            options.socketName = \"\";\n        }\n        this.options = options;\n    }\n    /**\n     * Add a new route to listen to the websocket\n     */\n    addRoute(newRoute) {\n        if (!this.options.routes.hasOwnProperty(newRoute.channel)) {\n            this.options.routes[newRoute.channel] = [];\n        }\n        this.options.routes[newRoute.channel].push(newRoute);\n    }\n    /**\n     * The route to remove\n     * @param route - The route to remove\n     */\n    removeRoute(route) {\n        let index = this.options.routes[route.channel].indexOf(route);\n        if (index != -1) {\n            this.options.routes[route.channel].splice(index, 1);\n        }\n    }\n    openCallback;\n    /**\n     * Try to open the websocket\n     */\n    open() {\n        return new Promise((resolve) => {\n            try {\n                if (this.socket) {\n                    this.socket.close();\n                }\n                let protocol = \"ws\";\n                if (this.options.useHttps) {\n                    protocol = \"wss\";\n                }\n                let url = protocol + \"://\" + this.options.host + \":\" + this.options.port + \"/ws/\" + this.options.socketName;\n                this.log(url);\n                this.openCallback = (isOpen) => {\n                    resolve(isOpen);\n                };\n                this.socket = new WebSocket(url);\n                this.socket.onopen = this._onOpen.bind(this);\n                this.socket.onclose = this._onClose.bind(this);\n                this.socket.onerror = this._onError.bind(this);\n                this.socket.onmessage = this.onMessage.bind(this);\n            }\n            catch (e) {\n                console.log(e);\n                resolve(false);\n            }\n        });\n    }\n    jsonReplacer(key, value) {\n        if (this[key] instanceof Date && this[key].getFullYear() < 100) {\n            return \"0001-01-01T00:00:00\";\n        }\n        return value;\n    }\n    /**\n     * Send a message though the websocket\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param options the options to add to the message (typically the uid)\n     */\n    sendMessage(channelName, data = null, options = {}) {\n        if (this.socket && this.socket.readyState == 1) {\n            let message = {\n                channel: channelName,\n            };\n            for (let key in options) {\n                message[key] = options[key];\n            }\n            if (data) {\n                message.data = data;\n                this.log(message);\n                if (typeof data != 'string') {\n                    message.data = JSON.stringify(data, this.jsonReplacer);\n                }\n            }\n            else {\n                this.log(message);\n            }\n            this.socket.send(JSON.stringify(message));\n        }\n        else {\n            this.log('Socket not ready ! Please ensure that it is open and ready to send message');\n            this.memoryBeforeOpen.push({\n                channelName: channelName,\n                data: data,\n                options: options\n            });\n        }\n    }\n    /**\n     * Send a message though the websocket and wait one answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWait(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.waitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    ;\n    /**\n     * Send a message though the websocket and wait answer give in parameters callbacks\n     * @param channelName The channel on which the message is sent\n     * @param data The data to send\n     * @param callbacks The callbacks to call. With the channel as key and the callback function as value\n     */\n    sendMessageAndWaitMultiple(channelName, data, callbacks) {\n        let uid = '_' + Math.random().toString(36).substr(2, 9);\n        this.multipltWaitingList[uid] = callbacks;\n        this.sendMessage(channelName, data, {\n            uid: uid\n        });\n    }\n    /**\n     * Check if socket is ready\n     */\n    isReady() {\n        if (this.socket && this.socket.readyState == 1) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Callback when the websocket connection is open\n     */\n    onOpen() {\n    }\n    _onOpen() {\n        if (this.socket && this.socket.readyState == 1) {\n            if (this.openCallback) {\n                this.openCallback(true);\n                this.openCallback = null;\n            }\n            this.log('Connection successfully established !' + this.options.host + \":\" + this.options.port);\n            window.clearTimeout(this.timeoutError);\n            this.onOpen();\n            for (let i = 0; i < this.memoryBeforeOpen.length; i++) {\n                this.sendMessage(this.memoryBeforeOpen[i].channelName, this.memoryBeforeOpen[i].data, this.memoryBeforeOpen[i].options);\n            }\n            this.memoryBeforeOpen = [];\n        }\n        else {\n            if (this.openCallback) {\n                this.openCallback(false);\n                this.openCallback = null;\n            }\n        }\n    }\n    errorOccur;\n    /**\n     * Callback called when the socket as an error\n     */\n    onError(event) {\n    }\n    _onError(event) {\n        this.errorOccur = true;\n        if (this.openCallback) {\n            this.openCallback(false);\n            this.openCallback = null;\n            return;\n        }\n        this.log('An error has occured');\n        this.onError(event);\n    }\n    /**\n     * Callback called when the connection closed without calling the close function\n     * By default the socket will try to reconnect each 5000ms\n     */\n    onClose(event) {\n        let reopenInterval = setInterval(async () => {\n            console.warn(\"try reopen socket \");\n            if (await this.open()) {\n                clearInterval(reopenInterval);\n            }\n        }, 5000);\n    }\n    _onClose(event) {\n        if (this.errorOccur) {\n            this.errorOccur = false;\n            return;\n        }\n        this.log('Closing connection');\n        this.onClose(event);\n    }\n    /**\n     * Close the current connection\n     */\n    close() {\n        if (this.socket) {\n            this.socket.onclose = null;\n            this.socket.onerror = null;\n            this.socket.onmessage = null;\n            this.socket.onopen = null;\n            this.socket.close();\n            delete this.socket;\n        }\n    }\n    onMessage(event) {\n        let response = JSON.parse(event.data);\n        this.log(response);\n        response.data = JSON.parse(response.data);\n        if (this.options.routes.hasOwnProperty(response.channel)) {\n            this.options.routes[response.channel].forEach(element => {\n                element.callback(response.data);\n            });\n        }\n        if (response.uid) {\n            if (this.waitingList.hasOwnProperty(response.uid)) {\n                let group = this.waitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    group[response.channel](response.data);\n                }\n                delete this.waitingList[response.uid];\n            }\n            else if (this.multipltWaitingList.hasOwnProperty(response.uid)) {\n                let group = this.multipltWaitingList[response.uid];\n                if (group.hasOwnProperty(response.channel)) {\n                    try {\n                        group[response.channel](response.data);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                }\n                delete this.multipltWaitingList[response.uid];\n            }\n        }\n    }\n    /**\n     * Print a msg inside the console\n     */\n    log(message) {\n        if (this.options.log) {\n            const now = new Date();\n            const hours = (now.getHours()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const minutes = (now.getMinutes()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            const seconds = (now.getSeconds()).toLocaleString(undefined, { minimumIntegerDigits: 2 });\n            if (message instanceof Object) {\n                let cloneMessage = JSON.parse(JSON.stringify(message, this.jsonReplacer));\n                if (cloneMessage.data && typeof cloneMessage.data == 'string') {\n                    cloneMessage.data = JSON.parse(cloneMessage.data);\n                }\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, cloneMessage);\n            }\n            else {\n                console.log(`[WEBSOCKET] [${hours}:${minutes}:${seconds}]: `, message);\n            }\n        }\n    }\n}\n","dependances":[{"fullName":"Aventus.ISocket","isStrong":true},{"fullName":"Aventus.SocketOptions","isStrong":false},{"fullName":"Aventus.SocketRoute","isStrong":false},{"fullName":"Aventus.SocketMessage","isStrong":false},{"fullName":"Event","isStrong":false},{"fullName":"MessageEvent","isStrong":false}],"fullName":"Aventus.Socket","required":false,"type":1,"isExported":true,"convertibleName":""}],"existing":[{"fullName":"Aventus.Loop","dependances":[]},{"fullName":"Aventus.ActionEventCallback","dependances":[]},{"fullName":"Aventus.ActionEventListener","dependances":[]},{"fullName":"Aventus.ActionBindings","dependances":[]},{"fullName":"Aventus.ActionInjection","dependances":[]},{"fullName":"Aventus.ActionChange","dependances":[]},{"fullName":"Aventus.ActionEvent","dependances":[]},{"fullName":"Aventus.ContextValues","dependances":[]},{"fullName":"Aventus.Actions","dependances":[]},{"fullName":"Aventus.ContextSchema","dependances":[]},{"fullName":"Aventus.WebComponentTemplateHTML","dependances":[]},{"fullName":"Aventus.DefaultComponent","dependances":[]},{"fullName":"Aventus.DebuggerConfig","dependances":[]},{"fullName":"Aventus.Subscriber","dependances":[]},{"fullName":"Aventus.StateAskChangeFct","dependances":[]},{"fullName":"Aventus.StateInactivationFct","dependances":[]},{"fullName":"Aventus.StateActivationFct","dependances":[]},{"fullName":"Aventus.StateSlug","dependances":[]},{"fullName":"Aventus.StateAction","dependances":[]},{"fullName":"Aventus.SocketMessage","dependances":[]},{"fullName":"Aventus.SocketRoute","dependances":[]},{"fullName":"Aventus.SocketOptions","dependances":[]},{"fullName":"Aventus.ISocket","dependances":[]},{"fullName":"Aventus.RamWsCallback","dependances":[]},{"fullName":"Aventus.RamWsRoute","dependances":[]},{"fullName":"Aventus.RamWsRoutes","dependances":[]},{"fullName":"Aventus.KeysObject","dependances":[]},{"fullName":"Aventus.RamItem","dependances":[]},{"fullName":"Aventus.RamSubscribers","dependances":[]},{"fullName":"Aventus.IRamAction","dependances":[]},{"fullName":"Aventus.IRam","dependances":[]},{"fullName":"Aventus.ResourceLoaderHeadOptions","dependances":[]},{"fullName":"Aventus.ResourceLoaderOptions","dependances":[]},{"fullName":"Aventus.WindowResizeObserver","dependances":[]},{"fullName":"Aventus.ResizeObserverOptions","dependances":[]},{"fullName":"Aventus.Pointer","dependances":[]},{"fullName":"Aventus.HttpRequestOptions","dependances":[]},{"fullName":"Aventus.InternalPointerEvent","dependances":[{"fullName":"Event","isStrong":true}]},{"fullName":"Aventus.InternalCustomFunction","dependances":[]},{"fullName":"Aventus.PressManagerState","dependances":[]},{"fullName":"Aventus.PressManagerOptions","dependances":[]},{"fullName":"Aventus.Coordinate","dependances":[]},{"fullName":"Aventus.DragAndDropOptions","dependances":[]},{"fullName":"Aventus.AnimationOptions","dependances":[]},{"fullName":"Aventus.IData","dependances":[]}]}
>>>>>>> 90655bf (change server to map with cli easier)
//#endregion js src //
//#region css def //
{}
//#endregion css def //
//#region css //
{}
//#endregion css //
//#region html //
{}
//#endregion html //
//#region dependances //
[]
//#endregion dependances //
