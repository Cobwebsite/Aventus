// Aventus@Main:1.0.3
// npm:@aventusjs/main
//#region js def //
declare global {

namespace Aventus{
@Storybook({
    prefix: "Webcomponent"
})
interface DebuggerConfig {
    writeCompiled?: boolean;
}

@Storybook({
    prefix: "Webcomponent"
})
class Style {
    private static instance;
    static noAnimation: CSSStyleSheet;
    private static defaultStyleSheets;
    static store(name: string, content: string): void;
    static get(name: string): CSSStyleSheet;
    static getAsString(name: string): string;
    static sheetToString(stylesheet: CSSStyleSheet): string;
    static load(name: string, url: string): Promise<void>;
    static appendToHead(name: string): void;
    static refreshHead(name: string): void;
    private static getInstance;
    private constructor();
    private stylesheets;
    load(name: string, url: string): Promise<void>;
    store(name: string, content: string): any;
    get(name: string): CSSStyleSheet;
    getAsString(name: string): string;
    sheetToString(stylesheet: CSSStyleSheet): string;
}

@Storybook({
    prefix: "Webcomponent"
})
interface DefaultComponent {
    [key: string]: any;
}

function uuidv4(): string;

function sleep(ms: number): Promise<void>;

type StringLiteral<T> = T extends string ? string extends T ? never : T : never;

type Constructor<T> = abstract new (...args: any[]) => T;

type AnyConstructor = ___Aventus.OnlyConstructor | {};

function isSubclassOf(subClass: Function, superClass: Function): boolean;

function isClass(v: any): boolean;

function setValueToObject(path: string, obj: any, value: any): void;

@Storybook({
    prefix: "Tools/Mutex"
})
class Mutex {
    /**
     * Array to store functions waiting for the mutex to become available.
     * @type {((run: boolean) => void)[]}
     */
    private waitingList;
    /**
    * Indicates whether the mutex is currently locked or not.
    * @type {boolean}
    */
    private isLocked;
    /**
    * Waits for the mutex to become available and then acquires it.
    * @returns {Promise<boolean>} A Promise that resolves to true if the mutex was acquired successfully.
    */
    waitOne(): any;
    /**
     * Release the mutex
     */
    release(): void;
    /**
     * Releases the mutex, allowing only the last function in the waiting list to acquire it.
     */
    releaseOnlyLast(): void;
    /**
     * Clears the mutex, removing all waiting functions and releasing the lock.
     */
    dispose(): void;
    /**
     * Executes a callback function safely within the mutex lock and releases the lock afterward.
     * @template T - The type of the return value of the callback function.
     * @param {() => T} cb - The callback function to execute.
     * @returns {Promise<T | null>} A Promise that resolves to the result of the callback function or null if an error occurs.
     */
    safeRun<T = void>(cb: () => T): Promise<T | null>;
    /**
     * Executes an asynchronous callback function safely within the mutex lock and releases the lock afterward.
     * @template T - The type of the return value of the asynchronous callback function.
     * @param {() => Promise<T>} cb - The asynchronous callback function to execute.
     * @returns {Promise<T | null>} A Promise that resolves to the result of the asynchronous callback function or null if an error occurs.
     */
    safeRunAsync<T = void>(cb: () => Promise<T>): Promise<T | null>;
    /**
     * Executes a callback function safely within the mutex lock, allowing only the last function in the waiting list to acquire the lock, and releases the lock afterward.
     * @template T - The type of the return value of the callback function.
     * @param {() => T} cb - The callback function to execute.
     * @returns {Promise<T | null>} A Promise that resolves to the result of the callback function or null if an error occurs.
     */
    safeRunLast<T = void>(cb: () => T): Promise<T | null>;
    /**
     * Executes an asynchronous callback function safely within the mutex lock, allowing only the last function in the waiting list to acquire the lock, and releases the lock afterward.
     * @template T - The type of the return value of the asynchronous callback function.
     * @param {() => Promise<T>} cb - The asynchronous callback function to execute.
     * @returns {Promise<T | undefined>} A Promise that resolves to the result of the asynchronous callback function or undefined if an error occurs.
     */
    safeRunLastAsync<T = void>(cb: () => Promise<T>): Promise<T | undefined>;
}

@Storybook({
    prefix: "Tools/Mutex"
})
class ActionGuard {
    /**
     * Map to store actions that are currently running.
     * @type {Map<any[], ((res: any) => void)[]>}
     * @private
     */
    private runningAction;
    /**
     * Executes an action uniquely based on the specified keys.
     * @template T
     * @param {any[]} keys The keys associated with the action.
     * @param {() => Promise<T>} action The action to execute.
     * @returns {Promise<T>} A promise that resolves with the result of the action.
     * @example
     *
     *
     * const actionGuard = new Aventus.ActionGuard();
     *
     *
     * const keys = ["key1", "key2"];
     *
     *
     * const action = async () => {
     *
     *     await new Promise(resolve => setTimeout(resolve, 1000));
     *     return "Action executed";
     * };
     *
     *
     * await actionGuard.run(keys, action)
     *
     */
    run<T extends any>(keys: any[], action: () => Promise<T>): Promise<T>;
    run<T extends any>(action: () => Promise<T>): Promise<T>;
}

type KeysObject<T> = {
    [Key in keyof T]?: any;
};

@Storybook({
    prefix: "Ram"
})
interface IRam {
}

enum RamErrorCode {
    unknow = 0,
    noId = 1,
    noItemInsideRam = 2
}

type UriParamsValue = {
    [paramName: string]: string | number;
};

type StateSlug = UriParamsValue;

type UriParams = {
    name: string;
    type: "number" | "string";
    position: number;
};

@Storybook({
    prefix: "Lib/ResourceLoader"
})
interface ResourceLoaderHeadOptions {
    url: string;
    type: 'js' | 'css';
}

@Storybook({
    prefix: "Lib/ResourceLoader"
})
interface ResourceLoaderOptions {
    url: string;
    type?: 'js' | 'css' | 'img' | 'svg';
}

@Storybook({
    prefix: "Lib/ResourceLoader"
})
class ResourceLoader {
    private static headerLoaded;
    private static headerWaiting;
    /**
     * Load the resource inside the head tag
     */
    static loadInHead(options: ResourceLoaderHeadOptions | string): Promise<boolean>;
    private static loadTag;
    private static releaseAwaitFctHead;
    private static awaitFctHead;
    private static requestLoaded;
    private static requestWaiting;
    /**
     *
    */
    static load(options: ResourceLoaderOptions | string): Promise<string>;
    private static releaseAwaitFct;
    private static awaitFct;
    private static fetching;
    private static readFile;
    private static imgExtensions;
    private static prepareOptions;
}

@Storybook({
    prefix: "Lib/ResizeObserver"
})
interface ResizeObserverOptions {
    callback: CallableFunction;
    fps?: number;
}

@Storybook({
    prefix: "Lib/PressManager"
})
interface Pointer {
    id: number;
    constructor(nativePointer: Touch | PointerEvent): any;
}

@Storybook({
    prefix: "Lib/Instance"
})
class Instance {
    private static elements;
    static get<X>(type: Function & {
        prototype: X;
    }): X;
    static set<X extends {
        constructor: any;
    }>(el: X): boolean;
    static destroy<X extends {
        constructor: any;
    }>(el: X): boolean;
}

const DragElementXYType: readonly [any, any, any, any];

const DragElementLeftTopType: readonly [any, any];

@Storybook({
    prefix: "Lib/PressManager"
})
interface PressManagerState {
    oneActionTriggered: PressManager | null;
}

class NormalizedEvent {
    private _event;
    get event(): PointerEvent | TouchEvent;
    constructor(event: PointerEvent | TouchEvent);
    getProp<T>(prop: keyof PointerEvent | keyof TouchEvent): T | undefined;
    stopImmediatePropagation(): void;
    get clientX(): number;
    get clientY(): number;
    get pageX(): number;
    get pageY(): number;
    get type(): string;
    get target(): EventTarget | null;
    get timeStamp(): number;
    get pointerType(): string | undefined;
    get button(): number | undefined;
    get isTouch(): boolean;
}

@Storybook({
    prefix: "Lib/PressManager"
})
interface InternalCustomFunction {
    src?: PressManager;
    onDrag?: (e: NormalizedEvent, self: PressManager) => void;
    onDragEnd?: (e: NormalizedEvent, self: PressManager) => void;
    offsetDrag?: number;
}

@Storybook({
    prefix: "Lib/PressManager"
})
interface InternalPointerEvent extends Event {
    detail: {
        state: PressManagerState;
        customFcts: InternalCustomFunction;
        realEvent: NormalizedEvent;
    };
}

@Storybook({
    prefix: "Lib/PressManager"
})
interface PressManagerOptions {
    /**
     * The element to be managed by PressManager.
     */
    element: Element;
    /**
     * Callback function triggered on a press event.
     * If false returns it means that no action has been triggered and this wont block others actions
     * @param e - The NormalizedEvent associated with the press.
     * @param self - The instance of PressManager.
     */
    onPress?: (e: NormalizedEvent, self: PressManager) => void | boolean;
    /**
     * Callback function triggered when a press starts.
     * @param e - The NormalizedEvent associated with the press start.
     * @param self - The instance of PressManager.
     */
    onPressStart?: (e: NormalizedEvent, self: PressManager) => void;
    /**
     * Callback function triggered when a press ends.
     * @param e - The NormalizedEvent associated with the press end.
     * @param self - The instance of PressManager.
     */
    onPressEnd?: (e: NormalizedEvent, self: PressManager) => void;
    /**
     * Callback function triggered on a long press.
     * If false returns it means that no action has been triggered and this wont block others actions
     * @param e - The NormalizedEvent associated with the long press.
     * @param self - The instance of PressManager.
     */
    onLongPress?: (e: NormalizedEvent, self: PressManager) => void | boolean;
    /**
     * Callback function triggered on a double press.
     * If false returns it means that no action has been triggered and this wont block others actions
     * @param e - The NormalizedEvent associated with the double press.
     * @param self - The instance of PressManager.
     */
    onDblPress?: (e: NormalizedEvent, self: PressManager) => void | boolean;
    /**
    * Callback function triggered on a drag event.
    * @param e - The NormalizedEvent associated with the drag.
    * @param self - The instance of PressManager.
    */
    onDrag?: (e: NormalizedEvent, self: PressManager) => void;
    /**
    * Callback function triggered when a drag starts.
    * If false returns it means that no action has been triggered and this wont block others actions
    * @param e - The NormalizedEvent associated with the drag start.
    * @param self - The instance of PressManager.
    */
    onDragStart?: (e: NormalizedEvent, self: PressManager) => void | boolean;
    /**
     * Callback function triggered when a drag ends.
     * @param e - The NormalizedEvent associated with the drag end.
     * @param self - The instance of PressManager.
     */
    onDragEnd?: (e: NormalizedEvent, self: PressManager) => void;
    /**
     * The minimum distance in pixels required to trigger a drag event.
     */
    offsetDrag?: number;
    dragDirection?: 'X' | 'Y' | 'XY';
    /**
     * The delay in milliseconds to detect a double press.
     */
    delayDblPress?: number;
    /**
     * The delay in milliseconds to detect a long press.
     */
    delayLongPress?: number;
    forceDblPress?: boolean;
    /**
     * Determines whether to stop the propagation of the event.
     * It can be a boolean or a function that returns a boolean.
     */
    stopPropagation?: boolean | (() => boolean);
    /**
     * Specifies which mouse buttons are allowed to trigger the events.
     * An array of button numbers.
     */
    buttonAllowed?: number[];
    /**
     * Callback function triggered on any event.
     * @param e - The NormalizedEvent associated with the event.
     */
    onEvent?: (e: NormalizedEvent) => void;
}

type DragElementLeftTop = InstanceType<typeof DragElementLeftTopType[number]>;

type DragElementXY = InstanceType<typeof DragElementXYType[number]>;

@Storybook({
    prefix: "Lib/Callback"
})
class Callback<U extends (...args: any) => T, T = void> {
    private callbacks;
    /**
     * Clear all callbacks
     */
    clear(): void;
    /**
     * Add a callback
     */
    add(cb: U, scope?: any): void;
    /**
     * Remove a callback
     */
    remove(cb: U): void;
    /**
     * Trigger all callbacks
     */
    trigger(...args: Parameters<U>): T[];
}

@Storybook({
    prefix: "Lib/Callback"
})
class CallbackGroup<U extends (...args: any) => void> {
    private callbacks;
    /**
     * Clear all callbacks
     */
    clearAll(): void;
    /**
     * Clear all callbacks for a specific group
     */
    clear(group: string | number): void;
    /**
     * Add a callback for a group
     */
    add(group: string | number, cb: U, scope?: any): void;
    /**
     * Remove a callback for a group
     */
    remove(group: string | number, cb: U): void;
    /**
     * Trigger all callbacks inside a group
     */
    trigger(group: string | number, ...args: Parameters<U>): void;
}

type AnimationOptions = Partial<___Aventus.AnimationOptionsInternal>;

@Storybook({
    prefix: "Http"
})
interface RouterOptions {
    url: string;
}

@Storybook({
    prefix: "Http"
})
interface HttpRouterOptions {
    url: string;
}

function compareObject(obj1: any, obj2: any): boolean;

function getValueFromObject(path: string, obj: any): any;

enum WatchAction {
    CREATED = 0,
    UPDATED = 1,
    DELETED = 2
}

type WatcherFunction = (action: WatchAction, path: string, value: any) => void;

type Asyncable<T> = T | Promise<T>;

function Async<T>(el: Asyncable<T>): Promise<T>;

enum HttpMethod {
    GET = "GET",
    POST = "POST",
    DELETE = "DELETE",
    PUT = "PUT",
    OPTION = "OPTION"
}

enum HttpErrorCode {
    unknow = 0
}

type Enum = {
    [key: string]: number | string;
};

type EnumValue<T extends (number | Enum)> = T extends Enum ? T[keyof T] : number;

class DateConverter {
    private static __converter;
    static get converter(): DateConverter;
    static set converter(value: DateConverter);
    isStringDate(txt: string): boolean;
    fromString(txt: string): Date | null;
    toString(date: Date): string;
}

type ClassCopyOptions = {
    isValidKey?: (key: string) => boolean;
    replaceKey?: (key: string) => string;
    transformValue?: (key: string, value: any) => any;
};

type JsonFromOptions = {
    transformValue?: (key: string, value: any) => any;
    replaceUndefined?: boolean;
    replaceUndefinedWithKey?: boolean;
};

type JsonToOptions = {
    isValidKey?: (key: string) => boolean;
    replaceKey?: (key: string) => string;
    transformValue?: (key: string, value: any) => any;
    beforeEnd?: (result: {
        [key: string | number]: any;
    }) => {
        [key: string | number]: any;
    };
};

@Storybook({
    prefix: "Data"
})
interface IData {
    /**
     * Get the unique type for the data. Define it as the fullnamespace + class name
     */
    get $type(): string;
    /**
     * Clone the object
     */
    clone(): this;
}

@Storybook({
    prefix: "Tools/Json"
})
class Json {
    /**
     * Converts a JavaScript class instance to a JSON object.
     * @template T - The type of the object to convert.
     * @param {T} obj - The object to convert to JSON.
     * @param {JsonToOptions} [options] - Options for JSON conversion.
     * @returns {{ [key: string | number]: any; }} Returns the JSON representation of the object.
     */
    static classToJson<T extends Object>(obj: T, options?: JsonToOptions): {
        [key: string | number]: any;
    };
    private static __classToJson;
    /**
    * Converts a JSON object to a JavaScript class instance.
    * @template T - The type of the object to convert.
    * @param {T} obj - The object to populate with JSON data.
    * @param {*} data - The JSON data to populate the object with.
    * @param {JsonFromOptions} [options] - Options for JSON deserialization.
    * @returns {T} Returns the populated object.
    */
    static classFromJson<T extends Object>(obj: T, data: any, options?: JsonFromOptions): T;
    private static __classFromJson;
}

@Storybook({
    prefix: "Tools/Conveter"
})
interface Schema {
    [key: string]: ___Aventus.SchemaType;
}

@Storybook({
    prefix: "Tools/Conveter"
})
interface IConverterTransform {
    transform<T = any>(data: any): T;
    copyValuesClass<T extends Object>(target: T, src: T, options?: ClassCopyOptions): void;
}

@Storybook({
    prefix: "Tools/Conveter"
})
class ConverterTransform implements IConverterTransform {
    transform<T = any>(data: any): T;
    protected createInstance(data: any): (Object & {
        fromJSON?: (data: any) => any;
    }) | undefined;
    protected beforeTransformObject(obj: Object): void;
    protected afterTransformObject(obj: Object): void;
    private transformLoop;
    copyValuesClass<T extends Object>(target: T, src: T, options?: ClassCopyOptions): void;
    private __classCopyValues;
}

@Storybook({
    prefix: "Tools/Conveter"
})
class Converter {
    /**
    * Map storing information about registered types.
    */
    static readonly info: Map<string, new () => any>;
    /**
    * Map storing schemas for registered types.
    */
    private static schema;
    /**
     * Internal converter instance.
     */
    private static __converter;
    /**
     * Getter for the internal converter instance.
     */
    private static get converterTransform();
    /**
    * Sets the converter instance.
    * @param converter The converter instance to set.
    */
    static setConverter(converter: IConverterTransform): void;
    /**
    * Registers a unique string type for any class.
    * @param $type The unique string type identifier.
    * @param cst The constructor function for the class.
    * @param schema Optional schema for the registered type.
    */
    static register($type: string, cst: new () => any, schema?: Schema): void;
    /**
     * Transforms the provided data using the current converter instance.
     * @template T
     * @param {*} data The data to transform.
     * @param {IConverterTransform} [converter] Optional converter instance to use for transformation.
     * @returns {T} Returns the transformed data.
     */
    static transform<T = any>(data: any, converter?: IConverterTransform): T;
    /**
     * Copies values from one class instance to another using the current converter instance.
     * @template T
     * @param {T} to The destination class instance to copy values into.
     * @param {T} from The source class instance to copy values from.
     * @param {ClassCopyOptions} [options] Optional options for the copy operation.
     * @param {IConverterTransform} [converter] Optional converter instance to use for the copy operation.
     * @returns {T} Returns the destination class instance with copied values.
     */
    static copyValuesClass<T extends Object>(to: T, from: T, options?: ClassCopyOptions, converter?: IConverterTransform): any;
}

@Storybook({
    prefix: "Data"
})
abstract class Data implements IData {
    /**
     * The schema for the class
     */
    static readonly $schema: {
        [prop: string]: string;
    };
    /**
     * The current namespace
     */
    static readonly Namespace: string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    /**
     * The current namespace
     */
    get namespace(): string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    get $type(): string;
    /**
     * Get the name of the class
     */
    get className(): string;
    /**
     * Get a JSON for the current object
     */
    toJSON(): {
        [key: string | number]: any;
    };
    /**
     * Clone the object by transforming a parsed JSON string back into the original type
     */
    clone(): this;
}

@Storybook({
    prefix: "Error"
})
class GenericError<T extends (number | Enum) = any> {
    /**
     * Code for the error
     */
    code: EnumValue<T>;
    /**
     * Description of the error
     */
    message: string;
    /**
     * Additional details related to the error.
     */
    details: any[] | {
        [key: string]: any;
    };
    /**
     * Creates a new instance of GenericError.
     * @param {EnumValue<T>} code - The error code.
     * @param {string} message - The error message.
     */
    constructor(code: EnumValue<T>, message: string);
}

@Storybook({
    prefix: "Error"
})
class VoidWithError<T extends GenericError = GenericError> {
    /**
     * Determine if the action is a success
     */
    get success(): boolean;
    /**
     * List of errors
     */
    errors: T[];
    /**
     * Converts the current instance to a VoidWithError object.
     * @returns {VoidWithError} A new instance of VoidWithError with the same error list.
     */
    toGeneric(): VoidWithError;
    /**
    * Checks if the error list contains a specific error code.
    * @template U - The type of error, extending GenericError.
    * @template T - The type of the error code, which extends either number or Enum.
    * @param {EnumValue<T>} code - The error code to check for.
    * @param {new (...args: any[]) => U} [type] - Optional constructor function of the error type.
    * @returns {boolean} True if the error list contains the specified error code, otherwise false.
    */
    containsCode<U extends GenericError<any>, T extends (number | Enum)>(code: EnumValue<T>, type?: new (...args: any[]) => U): boolean;
}

@Storybook({
    prefix: "Error"
})
class ResultWithError<U, T extends GenericError = GenericError> extends VoidWithError<T> {
    /**
      * The result value of the action.
      * @type {U | undefined}
      */
    result: U | undefined;
    /**
     * Converts the current instance to a ResultWithError object.
     * @returns {ResultWithError<U>} A new instance of ResultWithError with the same error list and result value.
     */
    toGeneric(): ResultWithError<U>;
}

type ExtractFromError<T, U = any> = T extends ResultWithError<infer U, any> ? U : T extends VoidWithError ? void : T;

@Storybook({
    prefix: "Http"
})
class HttpError extends GenericError<HttpErrorCode> {
}

type HttpRequestOptions = {
    beforeSend?: (request: HttpRequest) => Asyncable<VoidWithError>;
    responseMiddleware?: <T extends ResultWithError<any> | VoidWithError>(response: T, request: HttpRequest) => Asyncable<T>;
};

type WatcherChange = (action: WatchAction, changePath: string, value: any, dones: any[]) => void;

type EffectReceiver = {
    subscribe: (fct: WatcherChange) => void;
    unsubscribe: (fct: WatcherChange) => void;
    __path?: string;
};

class Signal<T> implements EffectReceiver {
    protected __subscribes: WatcherChange[];
    private _value;
    @Internal()
	private _onChange?;
    get value(): T;
    set value(item: T);
    constructor(item: T, onChange?: () => void);
    subscribe(fct: WatcherChange): void;
    unsubscribe(fct: WatcherChange): void;
    destroy(): void;
}

@Storybook({
    prefix: "Lib/Watcher"
})
class Effect {
    @InternalProtected()
	protected callbacks: {
        receiver: EffectReceiver;
        path: string;
        registerPath?: string;
        fullPath: string;
        cb: WatcherChange;
        version: number;
    }[];
    @InternalProtected()
	protected isInit: boolean;
    @InternalProtected()
	protected isDestroy: boolean;
    protected __subscribes: WatcherChange[];
    protected __allowChanged: ___Aventus.WatcherAllowed[];
    @InternalProtected()
	protected version: number;
    protected fct: () => void;
    constructor(fct: () => void);
    protected autoInit(): boolean;
    protected init(): void;
    protected run(): void;
    @InternalProtected()
	protected register(receiver: EffectReceiver, path: string, version: number, fullPath: string): void;
    canChange(fct: ___Aventus.WatcherAllowed): void;
    protected checkCanChange(action: WatchAction, changePath: string, value: any, dones: any[]): boolean;
    protected onChange(action: WatchAction, changePath: string, value: any, dones: any[]): void;
    destroy(): void;
    protected clearCallbacks(): void;
    subscribe(fct: WatcherChange): void;
    unsubscribe(fct: WatcherChange): void;
}

@Storybook({
    prefix: "Lib/Watcher"
})
class Computed<T = any> extends Effect implements EffectReceiver {
    protected _value?: T;
    @Internal()
	private __path;
    get value(): T | undefined;
    protected autoInit(): boolean;
    constructor(fct: () => ___Aventus.IsNotVoid<T>);
    protected init(): void;
    protected computedValue(): void;
    protected onChange(action: WatchAction, changePath: string, value: any, dones: any[]): void;
}

@Storybook({
    prefix: "Lib/Watcher"
})
class Watcher {
    private constructor();
    private static __reservedName;
    private static __triggerForced;
    @Internal()
	private static _registering;
    @Internal()
	private static get _register();
    /**
     * Transform object into a watcher
     */
    static get(obj: object, onDataChanged?: WatcherFunction): any;
    static is(obj: any): boolean;
    static extract<T>(obj: T, clearPath?: boolean): T;
    static trigger<T>(type: 'CREATED' | 'UPDATED' | 'DELETED', target: T): void;
    /**
     * Create a computed variable that will watch any changes
     */
    static computed<T>(fct: () => ___Aventus.IsNotVoid<T>): Computed<T>;
    /**
     * Create an effect variable that will watch any changes
     */
    static effect(fct: () => void): Effect;
    /**
     * Create an effect variable that will watch any changes inside the fct and trigger the cb on change
     */
    static watch(fct: () => any, cb: () => any): Effect;
    /**
     * Create a signal variable
     */
    static signal<T>(item: T, onChange?: () => void): Signal<T>;
}

@Storybook({
    prefix: "Lib/Watcher"
})
class ComputedNoRecomputed<T = any> extends Computed<T> {
    protected init(): void;
    protected computedValue(): void;
    protected run(): void;
}

@Storybook({
    prefix: "Lib/Watcher"
})
class EffectNoRecomputed extends Effect {
    protected init(): void;
    protected run(): void;
}

@Storybook({
    prefix: "Http"
})
class HttpRouter {
    @InternalProtected()
	protected options: HttpRouterOptions;
    constructor();
    private defaultOptionsValue;
    protected defineOptions(options: HttpRouterOptions): HttpRouterOptions;
    get<T>(url: string): Promise<ResultWithError<T>>;
    post<T>(url: string, data?: {
        [key: string | number]: any;
    } | FormData): Promise<ResultWithError<T>>;
    put<T>(url: string, data?: {
        [key: string | number]: any;
    } | FormData): Promise<ResultWithError<T>>;
    delete<T>(url: string, data?: {
        [key: string | number]: any;
    } | FormData): Promise<ResultWithError<T>>;
    option<T>(url: string, data?: {
        [key: string | number]: any;
    } | FormData): Promise<ResultWithError<T>>;
}

type RouterType = (abstract new (...args: any[]) => HttpRouter);

@Storybook({
    prefix: "Http"
})
class HttpRoute {
    protected router: HttpRouter;
    constructor(router?: HttpRouter);
    getPrefix(): string;
}

type RouteType = abstract new (...args: any[]) => HttpRoute;

@Storybook({
    prefix: "Http"
})
class HttpRequest {
    private static options?;
    static configure(options: HttpRequestOptions): void;
    private request;
    private url;
    constructor(url: string, method?: HttpMethod, body?: {
        [key: string | number]: any;
    } | FormData);
    setUrl(url: string): void;
    toString(): string;
    setBody(body: {
        [key: string | number]: any;
    } | FormData): void;
    setMethod(method: HttpMethod): void;
    private objectToFormData;
    jsonReplacer(key: string, value: any): any;
    private prepareBody;
    setHeader(name: string, value: string): void;
    setCredentials(credentials: RequestCredentials): void;
    protected _query(router?: HttpRouter): Promise<ResultWithError<Response>>;
    query(router?: HttpRouter): Promise<ResultWithError<Response>>;
    queryVoid<T>(router?: HttpRouter): Promise<VoidWithError>;
    queryJSON<T>(router?: HttpRouter): Promise<ResultWithError<T>>;
    queryTxt(router?: HttpRouter): Promise<ResultWithError<string>>;
    queryBlob(router?: HttpRouter): Promise<ResultWithError<Blob>>;
}

@Storybook({
    prefix: "Http"
})
abstract class StorableRoute<T extends IData> extends HttpRoute {
    GetAll(): unknown;
    Create(body: {
        item: T;
    } | FormData): unknown;
    GetById(id: number): unknown;
    Update(id: number, body: {
        body: T;
    } | FormData): unknown;
    Delete(id: number): unknown;
    abstract StorableName(): string;
}

@Storybook({
    prefix: "Lib/Animation"
})
class Animation {
    /**
     * Default FPS for all Animation if not set inside options
     */
    static FPS_DEFAULT: number;
    private options;
    private nextFrame;
    private fpsInterval;
    private continueAnimation;
    private frame_id;
    constructor(options: AnimationOptions);
    private animate;
    /**
     * Start the of animation
     */
    start(): void;
    /**
     * Stop the animation
     */
    stop(): void;
    /**
     * Stop the animation
     */
    immediateStop(): void;
    /**
     * Get the FPS
     */
    getFPS(): number;
    /**
     * Set the FPS
     */
    setFPS(fps: number): void;
    /**
     * Get the animation status (true if animation is running)
     */
    isStarted(): boolean;
}

type DragElement = DragElementXY | DragElementLeftTop;

@Storybook({
    prefix: "Lib/DragAndDrop"
})
interface DragAndDropOptionsShadow {
    enable: boolean;
    container?: ___Aventus.ContainerElement;
    removeOnStop?: boolean;
    transform?: (el: DragElement) => void;
    delete?: (el: DragElement) => void;
}

@Storybook({
    prefix: "Lib/DragAndDrop"
})
interface DragAndDropOptions {
    applyDrag?: boolean;
    element: DragElement;
    elementTrigger?: HTMLElement | SVGElement;
    offsetDrag?: number;
    dragDirection?: 'X' | 'Y' | 'XY';
    shadow?: DragAndDropOptionsShadow;
    strict?: boolean;
    targets?: ___Aventus.TargetableElement[] | (() => ___Aventus.TargetableElement[]);
    usePercent?: boolean;
    stopPropagation?: boolean | (() => boolean);
    useMouseFinalPosition?: boolean;
    useTransform?: boolean;
    isDragEnable?: () => boolean;
    getZoom?: () => number;
    getOffsetX?: () => number;
    getOffsetY?: () => number;
    onPointerDown?: (e: NormalizedEvent) => void;
    onPointerUp?: (e: NormalizedEvent) => void;
    onStart?: (e: NormalizedEvent) => void | boolean;
    onMove?: (e: NormalizedEvent, position: ___Aventus.Coordinate) => void;
    onStop?: (e: NormalizedEvent) => void;
    onDrop?: (element: DragElement, targets: ___Aventus.TargetableElement[]) => void;
    correctPosition?: (position: ___Aventus.Coordinate) => ___Aventus.Coordinate;
}

@Storybook({
    prefix: "Lib/PressManager"
})
class PressManager {
    private static globalConfig;
    static configure(options: Partial<PressManagerOptions>): void;
    static create(options: PressManagerOptions & {
        element: Element;
    }): PressManager;
    static create(options: PressManagerOptions & {
        element: Element[];
    }): PressManager[];
    static onEvent: Callback<(e: NormalizedEvent, instance: PressManager) => void>;
    protected options: PressManagerOptions;
    protected element: Element;
    protected delayDblPress: number;
    protected delayLongPress: number;
    protected nbPress: number;
    protected offsetDrag: number;
    protected dragDirection: 'X' | 'Y' | 'XY';
    protected state: PressManagerState;
    protected startPosition: {
        x: number;
        y: number;
    };
    protected customFcts: InternalCustomFunction;
    protected timeoutDblPress: number;
    protected timeoutLongPress: number;
    protected downEventSaved?: NormalizedEvent;
    protected useDblPress: boolean;
    protected stopPropagation: () => boolean;
    protected pointersRecord: {
        [id: number]: Event;
    };
    protected functionsBinded: {
        downAction: (e: PointerEvent) => void;
        downActionDelay: (e: PointerEvent) => void;
        upAction: (e: PointerEvent) => void;
        moveAction: (e: PointerEvent) => void;
        childPressStart: (e: InternalPointerEvent) => void;
        childPressEnd: (e: InternalPointerEvent) => void;
        childPressMove: (e: InternalPointerEvent) => void;
    };
    /**
     * @param {*} options - The options
     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage
     */
    constructor(options: PressManagerOptions);
    /**
     * Get the current element focused by the PressManager
     */
    getElement(): Element;
    protected checkDragConstraint(options: PressManagerOptions): void;
    protected assignValueOption(options: PressManagerOptions): void;
    protected bindAllFunction(): void;
    protected init(): void;
    protected identifyEvent(touch: Touch | PointerEvent): number;
    protected registerEvent(ev: PointerEvent | TouchEvent): boolean;
    protected unregisterEvent(ev: PointerEvent | TouchEvent): boolean;
    protected genericDownAction(state: PressManagerState, e: NormalizedEvent): void;
    private pointerEventTriggered;
    protected downActionDelay(ev: PointerEvent | TouchEvent): void;
    protected downAction(ev: PointerEvent | TouchEvent): void;
    protected genericUpAction(state: PressManagerState, e: NormalizedEvent): void;
    protected upAction(ev: PointerEvent | TouchEvent): void;
    protected genericMoveAction(state: PressManagerState, e: NormalizedEvent): void;
    protected moveAction(ev: PointerEvent): void;
    protected childPressStart(e: InternalPointerEvent): void;
    protected childPressEnd(e: InternalPointerEvent): void;
    protected childPressMove(e: InternalPointerEvent): void;
    protected lastEmitEvent?: NormalizedEvent;
    protected emitTriggerFunction(action: string, e: NormalizedEvent, el?: Element | null): void;
    /**
     * Destroy the Press instance byremoving all events
     */
    destroy(): void;
}

@Storybook({
    prefix: "Lib/DragAndDrop"
})
class DragAndDrop {
    /**
     * Default offset before drag element
     */
    static defaultOffsetDrag: number;
    private pressManager;
    private options;
    private startCursorPosition;
    private startElementPosition;
    private isEnable;
    private draggableElement;
    constructor(options: DragAndDropOptions);
    private getDefaultOptions;
    private mergeProperties;
    private mergeFunctions;
    private defaultMerge;
    private positionShadowRelativeToElement;
    private onPressStart;
    private onPressEnd;
    private onDragStart;
    private onDrag;
    private onDragEnd;
    private setPosition;
    private getTargets;
    /**
     * Get targets within the current element position is matching
     */
    getMatchingTargets(): ___Aventus.TargetableElement[];
    /**
     * This function will return the targets that are matching with the mouse position
     * @param mouse The mouse position
     */
    protected getMatchingTargetsWithMousePosition(mouse: ___Aventus.Coordinate): ___Aventus.TargetableElement[];
    private matchPosition;
    /**
     * Get element currently dragging
     */
    getElementDrag(): DragElement;
    /**
     * Set targets where to drop
     */
    setTargets(targets: ___Aventus.TargetableElement[]): void;
    /**
     * Set targets where to drop
     */
    setTargetsFct(targets: () => ___Aventus.TargetableElement[]): void;
    /**
     * Destroy the current drag&drop instance
     */
    destroy(): void;
    private isLeftTopElement;
    private isXYElement;
    private getCoordinateFromAttribute;
    private XYElementToRelativeBox;
    private XYElementToAbsoluteBox;
    private getBoundingBoxAbsolute;
    private getBoundingBoxRelative;
    private getOffsetParent;
}

@Storybook({
    prefix: "Lib/ResizeObserver"
})
class ResizeObserver {
    private callback;
    private targets;
    private fpsInterval;
    private nextFrame;
    private entriesChangedEvent;
    private willTrigger;
    private static resizeObserverClassByObject;
    private static uniqueInstance;
    private static getUniqueInstance;
    constructor(options: ResizeObserverOptions | CallableFunction);
    /**
     * Observe size changing for the element
     */
    observe(target: Element): void;
    /**
     * Stop observing size changing for the element
     */
    unobserve(target: Element): void;
    /**
     * Destroy the resize observer
     */
    disconnect(): void;
    private entryChanged;
    private triggerCb;
    private _triggerCb;
}

type PreparedUri = {
    regex: RegExp;
    params: UriParams[];
};

@Storybook({
    prefix: "Lib/Uri"
})
class Uri {
    static prepare(uri: string): PreparedUri;
    static getParams(from: string | PreparedUri, current: string): UriParamsValue | null;
    static isActive(from: string | PreparedUri, current: string): boolean;
    static normalize(path: string): any;
}

@Storybook({
    prefix: "Ram"
})
class RamError extends GenericError<RamErrorCode> {
}

@Storybook({
    prefix: "Ram"
})
class ResultRamWithError<T> extends ResultWithError<T, RamError> {
}

@Storybook({
    prefix: "Ram"
})
class VoidRamWithError extends VoidWithError<RamError> {
}

@Storybook({
    prefix: "Ram"
})
interface IRamAction<T> {
    update(newData: KeysObject<T>): Promise<this | undefined>;
    updateWithError(newData: KeysObject<T>): Promise<ResultRamWithError<this>>;
    onUpdate(callback: (item: this) => void): void;
    offUpdate(callback: (item: this) => void): void;
    delete(): Promise<void>;
    deleteWithError(): Promise<VoidRamWithError>;
    onDelete(callback: (item: this) => void): void;
    offDelete(callback: (item: this) => void): void;
}

type RamItem<T extends IData> = T & IRamAction<T>;

@Storybook({
    prefix: "Ram"
})
abstract class GenericRam<Index, T extends IData, U extends T = T> implements IRam {
    /**
     * The current namespace
     */
    static Namespace: string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    private subscribers;
    protected recordsSubscribers: Map<Index, ___Aventus.RamSubscribers<RamItem<U>>>;
    /**
     * List of stored item by index key
     */
    protected records: Map<Index, RamItem<U>>;
    protected actionGuard: ActionGuard;
    protected constructor();
    /**
     * Define the field where the index key is location
     * Example : 'id';
     */
    abstract defineIndexKey(): keyof T;
    /**
     * Get item id
     */
    @BindThis()
	getIdWithError(item: KeysObject<T> | T): ResultRamWithError<Index>;
    /**
     * Get item id
     */
    @BindThis()
	getId(item: KeysObject<T> | T): Index;
    /**
     * Prevent adding Watch element
     */
    protected removeWatch<X>(element: X): X;
    /**
     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete
     */
    protected addRamAction<B extends (new (...args: any[]) => IData) & {
        className?: string;
    }>(Base: B): {
        new (...args: any[]): IData;
        readonly className: string;
    } & B;
    protected abstract getTypeForData(objJson: KeysObject<T> | T): new () => U;
    /**
     * Transform the object into the object stored inside Ram
     */
    protected getObjectForRam(objJson: KeysObject<T> | T): RamItem<U>;
    /**
     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced
     */
    protected addOrUpdateData(item: KeysObject<T>, result: ResultWithError<RamItem<T>>): Promise<'created' | 'updated' | null>;
    /**
     * Merge object and create real instance of class
     */
    protected mergeObject(item: T | undefined, objJson: KeysObject<T> | T, options?: JsonFromOptions): void;
    /**
     * Create or update the item
     */
    @BindThis()
	save(item: T, ...args: any[]): Promise<RamItem<U> | undefined>;
    /**
     * Create or update the item
     */
    @BindThis()
	saveWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<U>>>;
    protected beforeRecordSet(item: RamItem<T>): Promise<void>;
    protected afterRecordSet(item: RamItem<T>): Promise<void>;
    protected beforeRecordDelete(item: RamItem<T>): Promise<void>;
    protected afterRecordDelete(item: RamItem<T>): Promise<void>;
    protected publish(type: 'created' | 'updated' | 'deleted', data: RamItem<U>): void;
    private subscribe;
    private unsubscribe;
    /**
    * Add a callback that ll be triggered when a new item is stored
    */
    @BindThis()
	onCreated(cb: (item: RamItem<U>) => void): void;
    /**
     * Remove a created callback
     */
    @BindThis()
	offCreated(cb: (item: RamItem<U>) => void): void;
    /**
     * Add a callback that ll be triggered when an item is updated
     */
    @BindThis()
	onUpdated(cb: (item: RamItem<U>) => void): void;
    /**
     * Remove an updated callback
     */
    @BindThis()
	offUpdated(cb: (item: RamItem<U>) => void): void;
    /**
     * Add a callback that ll be triggered when an item is deleted
     */
    @BindThis()
	onDeleted(cb: (item: RamItem<U>) => void): void;
    /**
     * Remove an deleted callback
     */
    @BindThis()
	offDeleted(cb: (item: RamItem<U>) => void): void;
    /**
     * Get an item by id if exist (alias for getById)
     */
    @BindThis()
	get(id: Index): Promise<RamItem<U> | undefined>;
    /**
     * Get an item by id if exist (alias for getById)
     */
    @BindThis()
	getWithError(id: Index): Promise<ResultRamWithError<RamItem<U>>>;
    /**
     * Get an item by id if exist
     */
    @BindThis()
	getById(id: Index): Promise<RamItem<U> | undefined>;
    /**
     * Get an item by id if exist
     */
    @BindThis()
	getByIdWithError(id: Index): Promise<ResultRamWithError<RamItem<U>>>;
    /**
     * Trigger before getting an item by id
     */
    protected beforeGetById(id: Index, result: ResultRamWithError<RamItem<U>>): Promise<void>;
    /**
     * Trigger after getting an item by id
     */
    protected afterGetById(result: ResultRamWithError<RamItem<U>>): Promise<void>;
    /**
     * Get multiple items by ids
     */
    @BindThis()
	getByIds(ids: Index[]): Promise<RamItem<U>[]>;
    /**
     * Get multiple items by ids
     */
    @BindThis()
	getByIdsWithError(ids: Index[]): Promise<ResultRamWithError<RamItem<U>[]>>;
    /**
     * Trigger before getting a list of items by id
     */
    protected beforeGetByIds(ids: Index[], result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
    /**
     * Trigger after getting a list of items by id
     */
    protected afterGetByIds(result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getAll(): Promise<Map<Index, RamItem<U>>>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getAllWithError(): Promise<ResultRamWithError<Map<Index, RamItem<U>>>>;
    /**
     * Trigger before getting all items inside Ram
     */
    protected beforeGetAll(result: ResultRamWithError<Map<Index, RamItem<U>>>): Promise<void>;
    /**
     * Trigger after getting all items inside Ram
     */
    protected afterGetAll(result: ResultRamWithError<Map<Index, RamItem<U>>>): Promise<void>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getList(): Promise<RamItem<U>[]>;
    /**
     * Get all elements inside the Ram
     */
    @BindThis()
	getListWithError(): Promise<ResultRamWithError<RamItem<U>[]>>;
    /**
     * Create a list of items inside ram
     */
    @BindThis()
	createList(list: T[]): Promise<RamItem<U>[]>;
    /**
     * Create a list of items inside ram
     */
    @BindThis()
	createListWithError(list: T[]): Promise<ResultRamWithError<RamItem<U>[]>>;
    /**
     * Create an item inside ram
     */
    @BindThis()
	create(item: T, ...args: any[]): Promise<RamItem<U> | undefined>;
    /**
     * Create an item inside ram
     */
    @BindThis()
	createWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<U>>>;
    private _create;
    /**
     * Trigger before creating a list of items
     */
    protected beforeCreateList(list: T[], result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
    /**
     * Trigger before creating an item
     */
    protected beforeCreateItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<U>>): Promise<void>;
    /**
     * Trigger after creating an item
     */
    protected afterCreateItem(result: ResultRamWithError<RamItem<U>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after creating a list of items
     */
    protected afterCreateList(result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
    /**
     * Update a list of items inside ram
     */
    @BindThis()
	updateList(list: T[]): Promise<RamItem<U>[]>;
    /**
     * Update a list of items inside ram
     */
    @BindThis()
	updateListWithError(list: T[]): Promise<ResultRamWithError<RamItem<U>[]>>;
    /**
     * Update an item inside ram
     */
    @BindThis()
	update(item: T, ...args: any[]): Promise<RamItem<U> | undefined>;
    /**
     * Update an item inside ram
     */
    @BindThis()
	updateWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<U>>>;
    private _update;
    /**
     * Trigger before updating a list of items
     */
    protected beforeUpdateList(list: T[], result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
    /**
    * Trigger before updating an item
    */
    protected beforeUpdateItem(item: T, fromList: boolean, result: ResultRamWithError<RamItem<U>>): Promise<void>;
    /**
     * Trigger after updating an item
     */
    protected afterUpdateItem(result: ResultRamWithError<RamItem<U>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after updating a list of items
     */
    protected afterUpdateList(result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
    /**
     * Delete a list of items inside ram
     */
    @BindThis()
	deleteList(list: T[]): Promise<RamItem<U>[]>;
    /**
     * Delete a list of items inside ram
     */
    @BindThis()
	deleteListWithError(list: T[]): Promise<ResultRamWithError<RamItem<U>[]>>;
    /**
     * Delete an item inside ram
     */
    @BindThis()
	delete(item: T, ...args: any[]): Promise<RamItem<U> | undefined>;
    /**
    * Delete an item inside ram
    */
    @BindThis()
	deleteWithError(item: T, ...args: any[]): Promise<ResultRamWithError<RamItem<U>>>;
    /**
     * Delete an item by id inside ram
     */
    @BindThis()
	deleteById(id: Index): Promise<RamItem<U> | undefined>;
    /**
    * Delete an item by id inside ram
    */
    @BindThis()
	deleteByIdWithError(id: Index): Promise<ResultRamWithError<RamItem<U>>>;
    private _delete;
    /**
     * Trigger before deleting a list of items
     */
    protected beforeDeleteList(list: T[], result: VoidWithError): Promise<void>;
    /**
     * Trigger before deleting an item
     */
    protected beforeDeleteItem(item: T, fromList: boolean, result: VoidWithError): Promise<void>;
    /**
     * Trigger after deleting an item
     */
    protected afterDeleteItem(result: ResultRamWithError<RamItem<U>>, fromList: boolean): Promise<void>;
    /**
     * Trigger after deleting a list of items
     */
    protected afterDeleteList(result: ResultRamWithError<RamItem<U>[]>): Promise<void>;
}

@Storybook({
    prefix: "Ram"
})
abstract class Ram<T extends IData, U extends T = T> extends GenericRam<number, T, U> {
}

@Storybook({
    prefix: "State"
})
interface StateAction {
    active?: ___Aventus.StateActivationFct | ___Aventus.StateActivationFct[];
    inactive?: ___Aventus.StateInactivationFct | ___Aventus.StateInactivationFct[];
    askChange?: ___Aventus.StateAskChangeFct | ___Aventus.StateAskChangeFct[];
}

@Storybook({
    prefix: "State"
})
interface IStateManager {
    subscribe(statePatterns: string | string[], callbacks: StateAction): any;
    unsubscribe(statePatterns: string | string[], callbacks: StateAction): any;
    onAfterStateChanged(cb: () => void): any;
    offAfterStateChanged(cb: () => void): any;
    setState(state: State | string): Promise<boolean>;
    getState(): State | undefined;
    isStateActive(statePattern: string): boolean;
    getStateSlugs(statePattern: string): UriParamsValue | null;
}

@Storybook({
    prefix: "State"
})
abstract class StateManager implements IStateManager {
    protected subscribers: {
        [statePattern: string]: ___Aventus.Subscriber;
    };
    static canBeActivate(statePattern: string, stateName: string): boolean;
    protected activeState?: State;
    protected changeStateMutex: Mutex;
    protected canChangeStateCbs: ((newState: State) => Promise<boolean>)[];
    private afterStateChanged;
    /**
     * Subscribe actions for a state or a state list
     */
    subscribe(statePatterns: string | string[], callbacks: StateAction, autoActiveState?: boolean): void;
    /**
     *
     */
    activateAfterSubscribe(statePatterns: string | string[], callbacks: StateAction): void;
    /**
     * Unsubscribe actions for a state or a state list
     */
    unsubscribe(statePatterns: string | string[], callbacks: StateAction): void;
    onAfterStateChanged(cb: () => void): void;
    offAfterStateChanged(cb: () => void): void;
    protected assignDefaultState(stateName: string): State;
    canChangeState(cb: (newState: State) => Promise<boolean>): void;
    /**
     * Activate a current state
     */
    setState(state: State | string): Promise<boolean>;
    getState(): State | undefined;
    /**
     * Check if a state is in the subscribers and active, return true if it is, false otherwise
     */
    isStateActive(statePattern: string): boolean;
    /**
     * Get slugs information for the current state, return null if state isn't active
     */
    getStateSlugs(statePattern: string): UriParamsValue | null;
    protected logLevel(): number;
    protected _log(msg: string, type: "error" | "warning" | "info"): void;
}

@Storybook({
    prefix: "State"
})
interface IState {
    readonly name: string;
    activate(manager: StateManager): Promise<boolean>;
    onActivate(): any;
    onInactivate(nextState: State): any;
    askChange(state: State, nextState: State): Promise<boolean>;
}

@Storybook({
    prefix: "State"
})
abstract class State implements IState {
    /**
     * Activate a custom state inside a specific manager
     * It ll be a generic state with no information inside exept name
     */
    static activate(stateName: string, manager: StateManager): Promise<boolean>;
    abstract get name(): string;
    /**
     * Activate this state inside a specific manager
     */
    activate(manager: StateManager): Promise<boolean>;
    onActivate(): void;
    onInactivate(nextState: State): void;
    askChange(state: State, nextState: State): Promise<boolean>;
}

@Storybook({
    prefix: "State"
})
class EmptyState extends State implements IState {
    private localName;
    constructor(stateName: string);
    /**
     * @inheritdoc
     */
    get name(): string;
}

@Storybook({
    prefix: "Webcomponent"
})
class TemplateInstance {
    @Internal()
	private context;
    content: DocumentFragment;
    private actions;
    private component;
    private _components;
    private firstRenderUniqueCb;
    private firstRenderCb;
    firstChild: HTMLElement | null;
    lastChild: HTMLElement | null;
    private computeds;
    private renderingComputeds;
    private loopRegisteries;
    private loops;
    private ifs;
    private isDestroyed;
    constructor(component: WebComponent, content: DocumentFragment, actions: ___Aventus.Actions, loops: ___Aventus.Loop[], ifs: ___Aventus.If[], context?: TemplateContext);
    render(): void;
    destructor(): void;
    removeFromDOM(avoidTrigger?: boolean): void;
    private selectElements;
    private updateContext;
    private renderContextEdit;
    private bindEvents;
    private bindEvent;
    private bindPressEvent;
    private transformActionsListening;
    private transformChangeAction;
    private transformInjectionAction;
    private transformBindigAction;
    private renderSubTemplate;
    private renderLoop;
    private resetLoopComplex;
    private renderLoopComplex;
    private resetLoopSimple;
    private renderLoopSimple;
    private renderIf;
    private renderIfMemory;
    private renderIfRecreate;
}

@Storybook({
    prefix: "Webcomponent"
})
class TemplateContext {
    data: {
        [name: string]: any;
    };
    comp: WebComponent;
    private computeds;
    private watch;
    private registry?;
    private isDestroyed;
    constructor(component: WebComponent, data?: {
        [key: string]: any;
    }, parentContext?: TemplateContext, registry?: ___Aventus.LoopRegistery);
    print(value: any): string;
    registerIndex(): string;
    registerLoop(dataName: string, _indexValue: number, _indexName: string, indexName: string | undefined, itemName: string | undefined, onThis: boolean): void;
    private updateIndex;
    increaseIndex(_indexName: string): void;
    decreaseIndex(_indexName: string): void;
    destructor(): void;
    registerWatch(name: string, value: any): void;
    updateWatch(name: string, value: any, dones: any[]): void;
    normalizePath(path: string): string;
    getValueFromItem(name: string): any;
    setValueToItem(name: string, value: any): void;
}

@Storybook({
    prefix: "Webcomponent"
})
class Template {
    static validatePath(path: string, pathToCheck: string): boolean;
    cst: typeof WebComponent;
    constructor(component: typeof WebComponent);
    private htmlParts;
    setHTML(data: ___Aventus.TemplateHTML): void;
    generateTemplate(): void;
    /**
     * Used by the for loop and the if
     * @param template
     */
    setTemplate(template: string): void;
    template: HTMLTemplateElement;
    actions: ___Aventus.Actions;
    setActions(actions: ___Aventus.Actions): void;
    loops: ___Aventus.Loop[];
    addLoop(loop: ___Aventus.Loop): void;
    ifs: ___Aventus.If[];
    addIf(_if: ___Aventus.If): void;
    createInstance(component: WebComponent): any;
}

@Dependances([{
    type: WebComponentInstance,
    strong: true
}])
@Storybook({
    prefix: "Webcomponent"
})
abstract class WebComponent extends HTMLElement implements DefaultComponent {
    /**
     * Add attributes informations
     */
    static get observedAttributes(): string[];
    private _first;
    private _isReady;
    /**
     * Determine if the component is ready (postCreation done)
     */
    get isReady(): boolean;
    /**
     * The current namespace
     */
    static readonly Namespace: string;
    /**
     * The current Tag / empty if abstract class
     */
    static readonly Tag: string;
    /**
     * Get the unique type for the data. Define it as the namespace + class name
     */
    static get Fullname(): string;
    /**
     * The current namespace
     */
    get namespace(): string;
    /**
     * Get the name of the component class
     */
    getClassName(): string;
    /**
     * The current tag
     */
    get tag(): string;
    /**
    * Get the unique type for the data. Define it as the namespace + class name
    */
    get $type(): string;
    @Internal()
	private __onChangeFct;
    @Internal()
	private __watch;
    @Internal()
	private __watchActions;
    private __watchActionsCb;
    private __watchFunctions;
    private __watchFunctionsComputed;
    private __pressManagers;
    @Internal()
	private __signalActions;
    @Internal()
	private __signals;
    private __isDefaultState;
    private __defaultActiveState;
    private __defaultInactiveState;
    private __statesList;
    constructor();
    /**
     * Remove all listeners
     * State + press
     */
    destructor(): void;
    protected destructChildren(): void;
    private __addWatchesActions;
    private __addWatchesFunctions;
    private __registerWatchesActions;
    private __addSignalActions;
    private __registerSignalsActions;
    private __registerSignalsAction;
    private __defaultValuesSignal;
    private __addPropertyActions;
    private __registerPropertiesActions;
    private static __style;
    private static __template;
    private __templateInstance?;
    protected styleBefore(addStyle: (name: string) => void): void;
    protected styleAfter(addStyle: (name: string) => void): void;
    private __getStyle;
    private __getHtml;
    private __getStatic;
    private static __styleSheets;
    private __renderStyles;
    private __renderTemplate;
    private __registerTemplateAction;
    private connectedCallback;
    private disconnectedCallback;
    private __onReadyCb;
    onReady(cb: Function): void;
    private __setReady;
    private __removeNoAnimations;
    private __defaultValues;
    private __defaultValuesWatch;
    private __upgradeAttributes;
    private __listBoolProps;
    private __upgradeProperty;
    private __correctGetter;
    private __getStateManager;
    private __addActiveDefState;
    private __addInactiveDefState;
    private __addActiveState;
    private __addInactiveState;
    private __addAskChangeState;
    private __createStates;
    private __createStatesList;
    private __inactiveDefaultState;
    private __activeDefaultState;
    private __subscribeState;
    private __activateState;
    private __stateCleared;
    private __unsubscribeState;
    protected dateToString(d: Date | string | null | undefined): string | null;
    protected dateTimeToString(dt: Date | string | null | undefined): string | null;
    protected stringToDate(s: string): Date | null;
    protected stringToDateTime(s: string): Date | null;
    protected getBoolean(val: any): boolean;
    private __registerPropToWatcher;
    private getStringAttr;
    private setStringAttr;
    private getStringProp;
    private getNumberAttr;
    private setNumberAttr;
    private getNumberProp;
    private getBoolAttr;
    private setBoolAttr;
    private getBoolProp;
    private getDateAttr;
    private setDateAttr;
    private getDateProp;
    private getDateTimeAttr;
    private setDateTimeAttr;
    private getDateTimeProp;
    private __propertyReceivers;
    private getReceiver;
    private attributeChangedCallback;
    /**
     * Remove a component from the dom
     * If desctruct is set to true, the component will be fully destroyed
     */
    remove(destruct?: boolean): void;
    /**
     * Function triggered when the component is destroyed
     */
    protected postDestruction(): void;
    /**
     * Function triggered the first time the component is rendering inside DOM
     */
    protected postCreation(): void;
    /**
    * Function triggered each time the component is rendering inside DOM
    */
    protected postConnect(): void;
    /**
    * Function triggered each time the component is removed from the DOM
    */
    protected postDisonnect(): void;
    /**
     * Find a parent by tagname if exist
     */
    findParentByTag<T>(tagname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by class name if exist
     */
    findParentByClass<T>(classname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by type if exist
     */
    findParentByType<T>(type: {
        prototype: T;
    }, untilNode?: Element): T | null;
    /**
     * Find a parent by type if exist
     */
    findParentByType<T extends {
        prototype: any;
    }[]>(type: [...T], untilNode?: Element): T[number]['prototype'] | null;
    /**
     * Find list of parents by tagname
     */
    findParentsByTag<T>(tagname: string | string[], untilNode?: Element): T[];
    /**
     * Find list of parents by custom check
     */
    findParents<T>(tagname: string | string[], check: (node: Node) => boolean, untilNode?: Element): T[];
    /**
     * Find list of parents by custom check
     */
    findParent<T>(tagname: string | string[], check: (node: Node) => boolean, untilNode?: Element): T | null;
    /**
     * Check if element contains a child
     */
    containsChild(el: Element): boolean;
    /**
     * Get elements inside slot
     */
    getElementsInSlot(slotName?: string): HTMLElement[];
    /**
     * Get nodes inside slot
     */
    getNodesInSlot(slotName?: string): Node[];
    /**
     * Get active element from the shadowroot or the document
     */
    getActiveElement(document?: Document): Element | null;
}

@Storybook({
    prefix: "Webcomponent"
})
class WebComponentInstance {
    private static __allDefinitions;
    private static __allInstances;
    /**
     * Last definition insert datetime
     */
    static lastDefinition: number;
    private static registerDefinition;
    private static removeDefinition;
    /**
     * Get all sub classes of type
     */
    static getAllClassesOf<T>(type: typeof WebComponent): (new () => WebComponent)[];
    /**
     * Get all registered definitions
     */
    static getAllDefinitions(): (new () => WebComponent)[];
    static addInstance(instance: WebComponent): void;
    static removeInstance(instance: WebComponent): void;
    static getAllInstances(type: new () => WebComponent): {};
    static create<T>(type: string): T | null;
}

@Storybook({
    prefix: "Webcomponent"
})
class ElementExtension {
    /**
     * Find a parent by custom check
     */
    static findParent<T>(element: Element, check: (node: Node) => boolean, untilNode?: Element): T | null;
    /**
     * Find a list of parent by custom check
     */
    static findParents<T>(element: Element, check: (node: Node) => boolean, untilNode?: Element): T[];
    /**
     * Find a parent by tagname if exist Static.findParentByTag(this, "av-img")
     */
    static findParentByTag<T>(element: Element, tagname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by class name if exist Static.findParentByClass(this, "my-class-img") = querySelector('.my-class-img')
     */
    static findParentByClass<T>(element: Element, classname: string | string[], untilNode?: Element): T | null;
    /**
     * Find a parent by type if exist Static.findParentyType(this, Aventus.Img)
     */
    static findParentByType<T>(element: Element, type: {
        prototype: T;
    }, untilNode?: Element): T | null;
    static findParentByType<T extends {
        prototype: any;
    }[]>(element: Element, type: [...T], untilNode?: Element): T[number]['prototype'] | null;
    /**
     * Find list of parents by tagname
     */
    static findParentsByTag<T>(element: Element, tagname: string | string[], untilNode?: Element): T[];
    /**
     * Check if element contains a child
     */
    static containsChild(element: Element, child: Element): boolean;
    /**
     * Get element inside slot
     */
    static getElementsInSlot(element: Element, slotName?: string): HTMLElement[];
    /**
     * Get element inside slot
     */
    static getNodesInSlot(element: Element, slotName?: string): Node[];
    /**
     * Get deeper element inside dom at the position X and Y
     */
    static getElementAtPosition(x: number, y: number, startFrom?: Element): any;
    /**
     * Get active element from the define root
     */
    static getActiveElement(root?: Document | ShadowRoot | null): Element | null;
}

	}

    var AvInstance: typeof Aventus.Instance;
    type NotVoid = { [key: string]: NotVoid; } | object | string | boolean | symbol | number | null | undefined;
    type Last<T extends any[]> = T extends [...infer _, infer Last] ? Last : never;

    declare namespace Aventus {
        interface WebComponent extends HTMLElement {
            shadowRoot: ShadowRoot;
        }
    }


    type ConstructorConstraint<T> = Function & { prototype: T; };

    interface DebuggerConfig {
        /** Write the compiled file inside ./compiled.js */
        writeCompiled?: boolean,
        /** Write the view parsed */
        writeHTML?: boolean;
        /** Write the ts file for the component with template methods */
        writeComponentTs?: boolean;
        /** Enable history for watch property and add a function getWatchHistory on this component*/
        enableWatchHistory?: boolean,
    }

    interface OverrideViewConfig {
        /** if set the component ll do a query selector else the component is the one loaded on first render */
        removeViewVariables?: string[];
    }

    interface ViewElementConfig {
        /** if set the component ll do a query selector else the component is the one loaded on first render */
        useLive?: boolean;
    }

    interface DependanceConfig {
        /** The type to load */
        type: any,
        /** The type must be loaded before the current class */
        strong?: boolean;
    }

    /**
     * Add an attribute inside on your component
     */
    function Attribute();
    /**
     * Add an attribute inside on your component with changes analyze
     */
    function Property();
    /**
     * Add an attribute inside on your component with changes analyze
     */
    function Property<T>(onChange: (component: T) => void);
    /**
     * Add an attribute inside on your component with changes analyze
     */
    function Signal();
    /**
     * Add an attribute inside on your component with changes analyze
     */
    function Signal<T>(onChange: (component: T) => void);
    /**
     * Add a property inside a watcher to be notify of changing
     */
    function Watch();
    /**
     * Add a property inside a watcher to be notify of changing
     */
    function Watch<T>(onChange: (component: T, action: Aventus.WatchAction, path: string, value: any) => void);
    /**
     * Allow injection autocompletion
     */
    function Injectable();
    /**
     * Add a function inside a watcher to be notify of changing
     */
    function Effect(options?: { autoInit?: boolean; });
    /**
     * Signal that this variable is a link to your shadowroot
     */
    function ViewElement(config?: ViewElementConfig);
    /**
     * Add foreign key reference
     */
    function ForeignKey(ref: ConstructorConstraint<Aventus.IData>);
    /**
     * Define a public property that will be transformed to private once compiled
     */
    function Internal();
    /**
     * Define a public property that will be transformed to protected once compiled
     */
    function InternalProtected();

    function StateActive(stateName: string, manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<((state: Aventus.State, slugs: Aventus.StateSlug) => void)>) => void;
    function DefaultStateActive(manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager);
    function StateInactive(stateName: string, manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<((state: Aventus.State, nextState: Aventus.State, slugs: Aventus.StateSlug) => void)>) => void;
    function DefaultStateInactive(manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager);
    function StateChange(stateName: string, manager: ConstructorConstraint<Aventus.StateManager> | Aventus.StateManager): (target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<((state: Aventus.State, nextState: Aventus.State, slugs: Aventus.StateSlug) => boolean | Promise<boolean>)>) => void;

    /**
     * Clear parent view and use your
     */
    function OverrideView(config?: OverrideViewConfig): (<T extends ConstructorConstraint<Aventus.WebComponent>> (ConstructorConstraint: T) => T);
    /**
     * use a custom TagName
     */
    function TagName(name: string): (<T extends ConstructorConstraint<Aventus.WebComponent>> (ConstructorConstraint: T) => T);
    /**
     * Force to be required inside export
     */
    function Required(): (ConstructorConstraint: Function) => void;
    /**
     * Add debbuger action function for your component
     */
    function Debugger(config: DebuggerConfig): (ConstructorConstraint: Function) => void;


    function Dependances(info: DependanceConfig[]): (ConstructorConstraint: Function) => void;

    /**
     * Register the element inside the Converter instance
     * Your object must have a static type named as the parameter
     */
    function Convertible(name: string = "Fullname"): (ConstructorConstraint: Function) => void;

    function BindThis(): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;

    function NoCompile(): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;

    interface StorybookConfig {
        /** Define what must be exported to storybook */
        export?: 'all' | 'none' | 'public' | 'protected',
        /** Define a prefix for the group of your stories */
        prefix?: string,
        /** Define the group for your element. If not set, the group will be the namespace */
        group?: string,
        /** If set to true, only meta will be generated. Usefull to create custom pages */
        noLive?: boolean;
        /** If set to true, no default story will be created. This will also prevent the rendering of the live section */
        noDefaultStory?: boolean;
        /** Define the configruation for your slots */
        slots?: {
            /** Define the slot content base on the name */
            values?: {
                [name: string]: string;
            };
            /** Inject type */
            inject?: (new (...args: any[]) => Aventus.WebComponent)[];
        };
    }
    /**
     * Export a story for this component
     */
    function Storybook(info?: StorybookConfig);

    function NoStory();
    function AddToStory();
    function StoryValue(value: any);

    /**
     * Mark as deprecated
     */
    function Deprecated(msg?: string);

}
declare module ___Aventus {
type ActionBindings = {
    id: string;
    injectionName: string;
    eventNames: string[];
    inject: (c: globalThis.Aventus.TemplateContext) => any;
    extract: (c: globalThis.Aventus.TemplateContext, v: any) => any;
    isCallback?: boolean;
    once?: boolean;
};

type ActionInjection = {
    id: string;
    injectionName: string;
    inject: (c: globalThis.Aventus.TemplateContext) => any;
    once?: boolean;
};

type ActionEventCallback = (c: globalThis.Aventus.TemplateContext, ...args: any) => void;

type ActionEventListener = (e: Event, c: globalThis.Aventus.TemplateContext) => void;

type ContextEdit = {
    fct: (c: globalThis.Aventus.TemplateContext) => {
        [key: string]: any;
    };
    once?: boolean;
};

type If = {
    anchorId: string;
    parts: {
        condition: (c: globalThis.Aventus.TemplateContext) => boolean;
        template: globalThis.Aventus.Template;
        once?: boolean;
    }[];
};

type LoopSimple = {
    data: string;
    item?: string;
    index?: string;
};

type LoopFct = {
    transform?: () => void;
    condition: () => boolean;
    apply: () => {
        [key: string]: any;
    };
};

type TemplateHTML = {
    slots: {
        [name: string]: string;
    };
    blocks: {
        [name: string]: string;
    };
};

type OnlyConstructor<T = any> = (abstract new (...args: any[]) => T);

@Storybook({
    prefix: "Ram"
})
interface RamSubscribers<T> {
    created: ((item: T) => void)[];
    updated: ((item: T) => void)[];
    deleted: ((item: T) => void)[];
}

type StateAskChangeFct = (state: globalThis.Aventus.State, nextState: globalThis.Aventus.State, slugs: globalThis.Aventus.StateSlug) => Promise<boolean>;

type StateInactivationFct = (state: globalThis.Aventus.State, nextState: globalThis.Aventus.State, slugs: globalThis.Aventus.StateSlug) => void;

type WindowResizeObserver = globalThis.ResizeObserver;

@Storybook({
    prefix: "Lib/DragAndDrop"
})
interface Coordinate {
    x: number;
    y: number;
}

type TargetableElement = HTMLElement | SVGElement;

type ContainerElement = HTMLElement | SVGSVGElement;

type AnyElement = TargetableElement | ContainerElement;

@Storybook({
    prefix: "Lib/Animation"
})
interface AnimationOptionsInternal {
    animate: Function;
    stopped: Function;
    fps: number;
}

type IsNotVoid<T> = T extends void ? never : T;

type WatcherFunctionInternal = (action: globalThis.Aventus.WatchAction, path: string, value: any, dones: any) => void;

type WatcherAllowed = (action: globalThis.Aventus.WatchAction, path: string, value: any, dones: any[]) => boolean;

type SchemaType = 'string' | 'number' | 'boolean' | 'date' | string;

type DragAndDropOptionsInternal = Required<globalThis.Aventus.DragAndDropOptions> & {
    shadow: Required<globalThis.Aventus.DragAndDropOptionsShadow>;
};

type StateActivationFct = (state: globalThis.Aventus.State, slugs: globalThis.Aventus.StateSlug) => void;

type Subscriber = {
    regex: RegExp;
    params: {
        name: string;
        type: "number" | "string";
        position: number;
    }[];
    isActive: boolean;
    callbacks: {
        active: StateActivationFct[];
        inactive: StateInactivationFct[];
        askChange: StateAskChangeFct[];
    };
};

type Loop = {
    anchorId: string;
    template: globalThis.Aventus.Template;
    func?: (c: globalThis.Aventus.TemplateContext) => LoopFct;
    simple?: LoopSimple;
};

type ActionEvent = {
    id: string;
    eventName: string;
    isCallback?: boolean;
    fct: ActionEventListener & ActionEventCallback;
};

type LoopRegistery = {
    templates: globalThis.Aventus.TemplateInstance[];
    computeds: globalThis.Aventus.Computed[];
    unsub?: () => void;
};

type ActionChange = {
    fct: (c: globalThis.Aventus.TemplateContext) => string;
    once?: boolean;
};

type Actions = {
    elements?: {
        name: string;
        ids: string[];
        isArray?: boolean;
    }[];
    content?: {
        [id_attr: string]: ActionChange;
    };
    injection?: ActionInjection[];
    bindings?: ActionBindings[];
    events?: ActionEvent[];
    pressEvents?: globalThis.Aventus.PressManagerOptions[];
    contextEdits?: ContextEdit[];
};
}//#endregion js def //
//#region js src //
{"namespace":"Aventus","available":[{"code":"if(!Object.hasOwn(window, \"AvInstance\")) {\r\n\tObject.defineProperty(window, \"AvInstance\", {\r\n\t\tget() {return Aventus.Instance;}\r\n\t});\r\n\r\n\t(() => {\r\n\t\tMap.prototype._defaultHas = Map.prototype.has;\r\n\t\tMap.prototype._defaultSet = Map.prototype.set;\r\n\t\tMap.prototype._defaultGet = Map.prototype.get;\r\n\t\tMap.prototype.has = function(key) {\r\n\t\t\tif(Aventus.Watcher?.is(key)) {\r\n\t\t\t\treturn Map.prototype._defaultHas.call(this,key.getTarget())\r\n\t\t\t}\r\n\t\t\treturn Map.prototype._defaultHas.call(this,key);\r\n\t\t}\r\n\r\n\t\tMap.prototype.set = function(key, value) {\r\n\t\t\tif(Aventus.Watcher?.is(key)) {\r\n\t\t\t\treturn Map.prototype._defaultSet.call(this, key.getTarget(), value)\r\n\t\t\t}\r\n\t\t\treturn Map.prototype._defaultSet.call(this, key, value);\r\n\t\t}\r\n\t\tMap.prototype.get = function(key) {\r\n\t\t\tif(Aventus.Watcher?.is(key)) {\r\n\t\t\t\treturn Map.prototype._defaultGet.call(this, key.getTarget())\r\n\t\t\t}\r\n\t\t\treturn Map.prototype._defaultGet.call(this, key);\r\n\t\t}\r\n\t})();\r\n}","dependances":[],"fullName":"!staticClass_a19222991f817371b18f65b47e8f5cf9","required":true,"noNamespace":"before","type":0,"isExported":false,"convertibleName":""},{"code":" ","dependances":[],"fullName":"!staticClass_b8b6866d7faef0c1b536e38915cc5583","required":true,"noNamespace":"before","type":0,"isExported":false,"convertibleName":""},{"code":"let Style=class Style {\n    static instance;\n    static noAnimation;\n    static defaultStyleSheets = {\n        \"@default\": `:host{display:inline-block;box-sizing:border-box}:host *{box-sizing:border-box}`,\n    };\n    static store(name, content) {\n        this.getInstance().store(name, content);\n    }\n    static get(name) {\n        return this.getInstance().get(name);\n    }\n    static getAsString(name) {\n        return this.getInstance().getAsString(name);\n    }\n    static sheetToString(stylesheet) {\n        return this.getInstance().sheetToString(stylesheet);\n    }\n    static load(name, url) {\n        return this.getInstance().load(name, url);\n    }\n    static appendToHead(name) {\n        if (!document.head.querySelector(`style[data-name=\"${name}\"]`)) {\n            const styleNode = document.createElement('style');\n            styleNode.setAttribute(`data-name`, name);\n            styleNode.innerHTML = Style.getAsString(name);\n            document.getElementsByTagName('head')[0].appendChild(styleNode);\n        }\n    }\n    static refreshHead(name) {\n        const styleNode = document.head.querySelector(`style[data-name=\"${name}\"]`);\n        if (styleNode) {\n            styleNode.innerHTML = Style.getAsString(name);\n        }\n    }\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new Style();\n        }\n        return this.instance;\n    }\n    constructor() {\n        for (let name in Style.defaultStyleSheets) {\n            this.store(name, Style.defaultStyleSheets[name]);\n        }\n        Style.noAnimation = new CSSStyleSheet();\n        Style.noAnimation.replaceSync(`:host{-webkit-transition: none !important;-moz-transition: none !important;-ms-transition: none !important;-o-transition: none !important;transition: none !important;}:host *{-webkit-transition: none !important;-moz-transition: none !important;-ms-transition: none !important;-o-transition: none !important;transition: none !important;}`);\n    }\n    stylesheets = new Map();\n    async load(name, url) {\n        try {\n            let style = this.stylesheets.get(name);\n            if (!style || style.cssRules.length == 0) {\n                let txt = await (await fetch(url)).text();\n                this.store(name, txt);\n            }\n        }\n        catch (e) {\n        }\n    }\n    store(name, content) {\n        let style = this.stylesheets.get(name);\n        if (!style) {\n            const sheet = new CSSStyleSheet();\n            sheet.replaceSync(content);\n            this.stylesheets.set(name, sheet);\n            return sheet;\n        }\n        else {\n            style.replaceSync(content);\n            Style.refreshHead(name);\n            return style;\n        }\n    }\n    get(name) {\n        let style = this.stylesheets.get(name);\n        if (!style) {\n            style = this.store(name, \"\");\n        }\n        return style;\n    }\n    getAsString(name) {\n        return this.sheetToString(this.get(name));\n    }\n    sheetToString(stylesheet) {\n        return stylesheet.cssRules\n            ? Array.from(stylesheet.cssRules)\n                .map(rule => rule.cssText || '')\n                .join('\\n')\n            : '';\n    }\n}\nStyle.Namespace=`Aventus`;\r\n_.Style=Style;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":true},{"fullName":"Promise","isStrong":false},{"fullName":"Map","isStrong":false}],"fullName":"Aventus.Style","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let uuidv4=function uuidv4() {\n    let uid = '10000000-1000-4000-8000-100000000000'.replace(/[018]/g, c => (Number(c) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(c) / 4).toString(16));\n    return uid;\n}\n_.uuidv4=uuidv4;\r\n","dependances":[],"fullName":"Aventus.uuidv4","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"let sleep=function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n_.sleep=sleep;\r\n","dependances":[],"fullName":"Aventus.sleep","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"let isSubclassOf=function isSubclassOf(subClass, superClass) {\n    if (typeof subClass !== 'function' || typeof superClass !== 'function')\n        return false;\n    let proto = subClass.prototype;\n    while (proto) {\n        if (proto === superClass.prototype)\n            return true;\n        proto = Object.getPrototypeOf(proto);\n    }\n    return false;\n}\n_.isSubclassOf=isSubclassOf;\r\n","dependances":[],"fullName":"Aventus.isSubclassOf","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"let isClass=function isClass(v) {\n    return typeof v === 'function' && /^\\s*class\\s+/.test(v.toString());\n}\n_.isClass=isClass;\r\n","dependances":[],"fullName":"Aventus.isClass","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"let setValueToObject=function setValueToObject(path, obj, value) {\n    path = path.replace(/\\[(.*?)\\]/g, '.$1');\n    const val = (key) => {\n        if (obj instanceof Map) {\n            return obj.get(key);\n        }\n        return obj[key];\n    };\n    let splitted = path.split(\".\");\n    for (let i = 0; i < splitted.length - 1; i++) {\n        let split = splitted[i];\n        let value = val(split);\n        if (!value) {\n            obj[split] = {};\n            value = obj[split];\n        }\n        obj = value;\n    }\n    if (obj instanceof Map) {\n        obj.set(splitted[splitted.length - 1], value);\n    }\n    else {\n        obj[splitted[splitted.length - 1]] = value;\n    }\n}\n_.setValueToObject=setValueToObject;\r\n","dependances":[],"fullName":"Aventus.setValueToObject","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"let Mutex=class Mutex {\n    /**\n     * Array to store functions waiting for the mutex to become available.\n     * @type {((run: boolean) => void)[]}\n     */\n    waitingList = [];\n    /**\n    * Indicates whether the mutex is currently locked or not.\n    * @type {boolean}\n    */\n    isLocked = false;\n    /**\n    * Waits for the mutex to become available and then acquires it.\n    * @returns {Promise<boolean>} A Promise that resolves to true if the mutex was acquired successfully.\n    */\n    waitOne() {\n        return new Promise((resolve) => {\n            if (this.isLocked) {\n                this.waitingList.push((run) => {\n                    resolve(run);\n                });\n            }\n            else {\n                this.isLocked = true;\n                resolve(true);\n            }\n        });\n    }\n    /**\n     * Release the mutex\n     */\n    release() {\n        let nextFct = this.waitingList.shift();\n        if (nextFct) {\n            nextFct(true);\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Releases the mutex, allowing only the last function in the waiting list to acquire it.\n     */\n    releaseOnlyLast() {\n        if (this.waitingList.length > 0) {\n            let lastFct = this.waitingList.pop();\n            for (let fct of this.waitingList) {\n                fct(false);\n            }\n            this.waitingList = [];\n            if (lastFct) {\n                lastFct(true);\n            }\n        }\n        else {\n            this.isLocked = false;\n        }\n    }\n    /**\n     * Clears the mutex, removing all waiting functions and releasing the lock.\n     */\n    dispose() {\n        this.waitingList = [];\n        this.isLocked = false;\n    }\n    /**\n     * Executes a callback function safely within the mutex lock and releases the lock afterward.\n     * @template T - The type of the return value of the callback function.\n     * @param {() => T} cb - The callback function to execute.\n     * @returns {Promise<T | null>} A Promise that resolves to the result of the callback function or null if an error occurs.\n     */\n    async safeRun(cb) {\n        let result = null;\n        await this.waitOne();\n        try {\n            result = cb.apply(null, []);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        await this.release();\n        return result;\n    }\n    /**\n     * Executes an asynchronous callback function safely within the mutex lock and releases the lock afterward.\n     * @template T - The type of the return value of the asynchronous callback function.\n     * @param {() => Promise<T>} cb - The asynchronous callback function to execute.\n     * @returns {Promise<T | null>} A Promise that resolves to the result of the asynchronous callback function or null if an error occurs.\n     */\n    async safeRunAsync(cb) {\n        let result = null;\n        await this.waitOne();\n        try {\n            result = await cb.apply(null, []);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        await this.release();\n        return result;\n    }\n    /**\n     * Executes a callback function safely within the mutex lock, allowing only the last function in the waiting list to acquire the lock, and releases the lock afterward.\n     * @template T - The type of the return value of the callback function.\n     * @param {() => T} cb - The callback function to execute.\n     * @returns {Promise<T | null>} A Promise that resolves to the result of the callback function or null if an error occurs.\n     */\n    async safeRunLast(cb) {\n        let result = null;\n        if (await this.waitOne()) {\n            try {\n                result = cb.apply(null, []);\n            }\n            catch (e) {\n                console.error(e);\n            }\n            await this.releaseOnlyLast();\n        }\n        return result;\n    }\n    /**\n     * Executes an asynchronous callback function safely within the mutex lock, allowing only the last function in the waiting list to acquire the lock, and releases the lock afterward.\n     * @template T - The type of the return value of the asynchronous callback function.\n     * @param {() => Promise<T>} cb - The asynchronous callback function to execute.\n     * @returns {Promise<T | undefined>} A Promise that resolves to the result of the asynchronous callback function or undefined if an error occurs.\n     */\n    async safeRunLastAsync(cb) {\n        let result;\n        if (await this.waitOne()) {\n            try {\n                result = await cb.apply(null, []);\n            }\n            catch (e) {\n                console.error(e);\n            }\n            await this.releaseOnlyLast();\n        }\n        return result;\n    }\n}\nMutex.Namespace=`Aventus`;\r\n_.Mutex=Mutex;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Promise","isStrong":false}],"fullName":"Aventus.Mutex","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ActionGuard=class ActionGuard {\n    /**\n     * Map to store actions that are currently running.\n     * @type {Map<any[], ((res: any) => void)[]>}\n     * @private\n     */\n    runningAction = new Map();\n    run(keys, action) {\n        return new Promise(async (resolve) => {\n            if (typeof keys == 'function') {\n                action = keys;\n                keys = [];\n            }\n            if (!action) {\n                throw \"No action inside the Mutex.run\";\n            }\n            let actions = undefined;\n            let runningKeys = Array.from(this.runningAction.keys());\n            for (let runningKey of runningKeys) {\n                if (runningKey.length == keys.length) {\n                    let found = true;\n                    for (let i = 0; i < keys.length; i++) {\n                        if (runningKey[i] != keys[i]) {\n                            found = false;\n                            break;\n                        }\n                    }\n                    if (found) {\n                        actions = this.runningAction.get(runningKey);\n                        break;\n                    }\n                }\n            }\n            if (actions) {\n                actions.push((res) => {\n                    resolve(res);\n                });\n            }\n            else {\n                this.runningAction.set(keys, []);\n                let res = await action();\n                let actions = this.runningAction.get(keys);\n                if (actions) {\n                    for (let action of actions) {\n                        action(res);\n                    }\n                }\n                this.runningAction.delete(keys);\n                resolve(res);\n            }\n        });\n    }\n}\nActionGuard.Namespace=`Aventus`;\r\n_.ActionGuard=ActionGuard;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"T","isStrong":false}],"fullName":"Aventus.ActionGuard","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"var RamErrorCode;\n(function (RamErrorCode) {\n    RamErrorCode[RamErrorCode[\"unknow\"] = 0] = \"unknow\";\n    RamErrorCode[RamErrorCode[\"noId\"] = 1] = \"noId\";\n    RamErrorCode[RamErrorCode[\"noItemInsideRam\"] = 2] = \"noItemInsideRam\";\n})(RamErrorCode || (RamErrorCode = {}));\n_.RamErrorCode=RamErrorCode;\r\n","dependances":[],"fullName":"Aventus.RamErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"let ResourceLoader=class ResourceLoader {\n    static headerLoaded = {};\n    static headerWaiting = {};\n    /**\n     * Load the resource inside the head tag\n     */\n    static async loadInHead(options) {\n        const _options = this.prepareOptions(options);\n        if (this.headerLoaded[_options.url]) {\n            return true;\n        }\n        else if (this.headerWaiting.hasOwnProperty(_options.url)) {\n            return await this.awaitFctHead(_options.url);\n        }\n        else {\n            this.headerWaiting[_options.url] = [];\n            let tagEl;\n            if (_options.type == \"js\") {\n                tagEl = document.createElement(\"SCRIPT\");\n            }\n            else if (_options.type == \"css\") {\n                tagEl = document.createElement(\"LINK\");\n                tagEl.setAttribute(\"rel\", \"stylesheet\");\n            }\n            else {\n                throw \"unknow type \" + _options.type + \" to append into head\";\n            }\n            document.head.appendChild(tagEl);\n            let result = await this.loadTag(tagEl, _options.url);\n            this.headerLoaded[_options.url] = true;\n            this.releaseAwaitFctHead(_options.url, result);\n            return result;\n        }\n    }\n    static loadTag(tagEl, url) {\n        return new Promise((resolve, reject) => {\n            tagEl.addEventListener(\"load\", (e) => {\n                resolve(true);\n            });\n            tagEl.addEventListener(\"error\", (e) => {\n                resolve(false);\n            });\n            if (tagEl instanceof HTMLLinkElement) {\n                tagEl.setAttribute(\"href\", url);\n            }\n            else {\n                tagEl.setAttribute('src', url);\n            }\n        });\n    }\n    static releaseAwaitFctHead(url, result) {\n        if (this.headerWaiting[url]) {\n            for (let i = 0; i < this.headerWaiting[url].length; i++) {\n                this.headerWaiting[url][i](result);\n            }\n            delete this.headerWaiting[url];\n        }\n    }\n    static awaitFctHead(url) {\n        return new Promise((resolve) => {\n            this.headerWaiting[url].push((result) => {\n                resolve(result);\n            });\n        });\n    }\n    static requestLoaded = {};\n    static requestWaiting = {};\n    /**\n     *\n    */\n    static async load(options) {\n        options = this.prepareOptions(options);\n        if (this.requestLoaded[options.url]) {\n            return this.requestLoaded[options.url];\n        }\n        else if (this.requestWaiting.hasOwnProperty(options.url)) {\n            await this.awaitFct(options.url);\n            return this.requestLoaded[options.url];\n        }\n        else {\n            this.requestWaiting[options.url] = [];\n            let blob = false;\n            if (options.type == \"img\") {\n                blob = true;\n            }\n            let content = await this.fetching(options.url, blob);\n            if (options.type == \"img\" && content.startsWith(\"data:text/html;\")) {\n                console.error(\"Can't load img \" + options.url);\n                content = \"\";\n            }\n            this.requestLoaded[options.url] = content;\n            this.releaseAwaitFct(options.url);\n            return content;\n        }\n    }\n    static releaseAwaitFct(url) {\n        if (this.requestWaiting[url]) {\n            for (let i = 0; i < this.requestWaiting[url].length; i++) {\n                this.requestWaiting[url][i]();\n            }\n            delete this.requestWaiting[url];\n        }\n    }\n    static awaitFct(url) {\n        return new Promise((resolve) => {\n            this.requestWaiting[url].push(() => {\n                resolve('');\n            });\n        });\n    }\n    static async fetching(url, useBlob = false) {\n        if (useBlob) {\n            let result = await fetch(url, {\n                headers: {\n                    responseType: 'blob'\n                }\n            });\n            let blob = await result.blob();\n            return await this.readFile(blob);\n        }\n        else {\n            let result = await fetch(url);\n            return await result.text();\n        }\n    }\n    static readFile(blob) {\n        return new Promise((resolve) => {\n            var reader = new FileReader();\n            reader.onloadend = function () {\n                resolve(reader.result);\n            };\n            reader.readAsDataURL(blob);\n        });\n    }\n    static imgExtensions = [\"png\", \"jpg\", \"jpeg\", \"gif\"];\n    static prepareOptions(options) {\n        let result;\n        if (typeof options === 'string' || options instanceof String) {\n            result = {\n                url: options,\n                type: 'js'\n            };\n            let splittedURI = result.url.split('.');\n            let extension = splittedURI[splittedURI.length - 1];\n            extension = extension.split(\"?\")[0];\n            if (extension == \"svg\") {\n                result.type = 'svg';\n            }\n            else if (extension == \"js\") {\n                result.type = 'js';\n            }\n            else if (extension == \"css\") {\n                result.type = 'css';\n            }\n            else if (this.imgExtensions.indexOf(extension) != -1) {\n                result.type = 'img';\n            }\n            else {\n                delete result.type;\n            }\n        }\n        else {\n            result = options;\n        }\n        return result;\n    }\n}\nResourceLoader.Namespace=`Aventus`;\r\n_.ResourceLoader=ResourceLoader;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.ResourceLoaderHeadOptions","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.ResourceLoaderOptions","isStrong":false},{"fullName":"Blob","isStrong":false}],"fullName":"Aventus.ResourceLoader","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Instance=class Instance {\n    static elements = new Map();\n    static get(type) {\n        let result = this.elements.get(type);\n        if (!result) {\n            let cst = type.prototype['constructor'];\n            result = new cst();\n            this.elements.set(type, result);\n        }\n        return result;\n    }\n    static set(el) {\n        let cst = el.constructor;\n        if (this.elements.get(cst)) {\n            return false;\n        }\n        this.elements.set(cst, el);\n        return true;\n    }\n    static destroy(el) {\n        let cst = el.constructor;\n        return this.elements.delete(cst);\n    }\n}\nInstance.Namespace=`Aventus`;\r\n_.Instance=Instance;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Map","isStrong":true},{"fullName":"X","isStrong":false}],"fullName":"Aventus.Instance","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let DragElementXYType= [SVGGElement, SVGRectElement, SVGEllipseElement, SVGTextElement];\n_.DragElementXYType=DragElementXYType;\r\n","dependances":[],"fullName":"Aventus.DragElementXYType","required":false,"type":5,"isExported":true,"convertibleName":""},{"code":"let DragElementLeftTopType= [HTMLElement, SVGSVGElement];\n_.DragElementLeftTopType=DragElementLeftTopType;\r\n","dependances":[],"fullName":"Aventus.DragElementLeftTopType","required":false,"type":5,"isExported":true,"convertibleName":""},{"code":"let NormalizedEvent=class NormalizedEvent {\n    _event;\n    get event() {\n        return this._event;\n    }\n    constructor(event) {\n        this._event = event;\n    }\n    getProp(prop) {\n        if (prop in this.event) {\n            return this.event[prop];\n        }\n        return undefined;\n    }\n    stopImmediatePropagation() {\n        this.event.stopImmediatePropagation();\n    }\n    get clientX() {\n        if ('clientX' in this.event) {\n            return this.event.clientX;\n        }\n        else if ('touches' in this.event && this.event.touches.length > 0) {\n            return this.event.touches[0].clientX;\n        }\n        return 0;\n    }\n    get clientY() {\n        if ('clientY' in this.event) {\n            return this.event.clientY;\n        }\n        else if ('touches' in this.event && this.event.touches.length > 0) {\n            return this.event.touches[0].clientY;\n        }\n        return 0;\n    }\n    get pageX() {\n        if ('pageX' in this.event) {\n            return this.event.pageX;\n        }\n        else if ('touches' in this.event && this.event.touches.length > 0) {\n            return this.event.touches[0].pageX;\n        }\n        return 0;\n    }\n    get pageY() {\n        if ('pageY' in this.event) {\n            return this.event.pageY;\n        }\n        else if ('touches' in this.event && this.event.touches.length > 0) {\n            return this.event.touches[0].pageY;\n        }\n        return 0;\n    }\n    get type() {\n        return this.event.type;\n    }\n    get target() {\n        return this.event.target;\n    }\n    get timeStamp() {\n        return this.event.timeStamp;\n    }\n    get pointerType() {\n        if ('TouchEvent' in window && this._event instanceof TouchEvent)\n            return \"touch\";\n        return this.getProp(\"pointerType\");\n    }\n    get button() {\n        return this.getProp(\"button\");\n    }\n    get isTouch() {\n        if ('TouchEvent' in window && this._event instanceof TouchEvent)\n            return true;\n        return this._event.pointerType == \"touch\";\n    }\n}\nNormalizedEvent.Namespace=`Aventus`;\r\n_.NormalizedEvent=NormalizedEvent;\r\n","dependances":[{"fullName":"T","isStrong":false}],"fullName":"Aventus.NormalizedEvent","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Callback=class Callback {\n    callbacks = new Map();\n    /**\n     * Clear all callbacks\n     */\n    clear() {\n        this.callbacks.clear();\n    }\n    /**\n     * Add a callback\n     */\n    add(cb, scope = null) {\n        if (!this.callbacks.has(cb)) {\n            this.callbacks.set(cb, scope);\n        }\n    }\n    /**\n     * Remove a callback\n     */\n    remove(cb) {\n        this.callbacks.delete(cb);\n    }\n    /**\n     * Trigger all callbacks\n     */\n    trigger(...args) {\n        let result = [];\n        let cbs = [...this.callbacks];\n        for (let [cb, scope] of cbs) {\n            result.push(cb.apply(scope, args));\n        }\n        return result;\n    }\n}\nCallback.Namespace=`Aventus`;\r\n_.Callback=Callback;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.Callback","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let CallbackGroup=class CallbackGroup {\n    callbacks = {};\n    /**\n     * Clear all callbacks\n     */\n    clearAll() {\n        this.callbacks = {};\n    }\n    /**\n     * Clear all callbacks for a specific group\n     */\n    clear(group) {\n        delete this.callbacks[group];\n    }\n    /**\n     * Add a callback for a group\n     */\n    add(group, cb, scope = null) {\n        if (!this.callbacks[group]) {\n            this.callbacks[group] = new Map();\n        }\n        if (!this.callbacks[group].has(cb)) {\n            this.callbacks[group].set(cb, scope);\n        }\n    }\n    /**\n     * Remove a callback for a group\n     */\n    remove(group, cb) {\n        if (this.callbacks[group]) {\n            this.callbacks[group].delete(cb);\n        }\n    }\n    /**\n     * Trigger all callbacks inside a group\n     */\n    trigger(group, ...args) {\n        if (this.callbacks[group]) {\n            let cbs = [...this.callbacks[group]];\n            for (let [cb, scope] of cbs) {\n                cb.apply(scope, args);\n            }\n        }\n    }\n}\nCallbackGroup.Namespace=`Aventus`;\r\n_.CallbackGroup=CallbackGroup;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Parameters","isStrong":false}],"fullName":"Aventus.CallbackGroup","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let compareObject=function compareObject(obj1, obj2) {\n    if (Array.isArray(obj1)) {\n        if (!Array.isArray(obj2)) {\n            return false;\n        }\n        obj2 = obj2.slice();\n        if (obj1.length !== obj2.length) {\n            return false;\n        }\n        for (let i = 0; i < obj1.length; i++) {\n            let foundElement = false;\n            for (let j = 0; j < obj2.length; j++) {\n                if (compareObject(obj1[i], obj2[j])) {\n                    obj2.splice(j, 1);\n                    foundElement = true;\n                    break;\n                }\n            }\n            if (!foundElement) {\n                return false;\n            }\n        }\n        return true;\n    }\n    else if (typeof obj1 === 'object' && obj1 !== undefined && obj1 !== null) {\n        if (typeof obj2 !== 'object' || obj2 === undefined || obj2 === null) {\n            return false;\n        }\n        if (obj1 == obj2) {\n            return true;\n        }\n        if (obj1 instanceof HTMLElement || obj2 instanceof HTMLElement) {\n            return false;\n        }\n        if (obj1 instanceof Date || obj2 instanceof Date) {\n            return obj1.toString() === obj2.toString();\n        }\n        let oneProxy = false;\n        if (Watcher.is(obj1)) {\n            oneProxy = true;\n            obj1 = Watcher.extract(obj1, false);\n        }\n        if (Watcher.is(obj2)) {\n            oneProxy = true;\n            obj2 = Watcher.extract(obj2, false);\n        }\n        if (obj1 instanceof Map && obj2 instanceof Map) {\n            if (obj1.size != obj2.size) {\n                return false;\n            }\n            const keys = obj1.keys();\n            for (let key in keys) {\n                if (!obj2.has(key)) {\n                    return false;\n                }\n                if (!compareObject(obj1.get(key), obj2.get(key))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        else {\n            if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n                return false;\n            }\n            for (let key in obj1) {\n                if (oneProxy && Watcher['__reservedName'][key]) {\n                    continue;\n                }\n                if (!(key in obj2)) {\n                    return false;\n                }\n                if (!compareObject(obj1[key], obj2[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    else {\n        return obj1 === obj2;\n    }\n}\n_.compareObject=compareObject;\r\n","dependances":[{"fullName":"Aventus.Watcher","isStrong":false}],"fullName":"Aventus.compareObject","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"let getValueFromObject=function getValueFromObject(path, obj) {\n    if (path === undefined) {\n        path = '';\n    }\n    path = path.replace(/\\[(.*?)\\]/g, '.$1');\n    if (path == \"\") {\n        return obj;\n    }\n    const val = (key) => {\n        if (obj instanceof Map) {\n            return obj.get(key);\n        }\n        return obj[key];\n    };\n    let splitted = path.split(\".\");\n    for (let i = 0; i < splitted.length - 1; i++) {\n        let split = splitted[i];\n        let value = val(split);\n        if (!value || typeof value !== 'object') {\n            return undefined;\n        }\n        obj = value;\n    }\n    if (!obj || typeof obj !== 'object') {\n        return undefined;\n    }\n    return val(splitted[splitted.length - 1]);\n}\n_.getValueFromObject=getValueFromObject;\r\n","dependances":[],"fullName":"Aventus.getValueFromObject","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"var WatchAction;\n(function (WatchAction) {\n    WatchAction[WatchAction[\"CREATED\"] = 0] = \"CREATED\";\n    WatchAction[WatchAction[\"UPDATED\"] = 1] = \"UPDATED\";\n    WatchAction[WatchAction[\"DELETED\"] = 2] = \"DELETED\";\n})(WatchAction || (WatchAction = {}));\n_.WatchAction=WatchAction;\r\n","dependances":[],"fullName":"Aventus.WatchAction","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"let Async=function Async(el) {\n    return new Promise((resolve) => {\n        if (el instanceof Promise) {\n            el.then(resolve);\n        }\n        else {\n            resolve(el);\n        }\n    });\n}\n_.Async=Async;\r\n","dependances":[{"fullName":"Aventus.Asyncable","isStrong":false}],"fullName":"Aventus.Async","required":false,"type":4,"isExported":true,"convertibleName":""},{"code":"var HttpMethod;\n(function (HttpMethod) {\n    HttpMethod[\"GET\"] = \"GET\";\n    HttpMethod[\"POST\"] = \"POST\";\n    HttpMethod[\"DELETE\"] = \"DELETE\";\n    HttpMethod[\"PUT\"] = \"PUT\";\n    HttpMethod[\"OPTION\"] = \"OPTION\";\n})(HttpMethod || (HttpMethod = {}));\n_.HttpMethod=HttpMethod;\r\n","dependances":[],"fullName":"Aventus.HttpMethod","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"var HttpErrorCode;\n(function (HttpErrorCode) {\n    HttpErrorCode[HttpErrorCode[\"unknow\"] = 0] = \"unknow\";\n})(HttpErrorCode || (HttpErrorCode = {}));\n_.HttpErrorCode=HttpErrorCode;\r\n","dependances":[],"fullName":"Aventus.HttpErrorCode","required":false,"type":6,"isExported":true,"convertibleName":""},{"code":"let DateConverter=class DateConverter {\n    static __converter = new DateConverter();\n    static get converter() {\n        return this.__converter;\n    }\n    static set converter(value) {\n        this.__converter = value;\n    }\n    isStringDate(txt) {\n        return /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d{3})Z$/.exec(txt) !== null;\n    }\n    fromString(txt) {\n        return new Date(txt);\n    }\n    toString(date) {\n        if (date.getFullYear() < 100) {\n            return \"0001-01-01T00:00:00.000Z\";\n        }\n        return date.toISOString();\n    }\n}\nDateConverter.Namespace=`Aventus`;\r\n_.DateConverter=DateConverter;\r\n","dependances":[{"fullName":"Date","isStrong":false}],"fullName":"Aventus.DateConverter","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Json=class Json {\n    /**\n     * Converts a JavaScript class instance to a JSON object.\n     * @template T - The type of the object to convert.\n     * @param {T} obj - The object to convert to JSON.\n     * @param {JsonToOptions} [options] - Options for JSON conversion.\n     * @returns {{ [key: string | number]: any; }} Returns the JSON representation of the object.\n     */\n    static classToJson(obj, options) {\n        const realOptions = {\n            isValidKey: options?.isValidKey ?? (() => true),\n            replaceKey: options?.replaceKey ?? ((key) => key),\n            transformValue: options?.transformValue ?? ((key, value) => value),\n            beforeEnd: options?.beforeEnd ?? ((res) => res)\n        };\n        return this.__classToJson(obj, realOptions);\n    }\n    static __classToJson(obj, options) {\n        let result = {};\n        let descriptors = Object.getOwnPropertyDescriptors(obj);\n        for (let key in descriptors) {\n            if (options.isValidKey(key))\n                result[options.replaceKey(key)] = options.transformValue(key, descriptors[key].value);\n        }\n        let cst = obj.constructor;\n        while (cst.prototype && cst != Object.prototype) {\n            let descriptorsClass = Object.getOwnPropertyDescriptors(cst.prototype);\n            for (let key in descriptorsClass) {\n                if (options.isValidKey(key)) {\n                    let descriptor = descriptorsClass[key];\n                    if (descriptor?.get) {\n                        result[options.replaceKey(key)] = options.transformValue(key, obj[key]);\n                    }\n                }\n            }\n            cst = Object.getPrototypeOf(cst);\n        }\n        result = options.beforeEnd(result);\n        return result;\n    }\n    /**\n    * Converts a JSON object to a JavaScript class instance.\n    * @template T - The type of the object to convert.\n    * @param {T} obj - The object to populate with JSON data.\n    * @param {*} data - The JSON data to populate the object with.\n    * @param {JsonFromOptions} [options] - Options for JSON deserialization.\n    * @returns {T} Returns the populated object.\n    */\n    static classFromJson(obj, data, options) {\n        let realOptions = {\n            transformValue: options?.transformValue ?? ((key, value) => value),\n            replaceUndefined: options?.replaceUndefined ?? false,\n            replaceUndefinedWithKey: options?.replaceUndefinedWithKey ?? false,\n        };\n        return this.__classFromJson(obj, data, realOptions);\n    }\n    static __classFromJson(obj, data, options) {\n        let props = Object.getOwnPropertyNames(obj);\n        for (let prop of props) {\n            let propUpperFirst = prop[0].toUpperCase() + prop.slice(1);\n            let value = data[prop] === undefined ? data[propUpperFirst] : data[prop];\n            if (value !== undefined || options.replaceUndefined || (options.replaceUndefinedWithKey && (Object.hasOwn(data, prop) || Object.hasOwn(data, propUpperFirst)))) {\n                let propInfo = Object.getOwnPropertyDescriptor(obj, prop);\n                if (propInfo?.writable) {\n                    obj[prop] = options.transformValue(prop, value);\n                }\n            }\n        }\n        let cstTemp = obj.constructor;\n        while (cstTemp.prototype && cstTemp != Object.prototype) {\n            props = Object.getOwnPropertyNames(cstTemp.prototype);\n            for (let prop of props) {\n                let propUpperFirst = prop[0].toUpperCase() + prop.slice(1);\n                let value = data[prop] === undefined ? data[propUpperFirst] : data[prop];\n                if (value !== undefined || options.replaceUndefined || (options.replaceUndefinedWithKey && (Object.hasOwn(data, prop) || Object.hasOwn(data, propUpperFirst)))) {\n                    let propInfo = Object.getOwnPropertyDescriptor(cstTemp.prototype, prop);\n                    if (propInfo?.set) {\n                        obj[prop] = options.transformValue(prop, value);\n                    }\n                }\n            }\n            cstTemp = Object.getPrototypeOf(cstTemp);\n        }\n        return obj;\n    }\n}\nJson.Namespace=`Aventus`;\r\n_.Json=Json;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Object","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.JsonToOptions","isStrong":false},{"fullName":"Required","isStrong":false},{"fullName":"Aventus.JsonFromOptions","isStrong":false}],"fullName":"Aventus.Json","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ConverterTransform=class ConverterTransform {\n    transform(data) {\n        return this.transformLoop(data);\n    }\n    createInstance(data) {\n        if (data.$type) {\n            let cst = Converter.info.get(data.$type);\n            if (cst) {\n                return new cst();\n            }\n        }\n        return undefined;\n    }\n    beforeTransformObject(obj) {\n    }\n    afterTransformObject(obj) {\n    }\n    transformLoop(data) {\n        if (data === null) {\n            return data;\n        }\n        if (Array.isArray(data)) {\n            let result = [];\n            for (let element of data) {\n                result.push(this.transformLoop(element));\n            }\n            return result;\n        }\n        if (data instanceof Date) {\n            return data;\n        }\n        if (typeof data === 'object' && !/^\\s*class\\s+/.test(data.toString())) {\n            let objTemp = this.createInstance(data);\n            if (objTemp) {\n                if (objTemp instanceof Map) {\n                    if (data.values) {\n                        for (const keyValue of data.values) {\n                            objTemp.set(this.transformLoop(keyValue[0]), this.transformLoop(keyValue[1]));\n                        }\n                    }\n                    return objTemp;\n                }\n                let obj = objTemp;\n                this.beforeTransformObject(obj);\n                if (obj.fromJSON) {\n                    obj = obj.fromJSON(data);\n                }\n                else {\n                    obj = Json.classFromJson(obj, data, {\n                        transformValue: (key, value) => {\n                            if (obj[key] instanceof Date) {\n                                return value ? new Date(value) : null;\n                            }\n                            else if (typeof value == 'string' && DateConverter.converter.isStringDate(value)) {\n                                return value ? DateConverter.converter.fromString(value) : null;\n                            }\n                            else if (obj[key] instanceof Map) {\n                                let map = new Map();\n                                for (const keyValue of value) {\n                                    map.set(this.transformLoop(keyValue[0]), this.transformLoop(keyValue[1]));\n                                }\n                                return map;\n                            }\n                            else if (obj instanceof Data) {\n                                let cst = obj.constructor;\n                                if (cst.$schema[key] == 'boolean') {\n                                    return value ? true : false;\n                                }\n                                else if (cst.$schema[key] == 'number') {\n                                    return isNaN(Number(value)) ? 0 : Number(value);\n                                }\n                                else if (cst.$schema[key] == 'number') {\n                                    return isNaN(Number(value)) ? 0 : Number(value);\n                                }\n                                else if (cst.$schema[key] == 'Date') {\n                                    return value ? new Date(value) : null;\n                                }\n                            }\n                            return this.transformLoop(value);\n                        }\n                    });\n                }\n                this.afterTransformObject(obj);\n                return obj;\n            }\n            let result = {};\n            for (let key in data) {\n                result[key] = this.transformLoop(data[key]);\n            }\n            return result;\n        }\n        if (typeof data == 'string' && /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d{3})Z$/.exec(data)) {\n            return new Date(data);\n        }\n        return data;\n    }\n    copyValuesClass(target, src, options) {\n        const realOptions = {\n            isValidKey: options?.isValidKey ?? (() => true),\n            replaceKey: options?.replaceKey ?? ((key) => key),\n            transformValue: options?.transformValue ?? ((key, value) => value),\n        };\n        this.__classCopyValues(target, src, realOptions);\n    }\n    __classCopyValues(target, src, options) {\n        let props = Object.getOwnPropertyNames(target);\n        for (let prop of props) {\n            let propInfo = Object.getOwnPropertyDescriptor(target, prop);\n            if (propInfo?.writable) {\n                if (options.isValidKey(prop))\n                    target[options.replaceKey(prop)] = options.transformValue(prop, src[prop]);\n            }\n        }\n        let cstTemp = target.constructor;\n        while (cstTemp.prototype && cstTemp != Object.prototype) {\n            props = Object.getOwnPropertyNames(cstTemp.prototype);\n            for (let prop of props) {\n                let propInfo = Object.getOwnPropertyDescriptor(cstTemp.prototype, prop);\n                if (propInfo?.set && propInfo.get) {\n                    if (options.isValidKey(prop))\n                        target[options.replaceKey(prop)] = options.transformValue(prop, src[prop]);\n                }\n            }\n            cstTemp = Object.getPrototypeOf(cstTemp);\n        }\n    }\n}\nConverterTransform.Namespace=`Aventus`;\r\n_.ConverterTransform=ConverterTransform;\r\n","dependances":[{"fullName":"Aventus.IConverterTransform","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Object","isStrong":false},{"fullName":"Aventus.Converter","isStrong":false},{"fullName":"Aventus.Json","isStrong":false},{"fullName":"Aventus.DateConverter","isStrong":false},{"fullName":"Aventus.ClassCopyOptions","isStrong":false},{"fullName":"Required","isStrong":false},{"fullName":"Aventus.Data","isStrong":false}],"fullName":"Aventus.ConverterTransform","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Converter=class Converter {\n    /**\n    * Map storing information about registered types.\n    */\n    static info = new Map([[\"Aventus.Map\", Map]]);\n    /**\n    * Map storing schemas for registered types.\n    */\n    static schema = new Map();\n    /**\n     * Internal converter instance.\n     */\n    static __converter = new ConverterTransform();\n    /**\n     * Getter for the internal converter instance.\n     */\n    static get converterTransform() {\n        return this.__converter;\n    }\n    /**\n    * Sets the converter instance.\n    * @param converter The converter instance to set.\n    */\n    static setConverter(converter) {\n        this.__converter = converter;\n    }\n    /**\n    * Registers a unique string type for any class.\n    * @param $type The unique string type identifier.\n    * @param cst The constructor function for the class.\n    * @param schema Optional schema for the registered type.\n    */\n    static register($type, cst, schema) {\n        this.info.set($type, cst);\n        if (schema) {\n            this.schema.set($type, schema);\n        }\n    }\n    /**\n     * Transforms the provided data using the current converter instance.\n     * @template T\n     * @param {*} data The data to transform.\n     * @param {IConverterTransform} [converter] Optional converter instance to use for transformation.\n     * @returns {T} Returns the transformed data.\n     */\n    static transform(data, converter) {\n        if (!converter) {\n            converter = this.converterTransform;\n        }\n        return converter.transform(data);\n    }\n    /**\n     * Copies values from one class instance to another using the current converter instance.\n     * @template T\n     * @param {T} to The destination class instance to copy values into.\n     * @param {T} from The source class instance to copy values from.\n     * @param {ClassCopyOptions} [options] Optional options for the copy operation.\n     * @param {IConverterTransform} [converter] Optional converter instance to use for the copy operation.\n     * @returns {T} Returns the destination class instance with copied values.\n     */\n    static copyValuesClass(to, from, options, converter) {\n        if (!converter) {\n            converter = this.converterTransform;\n        }\n        return converter.copyValuesClass(to, from, options);\n    }\n}\nConverter.Namespace=`Aventus`;\r\n_.Converter=Converter;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Map","isStrong":true},{"fullName":"Aventus.Schema","isStrong":true},{"fullName":"Aventus.IConverterTransform","isStrong":true},{"fullName":"Aventus.ConverterTransform","isStrong":true},{"fullName":"T","isStrong":false},{"fullName":"Object","isStrong":false},{"fullName":"Aventus.ClassCopyOptions","isStrong":false}],"fullName":"Aventus.Converter","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Data=class Data {\n    /**\n     * The schema for the class\n     */\n    static $schema;\n    /**\n     * The current namespace\n     */\n    static Namespace = \"\";\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    /**\n     * Get the name of the class\n     */\n    get className() {\n        return this.constructor.name;\n    }\n    /**\n     * Get a JSON for the current object\n     */\n    toJSON() {\n        let toAvoid = ['className', 'namespace'];\n        return Json.classToJson(this, {\n            isValidKey: (key) => !toAvoid.includes(key)\n        });\n    }\n    /**\n     * Clone the object by transforming a parsed JSON string back into the original type\n     */\n    clone() {\n        return Converter.transform(JSON.parse(JSON.stringify(this)));\n    }\n}\nData.Namespace=`Aventus`;\r\n_.Data=Data;\r\n","dependances":[{"fullName":"Aventus.IData","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Json","isStrong":false},{"fullName":"Aventus.Converter","isStrong":false}],"fullName":"Aventus.Data","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let GenericError=class GenericError {\n    /**\n     * Code for the error\n     */\n    code;\n    /**\n     * Description of the error\n     */\n    message;\n    /**\n     * Additional details related to the error.\n     */\n    details = [];\n    /**\n     * Creates a new instance of GenericError.\n     * @param {EnumValue<T>} code - The error code.\n     * @param {string} message - The error message.\n     */\n    constructor(code, message) {\n        this.code = code;\n        this.message = message + '';\n    }\n}\nGenericError.Namespace=`Aventus`;\r\n_.GenericError=GenericError;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Enum","isStrong":false},{"fullName":"Aventus.EnumValue","isStrong":false}],"fullName":"Aventus.GenericError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let VoidWithError=class VoidWithError {\n    /**\n     * Determine if the action is a success\n     */\n    get success() {\n        return this.errors.length == 0;\n    }\n    /**\n     * List of errors\n     */\n    errors = [];\n    /**\n     * Converts the current instance to a VoidWithError object.\n     * @returns {VoidWithError} A new instance of VoidWithError with the same error list.\n     */\n    toGeneric() {\n        const result = new VoidWithError();\n        result.errors = this.errors;\n        return result;\n    }\n    /**\n    * Checks if the error list contains a specific error code.\n    * @template U - The type of error, extending GenericError.\n    * @template T - The type of the error code, which extends either number or Enum.\n    * @param {EnumValue<T>} code - The error code to check for.\n    * @param {new (...args: any[]) => U} [type] - Optional constructor function of the error type.\n    * @returns {boolean} True if the error list contains the specified error code, otherwise false.\n    */\n    containsCode(code, type) {\n        if (type) {\n            for (let error of this.errors) {\n                if (error instanceof type) {\n                    if (error.code == code) {\n                        return true;\n                    }\n                }\n            }\n        }\n        else {\n            for (let error of this.errors) {\n                if (error.code == code) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\nVoidWithError.Namespace=`Aventus`;\r\n_.VoidWithError=VoidWithError;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.GenericError","isStrong":false},{"fullName":"Aventus.Enum","isStrong":false},{"fullName":"Aventus.EnumValue","isStrong":false},{"fullName":"U","isStrong":false}],"fullName":"Aventus.VoidWithError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ResultWithError=class ResultWithError extends VoidWithError {\n    /**\n      * The result value of the action.\n      * @type {U | undefined}\n      */\n    result;\n    /**\n     * Converts the current instance to a ResultWithError object.\n     * @returns {ResultWithError<U>} A new instance of ResultWithError with the same error list and result value.\n     */\n    toGeneric() {\n        const result = new ResultWithError();\n        result.errors = this.errors;\n        result.result = this.result;\n        return result;\n    }\n}\nResultWithError.Namespace=`Aventus`;\r\n_.ResultWithError=ResultWithError;\r\n","dependances":[{"fullName":"Aventus.VoidWithError","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.GenericError","isStrong":false}],"fullName":"Aventus.ResultWithError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let HttpError=class HttpError extends GenericError {\n}\nHttpError.Namespace=`Aventus`;\r\n_.HttpError=HttpError;\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Aventus.HttpErrorCode","isStrong":false},{"fullName":"Storybook","isStrong":false}],"fullName":"Aventus.HttpError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Signal=class Signal {\n    __subscribes = [];\n    _value;\n    _onChange;\n    get value() {\n        Watcher._register?.register(this, \"*\", Watcher._register.version, \"*\");\n        return this._value;\n    }\n    set value(item) {\n        const oldValue = this._value;\n        this._value = item;\n        if (oldValue != item) {\n            if (this._onChange) {\n                this._onChange();\n            }\n            for (let fct of this.__subscribes) {\n                fct(WatchAction.UPDATED, \"*\", item, []);\n            }\n        }\n    }\n    constructor(item, onChange) {\n        this._value = item;\n        this._onChange = onChange;\n    }\n    subscribe(fct) {\n        let index = this.__subscribes.indexOf(fct);\n        if (index == -1) {\n            this.__subscribes.push(fct);\n        }\n    }\n    unsubscribe(fct) {\n        let index = this.__subscribes.indexOf(fct);\n        if (index > -1) {\n            this.__subscribes.splice(index, 1);\n        }\n    }\n    destroy() {\n        this.__subscribes = [];\n    }\n}\nSignal.Namespace=`Aventus`;\r\n_.Signal=Signal;\r\n","dependances":[{"fullName":"Aventus.EffectReceiver","isStrong":true},{"fullName":"Aventus.WatcherChange","isStrong":false},{"fullName":"Internal","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Signal","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Effect=class Effect {\n    callbacks = [];\n    isInit = false;\n    isDestroy = false;\n    __subscribes = [];\n    __allowChanged = [];\n    version = 0;\n    fct;\n    constructor(fct) {\n        this.fct = fct;\n        if (this.autoInit()) {\n            this.init();\n        }\n    }\n    autoInit() {\n        return true;\n    }\n    init() {\n        this.isInit = true;\n        this.run();\n    }\n    run() {\n        this.version++;\n        Watcher._registering.push(this);\n        let result = this.fct();\n        Watcher._registering.splice(Watcher._registering.length - 1, 1);\n        for (let i = 0; i < this.callbacks.length; i++) {\n            if (this.callbacks[i].version != this.version) {\n                this.callbacks[i].receiver.unsubscribe(this.callbacks[i].cb);\n                this.callbacks.splice(i, 1);\n                i--;\n            }\n        }\n        return result;\n    }\n    register(receiver, path, version, fullPath) {\n        for (let info of this.callbacks) {\n            if (info.receiver == receiver && info.path == path && receiver.__path == info.registerPath) {\n                info.version = version;\n                info.fullPath = fullPath;\n                return;\n            }\n        }\n        let cb;\n        if (path == \"*\") {\n            cb = (action, changePath, value, dones) => { this.onChange(action, changePath, value, dones); };\n        }\n        else {\n            cb = (action, changePath, value, dones) => {\n                // if(changePath == path || changePath.startsWith(path + \".\") || changePath.startsWith(path + \"[\")) {\n                if (changePath == path) {\n                    this.onChange(action, changePath, value, dones);\n                }\n            };\n        }\n        this.callbacks.push({\n            receiver,\n            path,\n            registerPath: receiver.__path,\n            cb,\n            version,\n            fullPath\n        });\n        receiver.subscribe(cb);\n    }\n    canChange(fct) {\n        this.__allowChanged.push(fct);\n    }\n    checkCanChange(action, changePath, value, dones) {\n        if (this.isDestroy) {\n            return false;\n        }\n        for (let fct of this.__allowChanged) {\n            if (!fct(action, changePath, value, dones)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    onChange(action, changePath, value, dones) {\n        if (!this.checkCanChange(action, changePath, value, dones)) {\n            return;\n        }\n        this.run();\n        for (let fct of this.__subscribes) {\n            fct(action, changePath, value, dones);\n        }\n    }\n    destroy() {\n        this.isDestroy = true;\n        this.clearCallbacks();\n        this.isInit = false;\n    }\n    clearCallbacks() {\n        for (let pair of this.callbacks) {\n            pair.receiver.unsubscribe(pair.cb);\n        }\n        this.callbacks = [];\n    }\n    subscribe(fct) {\n        let index = this.__subscribes.indexOf(fct);\n        if (index == -1) {\n            this.__subscribes.push(fct);\n        }\n    }\n    unsubscribe(fct) {\n        let index = this.__subscribes.indexOf(fct);\n        if (index > -1) {\n            this.__subscribes.splice(index, 1);\n        }\n    }\n}\nEffect.Namespace=`Aventus`;\r\n_.Effect=Effect;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"InternalProtected","isStrong":false},{"fullName":"Aventus.EffectReceiver","isStrong":false},{"fullName":"Aventus.WatcherChange","isStrong":false},{"fullName":"Aventus.WatcherAllowed","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Effect","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Computed=class Computed extends Effect {\n    _value;\n    __path = \"*\";\n    get value() {\n        if (!this.isInit) {\n            this.init();\n        }\n        Watcher._register?.register(this, \"*\", Watcher._register.version, \"*\");\n        return this._value;\n    }\n    autoInit() {\n        return false;\n    }\n    constructor(fct) {\n        super(fct);\n    }\n    init() {\n        this.isInit = true;\n        this.computedValue();\n    }\n    computedValue() {\n        this._value = this.run();\n    }\n    onChange(action, changePath, value, dones) {\n        if (!this.checkCanChange(action, changePath, value, dones)) {\n            return;\n        }\n        let oldValue = this._value;\n        this.computedValue();\n        if (oldValue === this._value) {\n            return;\n        }\n        for (let fct of this.__subscribes) {\n            fct(action, changePath, value, dones);\n        }\n    }\n}\nComputed.Namespace=`Aventus`;\r\n_.Computed=Computed;\r\n","dependances":[{"fullName":"Aventus.Effect","isStrong":true},{"fullName":"Aventus.EffectReceiver","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Internal","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.IsNotVoid","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}],"fullName":"Aventus.Computed","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Watcher=class Watcher {\n    constructor() { }\n    ;\n    static __reservedName = {\n        __path: '__path',\n    };\n    static __triggerForced = false;\n    static _registering = [];\n    static get _register() {\n        return this._registering[this._registering.length - 1];\n    }\n    /**\n     * Transform object into a watcher\n     */\n    static get(obj, onDataChanged) {\n        if (obj == undefined) {\n            console.error(\"You must define an objet / array for your proxy\");\n            return;\n        }\n        if (obj.__isProxy) {\n            if (onDataChanged)\n                obj.subscribe(onDataChanged);\n            return obj;\n        }\n        const reservedName = this.__reservedName;\n        const clearReservedNames = (data) => {\n            if (data instanceof Object && !data.__isProxy) {\n                for (let key in reservedName) {\n                    delete data[key];\n                }\n            }\n        };\n        const setProxyPath = (newProxy, newPath) => {\n            if (newProxy instanceof Object && newProxy.__isProxy) {\n                newProxy.__path = newPath;\n            }\n        };\n        const jsonReplacer = (key, value) => {\n            if (reservedName[key])\n                return undefined;\n            return value;\n        };\n        const addAlias = (otherBaseData, name, cb) => {\n            let cbs = aliases.get(otherBaseData);\n            if (!cbs) {\n                cbs = [];\n                aliases.set(otherBaseData, cbs);\n            }\n            cbs.push({\n                name: name,\n                fct: cb\n            });\n        };\n        const deleteAlias = (otherBaseData, name) => {\n            let cbs = aliases.get(otherBaseData);\n            if (!cbs)\n                return;\n            for (let i = 0; i < cbs.length; i++) {\n                if (cbs[i].name == name) {\n                    cbs.splice(i, 1);\n                    if (cbs.length == 0) {\n                        aliases.delete(otherBaseData);\n                    }\n                    return;\n                }\n            }\n        };\n        const replaceByAlias = (target, element, prop, receiver, apply, out = {}) => {\n            let fullInternalPath = \"\";\n            if (Array.isArray(receiver)) {\n                if (prop != \"length\") {\n                    if (target.__path) {\n                        fullInternalPath = target.__path;\n                    }\n                    fullInternalPath += \"[\" + prop + \"]\";\n                }\n            }\n            else {\n                if (target.__path) {\n                    fullInternalPath = target.__path + '.';\n                }\n                fullInternalPath += prop;\n            }\n            if (receiver && internalAliases[fullInternalPath]) {\n                internalAliases[fullInternalPath].unbind();\n            }\n            if (element instanceof Object && element.__isProxy) {\n                let root = element.__root;\n                if (root != proxyData.baseData) {\n                    element.__validatePath();\n                    let oldPath = element.__path ?? '';\n                    let unbindElement = Watcher.extract(getValueFromObject(oldPath, root));\n                    if (unbindElement === undefined) {\n                        return element;\n                    }\n                    if (receiver == null) {\n                        receiver = getValueFromObject(target.__path, realProxy);\n                        if (internalAliases[fullInternalPath]) {\n                            internalAliases[fullInternalPath].unbind();\n                        }\n                    }\n                    if (apply) {\n                        let result = Reflect.set(target, prop, unbindElement, receiver);\n                    }\n                    element.__addAlias(proxyData.baseData, oldPath, (type, target, receiver2, value, prop2, dones) => {\n                        let triggerPath;\n                        if (prop2.startsWith(\"[\") || fullInternalPath == \"\" || prop2 == \"\") {\n                            triggerPath = fullInternalPath + prop2;\n                        }\n                        else {\n                            triggerPath = fullInternalPath + \".\" + prop2;\n                        }\n                        if (type == 'DELETED' && internalAliases[triggerPath]) {\n                            internalAliases[triggerPath].unbind();\n                        }\n                        triggerPath = triggerPath.replace(/\\[(.*?)\\]/g, '.$1');\n                        let splitted = triggerPath.split(\".\");\n                        let newProp = splitted.pop();\n                        let newReceiver = getValueFromObject(splitted.join(\".\"), realProxy);\n                        if (newReceiver.getTarget(false) == target)\n                            trigger(type, target, newReceiver, value, newProp, dones);\n                    });\n                    internalAliases[fullInternalPath] = {\n                        unbind: () => {\n                            delete internalAliases[fullInternalPath];\n                            element.__deleteAlias(proxyData.baseData, oldPath);\n                            deleteAlias(root, fullInternalPath);\n                        }\n                    };\n                    addAlias(root, fullInternalPath, (type, target, receiver2, value, prop2, dones) => {\n                        const pathSave = element.__path;\n                        let proxy = element.__getProxy;\n                        let triggerPath;\n                        if (prop2.startsWith(\"[\") || oldPath == \"\" || prop2 == \"\") {\n                            triggerPath = oldPath + prop2;\n                        }\n                        else {\n                            triggerPath = oldPath + \".\" + prop2;\n                        }\n                        triggerPath = triggerPath.replace(/\\[(.*?)\\]/g, '.$1');\n                        let splitted = triggerPath.split(\".\");\n                        let newProp = splitted.pop();\n                        let newReceiver = getValueFromObject(splitted.join(\".\"), proxy);\n                        if (newReceiver.getTarget(false) == target)\n                            element.__trigger(type, target, newReceiver, value, newProp, dones);\n                        element.__path = pathSave;\n                    });\n                    out.otherRoot = root;\n                    return unbindElement;\n                }\n            }\n            return element;\n        };\n        let currentTrace = new Error().stack?.split(\"\\n\") ?? [];\n        currentTrace.shift();\n        currentTrace.shift();\n        const aliases = new Map();\n        const internalAliases = {};\n        let proxyData = {\n            baseData: {},\n            callbacks: {},\n            callbacksReverse: new Map(),\n            avoidUpdate: [],\n            pathToRemove: [],\n            injectedDones: null,\n            history: [{\n                    object: JSON.parse(JSON.stringify(obj, jsonReplacer)),\n                    trace: currentTrace,\n                    action: 'init',\n                    path: ''\n                }],\n            useHistory: false,\n            getProxyObject(target, element, prop) {\n                let newProxy;\n                element = replaceByAlias(target, element, prop, null, true);\n                if (element instanceof Object && element.__isProxy) {\n                    newProxy = element;\n                }\n                else {\n                    try {\n                        if (element instanceof Computed) {\n                            return element;\n                        }\n                        if (element instanceof HTMLElement) {\n                            return element;\n                        }\n                        if (element instanceof Object) {\n                            newProxy = new Proxy(element, this);\n                        }\n                        else {\n                            return element;\n                        }\n                    }\n                    catch {\n                        return element;\n                    }\n                }\n                let newPath = '';\n                if (Array.isArray(target)) {\n                    if (/^[0-9]*$/g.exec(prop)) {\n                        if (target.__path) {\n                            newPath = target.__path;\n                        }\n                        newPath += \"[\" + prop + \"]\";\n                        setProxyPath(newProxy, newPath);\n                    }\n                    else {\n                        newPath += \".\" + prop;\n                        setProxyPath(newProxy, newPath);\n                    }\n                }\n                else if (element instanceof Date) {\n                    return element;\n                }\n                else {\n                    if (target.__path) {\n                        newPath = target.__path + '.';\n                    }\n                    newPath += prop;\n                    setProxyPath(newProxy, newPath);\n                }\n                return newProxy;\n            },\n            tryCustomFunction(target, prop, receiver) {\n                if (prop == \"__isProxy\") {\n                    return true;\n                }\n                else if (prop == \"__getProxy\") {\n                    return realProxy;\n                }\n                else if (prop == \"__root\") {\n                    return this.baseData;\n                }\n                else if (prop == \"__validatePath\") {\n                    return () => {\n                        if (this.baseData == target) {\n                            target.__path = \"\";\n                        }\n                    };\n                }\n                else if (prop == \"__callbacks\") {\n                    return this.callbacks;\n                }\n                else if (prop == \"subscribe\") {\n                    let path = receiver.__path;\n                    return (cb) => {\n                        if (!this.callbacks[path]) {\n                            this.callbacks[path] = [];\n                        }\n                        this.callbacks[path].push(cb);\n                        this.callbacksReverse.set(cb, path);\n                    };\n                }\n                else if (prop == \"unsubscribe\") {\n                    return (cb) => {\n                        let oldPath = this.callbacksReverse.get(cb);\n                        if (oldPath === undefined)\n                            return;\n                        if (!this.callbacks[oldPath]) {\n                            return;\n                        }\n                        let index = this.callbacks[oldPath].indexOf(cb);\n                        if (index > -1) {\n                            this.callbacks[oldPath].splice(index, 1);\n                        }\n                        this.callbacksReverse.delete(cb);\n                    };\n                }\n                else if (prop == \"getHistory\") {\n                    return () => {\n                        return this.history;\n                    };\n                }\n                else if (prop == \"clearHistory\") {\n                    this.history = [];\n                }\n                else if (prop == \"enableHistory\") {\n                    return () => {\n                        this.useHistory = true;\n                    };\n                }\n                else if (prop == \"disableHistory\") {\n                    return () => {\n                        this.useHistory = false;\n                    };\n                }\n                else if (prop == \"getTarget\") {\n                    return (clear = true) => {\n                        if (clear)\n                            clearReservedNames(target);\n                        return target;\n                    };\n                }\n                else if (prop == \"toJSON\") {\n                    if (target.toJSON) {\n                        return target.toJSON;\n                    }\n                    if (Array.isArray(receiver)) {\n                        return () => {\n                            let result = [];\n                            for (let element of target) {\n                                result.push(element);\n                            }\n                            return result;\n                        };\n                    }\n                    return () => {\n                        let result = {};\n                        for (let key of Object.keys(target)) {\n                            if (reservedName[key]) {\n                                continue;\n                            }\n                            result[key] = target[key];\n                        }\n                        return result;\n                    };\n                }\n                else if (prop == \"__addAlias\") {\n                    return addAlias;\n                }\n                else if (prop == \"__deleteAlias\") {\n                    return deleteAlias;\n                }\n                else if (prop == \"__injectedDones\") {\n                    return (dones) => {\n                        this.injectedDones = dones;\n                    };\n                }\n                else if (prop == \"__trigger\") {\n                    return trigger;\n                }\n                else if (prop == \"__static_trigger\") {\n                    return (type) => {\n                        Watcher.__triggerForced = true;\n                        trigger(type, target, receiver, target, '');\n                        Watcher.__triggerForced = false;\n                    };\n                }\n                return undefined;\n            },\n            get(target, prop, receiver) {\n                if (typeof prop == 'symbol') {\n                    return Reflect.get(target, prop, receiver);\n                }\n                if (reservedName[prop]) {\n                    return target[prop];\n                }\n                let customResult = this.tryCustomFunction(target, prop, receiver);\n                if (customResult !== undefined) {\n                    return customResult;\n                }\n                let element = target[prop];\n                if (typeof (element) == 'function') {\n                    if (Array.isArray(receiver)) {\n                        let result;\n                        if (prop == 'push') {\n                            if (target.__isProxy) {\n                                result = (el) => {\n                                    let index = target.push(el);\n                                    return index;\n                                };\n                            }\n                            else {\n                                result = (el) => {\n                                    let index = target.length;\n                                    let out = {};\n                                    el = replaceByAlias(target, el, target.length + '', receiver, false, out);\n                                    target.push(el);\n                                    const dones = [];\n                                    if (out.otherRoot) {\n                                        dones.push(out.otherRoot);\n                                    }\n                                    trigger('CREATED', target, receiver, receiver[index], \"[\" + (index) + \"]\", dones);\n                                    trigger('UPDATED', target, receiver, target.length, \"length\", dones);\n                                    return index;\n                                };\n                            }\n                        }\n                        else if (prop == 'splice') {\n                            if (target.__isProxy) {\n                                result = (index, nbRemove, ...insert) => {\n                                    let res = target.splice(index, nbRemove, ...insert);\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = (index, nbRemove, ...insert) => {\n                                    let oldValues = [];\n                                    const extReceiver = Watcher.extract(receiver);\n                                    for (let i = index; i < index + nbRemove; i++) {\n                                        oldValues.push(extReceiver[i]);\n                                    }\n                                    let updateLength = nbRemove != insert.length;\n                                    for (let i = 0; i < oldValues.length; i++) {\n                                        target.splice((index + i), 1);\n                                        trigger('DELETED', target, receiver, oldValues[i], \"[\" + index + \"]\");\n                                    }\n                                    for (let i = 0; i < insert.length; i++) {\n                                        const out = {};\n                                        let value = replaceByAlias(target, insert[i], (index + i) + '', receiver, false, out);\n                                        const dones = out.otherRoot ? [out.otherRoot] : [];\n                                        target.splice((index + i), 0, value);\n                                        trigger('CREATED', target, receiver, receiver[(index + i)], \"[\" + (index + i) + \"]\", dones);\n                                    }\n                                    if (updateLength)\n                                        trigger('UPDATED', target, receiver, target.length, \"length\");\n                                    return target;\n                                };\n                            }\n                        }\n                        else if (prop == 'pop') {\n                            if (target.__isProxy) {\n                                result = () => {\n                                    let res = target.pop();\n                                    return res;\n                                };\n                            }\n                            else {\n                                result = () => {\n                                    let index = target.length - 1;\n                                    let oldValue = receiver.length ? receiver[receiver.length] : undefined;\n                                    let res = target.pop();\n                                    trigger('DELETED', target, receiver, oldValue, \"[\" + index + \"]\");\n                                    trigger('UPDATED', target, receiver, target.length, \"length\");\n                                    return res;\n                                };\n                            }\n                        }\n                        else {\n                            result = element.bind(target);\n                        }\n                        return result;\n                    }\n                    else if (target instanceof Map) {\n                        let result;\n                        if (prop == \"set\") {\n                            if (target.__isProxy) {\n                                result = (key, value) => {\n                                    return target.set(key, value);\n                                };\n                            }\n                            else {\n                                result = (key, value) => {\n                                    const out = {};\n                                    let dones = [];\n                                    key = Watcher.extract(key);\n                                    value = replaceByAlias(target, value, key + '', receiver, false, out);\n                                    if (out.otherRoot)\n                                        dones.push(out.otherRoot);\n                                    let result = target.set(key, value);\n                                    trigger('CREATED', target, receiver, receiver.get(key), key + '', dones);\n                                    trigger('UPDATED', target, receiver, target.size, \"size\", dones);\n                                    return result;\n                                };\n                            }\n                        }\n                        else if (prop == \"clear\") {\n                            if (target.__isProxy) {\n                                result = () => {\n                                    return target.clear();\n                                };\n                            }\n                            else {\n                                result = () => {\n                                    let keys = target.keys();\n                                    for (let key of keys) {\n                                        let oldValue = receiver.get(key);\n                                        target.delete(key);\n                                        trigger('DELETED', target, receiver, oldValue, key);\n                                        trigger('UPDATED', target, receiver, target.size, \"size\");\n                                    }\n                                };\n                            }\n                        }\n                        else if (prop == \"delete\") {\n                            if (target.__isProxy) {\n                                result = (key) => {\n                                    return target.delete(key);\n                                };\n                            }\n                            else {\n                                result = (key) => {\n                                    key = Watcher.extract(key);\n                                    let oldValue = receiver.get(key);\n                                    let res = target.delete(key);\n                                    trigger('DELETED', target, receiver, oldValue, key + '');\n                                    trigger('UPDATED', target, receiver, target.size, \"size\");\n                                    return res;\n                                };\n                            }\n                        }\n                        else {\n                            result = element.bind(target);\n                        }\n                        return result;\n                    }\n                    return element.bind(target);\n                }\n                if (element instanceof Computed) {\n                    return element.value;\n                }\n                if (Watcher._registering.length > 0) {\n                    let currentPath;\n                    let fullPath;\n                    let isArray = Array.isArray(receiver);\n                    if (isArray && /^[0-9]*$/g.exec(prop)) {\n                        fullPath = receiver.__path + \"[\" + prop + \"]\";\n                        currentPath = \"[\" + prop + \"]\";\n                    }\n                    else {\n                        fullPath = receiver.__path ? receiver.__path + '.' + prop : prop;\n                        currentPath = prop;\n                    }\n                    Watcher._register?.register(receiver, currentPath, Watcher._register.version, fullPath);\n                }\n                if (typeof (element) == 'object') {\n                    return this.getProxyObject(target, element, prop);\n                }\n                return Reflect.get(target, prop, receiver);\n            },\n            set(target, prop, value, receiver) {\n                if (typeof prop == 'symbol') {\n                    return Reflect.set(target, prop, value, receiver);\n                }\n                let oldValue = Reflect.get(target, prop, receiver);\n                value = replaceByAlias(target, value, prop, receiver, true);\n                if (value instanceof Signal) {\n                    value = value.value;\n                }\n                let triggerChange = false;\n                if (!reservedName[prop]) {\n                    if (Array.isArray(receiver)) {\n                        if (prop != \"length\") {\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        if (!compareObject(value, oldValue)) {\n                            triggerChange = true;\n                        }\n                    }\n                    if (Watcher.__triggerForced) {\n                        triggerChange = true;\n                    }\n                }\n                let result = Reflect.set(target, prop, value, receiver);\n                if (triggerChange) {\n                    let index = this.avoidUpdate.indexOf(prop);\n                    if (index == -1) {\n                        let dones = this.injectedDones ?? [];\n                        this.injectedDones = null;\n                        trigger('UPDATED', target, receiver, value, prop, dones);\n                    }\n                    else {\n                        this.avoidUpdate.splice(index, 1);\n                    }\n                }\n                return result;\n            },\n            deleteProperty(target, prop) {\n                if (typeof prop == 'symbol') {\n                    return Reflect.deleteProperty(target, prop);\n                }\n                let triggerChange = false;\n                let pathToDelete = '';\n                if (!reservedName[prop]) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                pathToDelete = target.__path;\n                            }\n                            pathToDelete += \"[\" + prop + \"]\";\n                            triggerChange = true;\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            pathToDelete = target.__path + '.';\n                        }\n                        pathToDelete += prop;\n                        triggerChange = true;\n                    }\n                }\n                if (internalAliases[pathToDelete]) {\n                    internalAliases[pathToDelete].unbind();\n                }\n                if (target.hasOwnProperty(prop)) {\n                    let oldValue = target[prop];\n                    if (oldValue instanceof Effect || oldValue instanceof Signal) {\n                        oldValue.destroy();\n                    }\n                    delete target[prop];\n                    if (triggerChange) {\n                        clearReservedNames(oldValue);\n                        trigger('DELETED', target, null, oldValue, prop);\n                    }\n                    return true;\n                }\n                return false;\n            },\n            defineProperty(target, prop, descriptor) {\n                if (typeof prop == 'symbol') {\n                    return Reflect.defineProperty(target, prop, descriptor);\n                }\n                let triggerChange = false;\n                let newPath = '';\n                if (!reservedName[prop]) {\n                    if (Array.isArray(target)) {\n                        if (prop != \"length\") {\n                            if (target.__path) {\n                                newPath = target.__path;\n                            }\n                            newPath += \"[\" + prop + \"]\";\n                            if (!target.hasOwnProperty(prop)) {\n                                triggerChange = true;\n                            }\n                        }\n                    }\n                    else {\n                        if (target.__path) {\n                            newPath = target.__path + '.';\n                        }\n                        newPath += prop;\n                        if (!target.hasOwnProperty(prop)) {\n                            triggerChange = true;\n                        }\n                    }\n                }\n                let result = Reflect.defineProperty(target, prop, descriptor);\n                if (triggerChange) {\n                    this.avoidUpdate.push(prop);\n                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);\n                    target[prop] = proxyEl;\n                    trigger('CREATED', target, null, proxyEl, prop);\n                }\n                return result;\n            },\n            ownKeys(target) {\n                let result = Reflect.ownKeys(target);\n                for (let i = 0; i < result.length; i++) {\n                    let key = result[i];\n                    if (typeof key == 'string') {\n                        if (reservedName[key]) {\n                            result.splice(i, 1);\n                            i--;\n                        }\n                    }\n                }\n                return result;\n            },\n        };\n        if (onDataChanged) {\n            proxyData.callbacks[''] = [onDataChanged];\n        }\n        const trigger = (type, target, receiver, value, prop, dones = []) => {\n            if (dones.includes(proxyData.baseData)) {\n                return;\n            }\n            if (target.__isProxy) {\n                return;\n            }\n            let rootPath;\n            if (receiver == null) {\n                rootPath = target.__path;\n            }\n            else {\n                rootPath = receiver.__path;\n            }\n            if (rootPath != \"\") {\n                if (Array.isArray(receiver)) {\n                    if (prop && !prop.startsWith(\"[\")) {\n                        if (/^[0-9]*$/g.exec(prop)) {\n                            rootPath += \"[\" + prop + \"]\";\n                        }\n                        else {\n                            rootPath += \".\" + prop;\n                        }\n                    }\n                    else {\n                        rootPath += prop;\n                    }\n                }\n                else {\n                    if (prop && !prop.startsWith(\"[\")) {\n                        rootPath += \".\";\n                    }\n                    rootPath += prop;\n                }\n            }\n            else {\n                rootPath = prop;\n            }\n            let stacks = [];\n            if (proxyData.useHistory) {\n                let allStacks = new Error().stack?.split(\"\\n\") ?? [];\n                for (let i = allStacks.length - 1; i >= 0; i--) {\n                    let current = allStacks[i].trim().replace(\"at \", \"\");\n                    if (current.startsWith(\"Object.set\") || current.startsWith(\"Proxy.result\")) {\n                        break;\n                    }\n                    stacks.push(current);\n                }\n            }\n            dones.push(proxyData.baseData);\n            let aliasesDone = [];\n            for (let name in proxyData.callbacks) {\n                let pathToSend = rootPath;\n                if (name !== \"\") {\n                    let regex = new RegExp(\"^\" + name.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&') + \"(\\\\.|(\\\\[)|$)\");\n                    if (!regex.test(rootPath)) {\n                        let regex2 = new RegExp(\"^\" + rootPath.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&') + \"(\\\\.|(\\\\[)|$)\");\n                        if (!regex2.test(name)) {\n                            continue;\n                        }\n                        else {\n                            pathToSend = \"\";\n                        }\n                    }\n                    else {\n                        pathToSend = rootPath.replace(regex, \"$2\");\n                    }\n                }\n                if (name === \"\" && proxyData.useHistory) {\n                    proxyData.history.push({\n                        object: JSON.parse(JSON.stringify(proxyData.baseData, jsonReplacer)),\n                        trace: stacks.reverse(),\n                        action: WatchAction[type],\n                        path: pathToSend\n                    });\n                }\n                let cbs = [...proxyData.callbacks[name]];\n                for (let cb of cbs) {\n                    try {\n                        cb(WatchAction[type], pathToSend, value, dones);\n                    }\n                    catch (e) {\n                        if (e != 'impossible')\n                            console.error(e);\n                    }\n                }\n                for (let [key, infos] of aliases) {\n                    if (!dones.includes(key)) {\n                        for (let info of infos) {\n                            if (info.name == name) {\n                                aliasesDone.push(key);\n                                if (target.__path) {\n                                    let oldPath = target.__path;\n                                    info.fct(type, target, receiver, value, prop, dones);\n                                    target.__path = oldPath;\n                                }\n                                else {\n                                    info.fct(type, target, receiver, value, prop, dones);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            for (let [key, infos] of aliases) {\n                if (!dones.includes(key) && !aliasesDone.includes(key)) {\n                    for (let info of infos) {\n                        let regex = new RegExp(\"^\" + info.name.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&') + \"(\\\\.|(\\\\[)|$)\");\n                        if (!regex.test(rootPath)) {\n                            continue;\n                        }\n                        let newProp = rootPath.replace(info.name, \"\");\n                        if (newProp.startsWith(\".\")) {\n                            newProp = newProp.slice(1);\n                        }\n                        if (target.__path) {\n                            let oldPath = target.__path;\n                            info.fct(type, target, receiver, value, newProp, dones);\n                            target.__path = oldPath;\n                        }\n                        else {\n                            info.fct(type, target, receiver, value, newProp, dones);\n                        }\n                    }\n                }\n            }\n        };\n        var realProxy = new Proxy(obj, proxyData);\n        proxyData.baseData = obj;\n        setProxyPath(realProxy, '');\n        return realProxy;\n    }\n    static is(obj) {\n        return typeof obj == 'object' && obj.__isProxy;\n    }\n    static extract(obj, clearPath = false) {\n        if (this.is(obj)) {\n            return obj.getTarget(clearPath);\n        }\n        else {\n            if (obj instanceof Object) {\n                for (let key in this.__reservedName) {\n                    delete obj[key];\n                }\n            }\n        }\n        return obj;\n    }\n    static trigger(type, target) {\n        if (this.is(target)) {\n            target.__static_trigger(type);\n        }\n    }\n    /**\n     * Create a computed variable that will watch any changes\n     */\n    static computed(fct) {\n        const comp = new Computed(fct);\n        return comp;\n    }\n    /**\n     * Create an effect variable that will watch any changes\n     */\n    static effect(fct) {\n        const comp = new Effect(fct);\n        return comp;\n    }\n    /**\n     * Create an effect variable that will watch any changes inside the fct and trigger the cb on change\n     */\n    static watch(fct, cb) {\n        const comp = new Effect(fct);\n        comp.subscribe(cb);\n        return comp;\n    }\n    /**\n     * Create a signal variable\n     */\n    static signal(item, onChange) {\n        return new Signal(item, onChange);\n    }\n}\nWatcher.Namespace=`Aventus`;\r\n_.Watcher=Watcher;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Internal","isStrong":true},{"fullName":"Aventus.Effect","isStrong":true},{"fullName":"Aventus.WatcherFunction","isStrong":false},{"fullName":"Aventus.getValueFromObject","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.WatcherFunctionInternal","isStrong":false},{"fullName":"ProxyData","isStrong":false},{"fullName":"Aventus.Computed","isStrong":false},{"fullName":"Aventus.Signal","isStrong":false},{"fullName":"Aventus.compareObject","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.IsNotVoid","isStrong":false}],"fullName":"Aventus.Watcher","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ComputedNoRecomputed=class ComputedNoRecomputed extends Computed {\n    init() {\n        this.isInit = true;\n        Watcher._registering.push(this);\n        this._value = this.fct();\n        Watcher._registering.splice(Watcher._registering.length - 1, 1);\n    }\n    computedValue() {\n        if (this.isInit)\n            this._value = this.fct();\n        else\n            this.init();\n    }\n    run() { }\n}\nComputedNoRecomputed.Namespace=`Aventus`;\r\n_.ComputedNoRecomputed=ComputedNoRecomputed;\r\n","dependances":[{"fullName":"Aventus.Computed","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false}],"fullName":"Aventus.ComputedNoRecomputed","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let EffectNoRecomputed=class EffectNoRecomputed extends Effect {\n    init() {\n        this.isInit = true;\n        Watcher._registering.push(this);\n        this.fct();\n        Watcher._registering.splice(Watcher._registering.length - 1, 1);\n    }\n    run() {\n        if (!this.isInit) {\n            this.init();\n        }\n    }\n}\nEffectNoRecomputed.Namespace=`Aventus`;\r\n_.EffectNoRecomputed=EffectNoRecomputed;\r\n","dependances":[{"fullName":"Aventus.Effect","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false}],"fullName":"Aventus.EffectNoRecomputed","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let HttpRouter=class HttpRouter {\n    options;\n    constructor() {\n        this.options = this.defineOptions(this.defaultOptionsValue());\n    }\n    defaultOptionsValue() {\n        return {\n            url: location.protocol + \"//\" + location.host\n        };\n    }\n    defineOptions(options) {\n        return options;\n    }\n    async get(url) {\n        return await new HttpRequest(url).queryJSON(this);\n    }\n    async post(url, data) {\n        return await new HttpRequest(url, HttpMethod.POST, data).queryJSON(this);\n    }\n    async put(url, data) {\n        return await new HttpRequest(url, HttpMethod.PUT, data).queryJSON(this);\n    }\n    async delete(url, data) {\n        return await new HttpRequest(url, HttpMethod.DELETE, data).queryJSON(this);\n    }\n    async option(url, data) {\n        return await new HttpRequest(url, HttpMethod.OPTION, data).queryJSON(this);\n    }\n}\nHttpRouter.Namespace=`Aventus`;\r\n_.HttpRouter=HttpRouter;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"InternalProtected","isStrong":false},{"fullName":"Aventus.HttpRouterOptions","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.HttpMethod","isStrong":false},{"fullName":"Aventus.HttpRequest","isStrong":false}],"fullName":"Aventus.HttpRouter","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let HttpRoute=class HttpRoute {\n    router;\n    constructor(router) {\n        this.router = router ?? new HttpRouter();\n    }\n    getPrefix() {\n        return \"\";\n    }\n}\nHttpRoute.Namespace=`Aventus`;\r\n_.HttpRoute=HttpRoute;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.HttpRouter","isStrong":false}],"fullName":"Aventus.HttpRoute","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let HttpRequest=class HttpRequest {\n    static options;\n    static configure(options) {\n        this.options = options;\n    }\n    request;\n    url;\n    constructor(url, method = HttpMethod.GET, body) {\n        this.url = url;\n        this.request = {};\n        this.setMethod(method);\n        this.prepareBody(body);\n    }\n    setUrl(url) {\n        this.url = url;\n    }\n    toString() {\n        return this.url + \" : \" + JSON.stringify(this.request);\n    }\n    setBody(body) {\n        this.prepareBody(body);\n    }\n    setMethod(method) {\n        this.request.method = method;\n    }\n    objectToFormData(obj, formData, parentKey) {\n        formData = formData || new FormData();\n        let byPass = obj;\n        if (byPass.__isProxy) {\n            obj = byPass.getTarget();\n        }\n        const keys = obj.toJSON ? Object.keys(obj.toJSON()) : Object.keys(obj);\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            let value = obj[key];\n            const newKey = parentKey ? `${parentKey}[${key}]` : key;\n            if (value instanceof Date) {\n                formData.append(newKey, DateConverter.converter.toString(value));\n            }\n            else if (typeof value === 'object' &&\n                value !== null &&\n                !(value instanceof File)) {\n                if (Array.isArray(value)) {\n                    for (let j = 0; j < value.length; j++) {\n                        const arrayKey = `${newKey}[${j}]`;\n                        this.objectToFormData({ [arrayKey]: value[j] }, formData);\n                    }\n                }\n                else {\n                    this.objectToFormData(value, formData, newKey);\n                }\n            }\n            else {\n                if (value === undefined || value === null) {\n                    value = \"\";\n                }\n                else if (Watcher.is(value)) {\n                    value = Watcher.extract(value);\n                }\n                formData.append(newKey, value);\n            }\n        }\n        return formData;\n    }\n    jsonReplacer(key, value) {\n        if (this[key] instanceof Date) {\n            return DateConverter.converter.toString(this[key]);\n        }\n        return value;\n    }\n    prepareBody(data) {\n        if (!data) {\n            return;\n        }\n        else if (data instanceof FormData) {\n            this.request.body = data;\n        }\n        else {\n            let useFormData = false;\n            const analyseFormData = (obj) => {\n                for (let key in obj) {\n                    if (obj[key] instanceof File) {\n                        useFormData = true;\n                        break;\n                    }\n                    else if (Array.isArray(obj[key]) && obj[key].length > 0 && obj[key][0] instanceof File) {\n                        useFormData = true;\n                        break;\n                    }\n                    else if (typeof obj[key] == 'object' && !Array.isArray(obj[key]) && !(obj[key] instanceof Date)) {\n                        analyseFormData(obj[key]);\n                        if (useFormData) {\n                            break;\n                        }\n                    }\n                }\n            };\n            analyseFormData(data);\n            if (useFormData) {\n                this.request.body = this.objectToFormData(data);\n            }\n            else {\n                this.request.body = JSON.stringify(data, this.jsonReplacer);\n                this.setHeader(\"Content-Type\", \"Application/json\");\n            }\n        }\n    }\n    setHeader(name, value) {\n        if (!this.request.headers) {\n            this.request.headers = [];\n        }\n        this.request.headers.push([name, value]);\n    }\n    setCredentials(credentials) {\n        this.request.credentials = credentials;\n    }\n    async _query(router) {\n        let result = new ResultWithError();\n        try {\n            if (!this.url.startsWith(\"/\")) {\n                this.url = \"/\" + this.url;\n            }\n            if (HttpRequest.options?.beforeSend) {\n                const beforeSendResult = await HttpRequest.options.beforeSend(this);\n                result.errors = beforeSendResult.errors;\n            }\n            const fullUrl = router ? router.options.url + this.url : this.url;\n            result.result = await fetch(fullUrl, this.request);\n        }\n        catch (e) {\n            result.errors.push(new HttpError(HttpErrorCode.unknow, e));\n        }\n        return result;\n    }\n    async query(router) {\n        let result = await this._query(router);\n        if (HttpRequest.options?.responseMiddleware) {\n            result = await HttpRequest.options.responseMiddleware(result, this);\n        }\n        return result;\n    }\n    async queryVoid(router) {\n        let resultTemp = await this._query(router);\n        let result = new VoidWithError();\n        if (!resultTemp.success) {\n            result.errors = resultTemp.errors;\n            return result;\n        }\n        try {\n            if (!resultTemp.result) {\n                return result;\n            }\n            if (resultTemp.result.status != 204) {\n                let tempResult = Converter.transform(await resultTemp.result.json());\n                if (tempResult instanceof VoidWithError) {\n                    for (let error of tempResult.errors) {\n                        result.errors.push(error);\n                    }\n                }\n            }\n        }\n        catch (e) {\n        }\n        if (HttpRequest.options?.responseMiddleware) {\n            result = await HttpRequest.options.responseMiddleware(result, this);\n        }\n        return result;\n    }\n    async queryJSON(router) {\n        let resultTemp = await this._query(router);\n        let result = new ResultWithError();\n        if (!resultTemp.success) {\n            result.errors = resultTemp.errors;\n            return result;\n        }\n        try {\n            if (!resultTemp.result) {\n                return result;\n            }\n            let tempResult = Converter.transform(await resultTemp.result.json());\n            if (tempResult instanceof VoidWithError) {\n                for (let error of tempResult.errors) {\n                    result.errors.push(error);\n                }\n                if (tempResult instanceof ResultWithError) {\n                    result.result = tempResult.result;\n                }\n            }\n            else {\n                result.result = tempResult;\n            }\n        }\n        catch (e) {\n            result.errors.push(new HttpError(HttpErrorCode.unknow, e));\n        }\n        if (HttpRequest.options?.responseMiddleware) {\n            result = await HttpRequest.options.responseMiddleware(result, this);\n        }\n        return result;\n    }\n    async queryTxt(router) {\n        let resultTemp = await this._query(router);\n        let result = new ResultWithError();\n        if (!resultTemp.success) {\n            result.errors = resultTemp.errors;\n            return result;\n        }\n        try {\n            if (!resultTemp.result) {\n                return result;\n            }\n            result.result = await resultTemp.result.text();\n        }\n        catch (e) {\n            result.errors.push(new HttpError(HttpErrorCode.unknow, e));\n        }\n        if (HttpRequest.options?.responseMiddleware) {\n            result = await HttpRequest.options.responseMiddleware(result, this);\n        }\n        return result;\n    }\n    async queryBlob(router) {\n        let resultTemp = await this._query(router);\n        let result = new ResultWithError();\n        if (!resultTemp.success) {\n            result.errors = resultTemp.errors;\n            return result;\n        }\n        try {\n            if (!resultTemp.result) {\n                return result;\n            }\n            result.result = await resultTemp.result.blob();\n        }\n        catch (e) {\n            result.errors.push(new HttpError(HttpErrorCode.unknow, e));\n        }\n        if (HttpRequest.options?.responseMiddleware) {\n            result = await HttpRequest.options.responseMiddleware(result, this);\n        }\n        return result;\n    }\n}\nHttpRequest.Namespace=`Aventus`;\r\n_.HttpRequest=HttpRequest;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.HttpRequestOptions","isStrong":true},{"fullName":"Aventus.HttpMethod","isStrong":false},{"fullName":"Aventus.DateConverter","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.HttpRouter","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"Aventus.HttpError","isStrong":false},{"fullName":"Aventus.HttpErrorCode","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.Converter","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Blob","isStrong":false}],"fullName":"Aventus.HttpRequest","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let StorableRoute=class StorableRoute extends HttpRoute {\n    async GetAll() {\n        const request = new HttpRequest(`/${this.StorableName()}`, HttpMethod.GET);\n        return await request.queryJSON(this.router);\n    }\n    async Create(body) {\n        const request = new HttpRequest(`/${this.StorableName()}`, HttpMethod.POST);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async GetById(id) {\n        const request = new HttpRequest(`/${this.StorableName()}/${id}`, HttpMethod.GET);\n        return await request.queryJSON(this.router);\n    }\n    async Update(id, body) {\n        const request = new HttpRequest(`/${this.StorableName()}/${id}`, HttpMethod.PUT);\n        request.setBody(body);\n        return await request.queryJSON(this.router);\n    }\n    async Delete(id) {\n        const request = new HttpRequest(`/${this.StorableName()}/${id}`, HttpMethod.DELETE);\n        return await request.queryJSON(this.router);\n    }\n}\nStorableRoute.Namespace=`Aventus`;\r\n_.StorableRoute=StorableRoute;\r\n","dependances":[{"fullName":"Aventus.HttpRoute","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"Aventus.HttpRequest","isStrong":false},{"fullName":"Aventus.HttpMethod","isStrong":false},{"fullName":"TypeResult","isStrong":false}],"fullName":"Aventus.StorableRoute","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Animation=class Animation {\n    /**\n     * Default FPS for all Animation if not set inside options\n     */\n    static FPS_DEFAULT = 60;\n    options;\n    nextFrame = 0;\n    fpsInterval;\n    continueAnimation = false;\n    frame_id = 0;\n    constructor(options) {\n        if (!options.animate) {\n            options.animate = () => { };\n        }\n        if (!options.stopped) {\n            options.stopped = () => { };\n        }\n        if (!options.fps) {\n            options.fps = Animation.FPS_DEFAULT;\n        }\n        this.options = options;\n        this.fpsInterval = 1000 / options.fps;\n    }\n    animate() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (elapsed <= this.fpsInterval) {\n            this.frame_id = requestAnimationFrame(() => this.animate());\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        setTimeout(() => {\n            this.options.animate();\n        }, 0);\n        if (this.continueAnimation) {\n            this.frame_id = requestAnimationFrame(() => this.animate());\n        }\n        else {\n            this.options.stopped();\n        }\n    }\n    /**\n     * Start the of animation\n     */\n    start() {\n        if (this.continueAnimation == false) {\n            this.continueAnimation = true;\n            this.nextFrame = window.performance.now();\n            this.animate();\n        }\n    }\n    /**\n     * Stop the animation\n     */\n    stop() {\n        this.continueAnimation = false;\n    }\n    /**\n     * Stop the animation\n     */\n    immediateStop() {\n        cancelAnimationFrame(this.frame_id);\n        this.continueAnimation = false;\n        this.options.stopped();\n    }\n    /**\n     * Get the FPS\n     */\n    getFPS() {\n        return this.options.fps;\n    }\n    /**\n     * Set the FPS\n     */\n    setFPS(fps) {\n        this.options.fps = fps;\n        this.fpsInterval = 1000 / this.options.fps;\n    }\n    /**\n     * Get the animation status (true if animation is running)\n     */\n    isStarted() {\n        return this.continueAnimation;\n    }\n}\nAnimation.Namespace=`Aventus`;\r\n_.Animation=Animation;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.AnimationOptionsInternal","isStrong":false},{"fullName":"Aventus.AnimationOptions","isStrong":false}],"fullName":"Aventus.Animation","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let PressManager=class PressManager {\n    static globalConfig = {\n        delayDblPress: 250,\n        delayLongPress: 700,\n        offsetDrag: 20\n    };\n    static configure(options) {\n        this.globalConfig = options;\n    }\n    static create(options) {\n        if (Array.isArray(options.element)) {\n            let result = [];\n            for (let el of options.element) {\n                let cloneOpt = { ...options };\n                cloneOpt.element = el;\n                result.push(new PressManager(cloneOpt));\n            }\n            return result;\n        }\n        else {\n            return new PressManager(options);\n        }\n    }\n    static onEvent = new Callback();\n    options;\n    element;\n    delayDblPress;\n    delayLongPress;\n    nbPress = 0;\n    offsetDrag;\n    dragDirection;\n    state = {\n        oneActionTriggered: null,\n    };\n    startPosition = { x: 0, y: 0 };\n    customFcts = {};\n    timeoutDblPress = 0;\n    timeoutLongPress = 0;\n    downEventSaved;\n    useDblPress = false;\n    stopPropagation = () => true;\n    pointersRecord = {};\n    functionsBinded = {\n        downAction: (e) => { },\n        downActionDelay: (e) => { },\n        upAction: (e) => { },\n        moveAction: (e) => { },\n        childPressStart: (e) => { },\n        childPressEnd: (e) => { },\n        childPressMove: (e) => { }\n    };\n    /**\n     * @param {*} options - The options\n     * @param {HTMLElement | HTMLElement[]} options.element - The element to manage\n     */\n    constructor(options) {\n        if (options.element === void 0) {\n            throw 'You must provide an element';\n        }\n        this.offsetDrag = PressManager.globalConfig.offsetDrag !== undefined ? PressManager.globalConfig.offsetDrag : 20;\n        this.dragDirection = 'XY';\n        this.delayLongPress = PressManager.globalConfig.delayLongPress ?? 700;\n        this.delayDblPress = PressManager.globalConfig.delayDblPress ?? 150;\n        this.element = options.element;\n        this.checkDragConstraint(options);\n        this.assignValueOption(options);\n        this.options = options;\n        this.init();\n    }\n    /**\n     * Get the current element focused by the PressManager\n     */\n    getElement() {\n        return this.element;\n    }\n    checkDragConstraint(options) {\n        if (options.onDrag !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragStart !== void 0) {\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n            if (options.onDragEnd === void 0) {\n                options.onDragEnd = (e) => { };\n            }\n        }\n        if (options.onDragEnd !== void 0) {\n            if (options.onDragStart === void 0) {\n                options.onDragStart = (e) => { };\n            }\n            if (options.onDrag === void 0) {\n                options.onDrag = (e) => { };\n            }\n        }\n    }\n    assignValueOption(options) {\n        if (PressManager.globalConfig.delayDblPress !== undefined) {\n            this.delayDblPress = PressManager.globalConfig.delayDblPress;\n        }\n        if (options.delayDblPress !== undefined) {\n            this.delayDblPress = options.delayDblPress;\n        }\n        if (PressManager.globalConfig.delayLongPress !== undefined) {\n            this.delayLongPress = PressManager.globalConfig.delayLongPress;\n        }\n        if (options.delayLongPress !== undefined) {\n            this.delayLongPress = options.delayLongPress;\n        }\n        if (PressManager.globalConfig.offsetDrag !== undefined) {\n            this.offsetDrag = PressManager.globalConfig.offsetDrag;\n        }\n        if (options.offsetDrag !== undefined) {\n            this.offsetDrag = options.offsetDrag;\n        }\n        if (options.dragDirection !== undefined) {\n            this.dragDirection = options.dragDirection;\n        }\n        if (options.onDblPress !== undefined) {\n            this.useDblPress = true;\n        }\n        if (PressManager.globalConfig.forceDblPress !== undefined) {\n            this.useDblPress = PressManager.globalConfig.forceDblPress;\n        }\n        if (options.forceDblPress !== undefined) {\n            this.useDblPress = options.forceDblPress;\n        }\n        if (typeof PressManager.globalConfig.stopPropagation == 'function') {\n            this.stopPropagation = PressManager.globalConfig.stopPropagation;\n        }\n        else if (options.stopPropagation === false) {\n            this.stopPropagation = () => false;\n        }\n        if (typeof options.stopPropagation == 'function') {\n            this.stopPropagation = options.stopPropagation;\n        }\n        else if (options.stopPropagation === false) {\n            this.stopPropagation = () => false;\n        }\n        if (!options.buttonAllowed)\n            options.buttonAllowed = PressManager.globalConfig.buttonAllowed;\n        if (!options.buttonAllowed)\n            options.buttonAllowed = [0];\n        if (!options.onEvent)\n            options.onEvent = PressManager.globalConfig.onEvent;\n    }\n    bindAllFunction() {\n        this.functionsBinded.downAction = this.downAction.bind(this);\n        this.functionsBinded.downActionDelay = this.downActionDelay.bind(this);\n        this.functionsBinded.moveAction = this.moveAction.bind(this);\n        this.functionsBinded.upAction = this.upAction.bind(this);\n        this.functionsBinded.childPressStart = this.childPressStart.bind(this);\n        this.functionsBinded.childPressEnd = this.childPressEnd.bind(this);\n        this.functionsBinded.childPressMove = this.childPressMove.bind(this);\n    }\n    init() {\n        this.bindAllFunction();\n        this.element.addEventListener(\"pointerdown\", this.functionsBinded.downAction);\n        this.element.addEventListener(\"touchstart\", this.functionsBinded.downActionDelay);\n        this.element.addEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n        this.element.addEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n        this.element.addEventListener(\"trigger_pointer_pressmove\", this.functionsBinded.childPressMove);\n    }\n    identifyEvent(touch) {\n        if ('Touch' in window && touch instanceof Touch)\n            return touch.identifier;\n        return touch.pointerId;\n    }\n    registerEvent(ev) {\n        if ('TouchEvent' in window && ev instanceof TouchEvent) {\n            for (let touch of ev.targetTouches) {\n                const id = this.identifyEvent(touch);\n                if (this.pointersRecord[id]) {\n                    return false;\n                }\n                this.pointersRecord[id] = ev;\n            }\n            return true;\n        }\n        else {\n            const id = this.identifyEvent(ev);\n            if (this.pointersRecord[id]) {\n                return false;\n            }\n            this.pointersRecord[id] = ev;\n            return true;\n        }\n    }\n    unregisterEvent(ev) {\n        let result = true;\n        if ('TouchEvent' in window && ev instanceof TouchEvent) {\n            for (let touch of ev.changedTouches) {\n                const id = this.identifyEvent(touch);\n                if (!this.pointersRecord[id]) {\n                    result = false;\n                }\n                else {\n                    delete this.pointersRecord[id];\n                }\n            }\n        }\n        else {\n            const id = this.identifyEvent(ev);\n            if (!this.pointersRecord[id]) {\n                result = false;\n            }\n            else {\n                delete this.pointersRecord[id];\n            }\n        }\n        return result;\n    }\n    genericDownAction(state, e) {\n        this.downEventSaved = e;\n        this.startPosition = { x: e.pageX, y: e.pageY };\n        if (this.options.onLongPress) {\n            this.timeoutLongPress = setTimeout(() => {\n                if (!state.oneActionTriggered) {\n                    if (this.options.onLongPress) {\n                        if (this.options.onLongPress(e, this) !== false) {\n                            state.oneActionTriggered = this;\n                        }\n                    }\n                }\n            }, this.delayLongPress);\n        }\n    }\n    pointerEventTriggered = false;\n    downActionDelay(ev) {\n        if (!this.pointerEventTriggered) {\n            this.downAction(ev);\n        }\n        else {\n            ev.stopImmediatePropagation();\n        }\n        setTimeout(() => {\n            this.pointerEventTriggered = false;\n        }, 0);\n    }\n    downAction(ev) {\n        this.pointerEventTriggered = true;\n        const isFirst = Object.values(this.pointersRecord).length == 0;\n        if (!this.registerEvent(ev)) {\n            if (this.stopPropagation()) {\n                ev.stopImmediatePropagation();\n            }\n            return;\n        }\n        const e = new NormalizedEvent(ev);\n        if (this.options.onEvent) {\n            this.options.onEvent(e);\n        }\n        PressManager.onEvent.trigger(e, this);\n        if (e.button != undefined && !this.options.buttonAllowed?.includes(e.button)) {\n            this.unregisterEvent(ev);\n            return;\n        }\n        if (this.stopPropagation()) {\n            e.stopImmediatePropagation();\n        }\n        this.customFcts = {};\n        if (this.nbPress == 0 && isFirst) {\n            this.state.oneActionTriggered = null;\n            clearTimeout(this.timeoutDblPress);\n        }\n        if (isFirst) {\n            document.addEventListener(\"pointerup\", this.functionsBinded.upAction);\n            document.addEventListener(\"pointercancel\", this.functionsBinded.upAction);\n            document.addEventListener(\"touchend\", this.functionsBinded.upAction);\n            document.addEventListener(\"touchcancel\", this.functionsBinded.upAction);\n            document.addEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        }\n        this.genericDownAction(this.state, e);\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e, this);\n            this.lastEmitEvent = e;\n            // this.emitTriggerFunctionParent(\"pressstart\", e);\n        }\n        this.emitTriggerFunction(\"pressstart\", e);\n    }\n    genericUpAction(state, e) {\n        clearTimeout(this.timeoutLongPress);\n        if (state.oneActionTriggered == this) {\n            if (this.options.onDragEnd) {\n                this.options.onDragEnd(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDragEnd) {\n                this.customFcts.onDragEnd(e, this.customFcts.src);\n            }\n        }\n        else {\n            if (this.useDblPress) {\n                this.nbPress++;\n                if (this.nbPress == 2) {\n                    if (!state.oneActionTriggered) {\n                        this.nbPress = 0;\n                        if (this.options.onDblPress) {\n                            if (this.options.onDblPress(e, this) !== false) {\n                                state.oneActionTriggered = this;\n                            }\n                        }\n                    }\n                }\n                else if (this.nbPress == 1) {\n                    this.timeoutDblPress = setTimeout(() => {\n                        this.nbPress = 0;\n                        if (!state.oneActionTriggered) {\n                            if (this.options.onPress) {\n                                if (this.options.onPress(e, this) !== false) {\n                                    state.oneActionTriggered = this;\n                                }\n                            }\n                        }\n                    }, this.delayDblPress);\n                }\n            }\n            else {\n                if (!state.oneActionTriggered) {\n                    if (this.options.onPress) {\n                        if (this.options.onPress(e, this) !== false) {\n                            state.oneActionTriggered = this;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    upAction(ev) {\n        if (!this.unregisterEvent(ev)) {\n            if (this.stopPropagation()) {\n                ev.stopImmediatePropagation();\n            }\n            return;\n        }\n        const e = new NormalizedEvent(ev);\n        if (this.options.onEvent) {\n            this.options.onEvent(e);\n        }\n        PressManager.onEvent.trigger(e, this);\n        if (this.stopPropagation()) {\n            e.stopImmediatePropagation();\n        }\n        if (Object.values(this.pointersRecord).length == 0) {\n            document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n            document.removeEventListener(\"pointercancel\", this.functionsBinded.upAction);\n            document.removeEventListener(\"touchend\", this.functionsBinded.upAction);\n            document.removeEventListener(\"touchcancel\", this.functionsBinded.upAction);\n            document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        }\n        this.genericUpAction(this.state, e);\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e, this);\n            this.lastEmitEvent = e;\n            // this.emitTriggerFunctionParent(\"pressend\", e);\n        }\n        this.emitTriggerFunction(\"pressend\", e);\n    }\n    genericMoveAction(state, e) {\n        if (!state.oneActionTriggered) {\n            let xDist = e.pageX - this.startPosition.x;\n            let yDist = e.pageY - this.startPosition.y;\n            let distance = 0;\n            if (this.dragDirection == 'XY')\n                distance = Math.sqrt(xDist * xDist + yDist * yDist);\n            else if (this.dragDirection == 'X')\n                distance = Math.abs(xDist);\n            else\n                distance = Math.abs(yDist);\n            if (distance > this.offsetDrag && this.downEventSaved) {\n                if (this.options.onDragStart) {\n                    if (this.options.onDragStart(this.downEventSaved, this) !== false) {\n                        state.oneActionTriggered = this;\n                    }\n                }\n            }\n        }\n        else if (state.oneActionTriggered == this) {\n            if (this.options.onDrag) {\n                this.options.onDrag(e, this);\n            }\n            else if (this.customFcts.src && this.customFcts.onDrag) {\n                this.customFcts.onDrag(e, this.customFcts.src);\n            }\n        }\n    }\n    moveAction(ev) {\n        const e = new NormalizedEvent(ev);\n        if (this.options.onEvent) {\n            this.options.onEvent(e);\n        }\n        PressManager.onEvent.trigger(e, this);\n        if (this.stopPropagation()) {\n            e.stopImmediatePropagation();\n        }\n        this.genericMoveAction(this.state, e);\n        this.lastEmitEvent = e;\n        // if(this.options.onDrag) {\n        //     this.emitTriggerFunctionParent(\"pressmove\", e);\n        this.emitTriggerFunction(\"pressmove\", e);\n    }\n    childPressStart(e) {\n        if (this.lastEmitEvent == e.detail.realEvent)\n            return;\n        this.genericDownAction(e.detail.state, e.detail.realEvent);\n        if (this.options.onPressStart) {\n            this.options.onPressStart(e.detail.realEvent, this);\n        }\n    }\n    childPressEnd(e) {\n        this.unregisterEvent(e.detail.realEvent.event);\n        if (Object.values(this.pointersRecord).length == 0) {\n            document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n            document.removeEventListener(\"pointercancel\", this.functionsBinded.upAction);\n            document.removeEventListener(\"touchend\", this.functionsBinded.upAction);\n            document.removeEventListener(\"touchcancel\", this.functionsBinded.upAction);\n            document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        }\n        if (this.lastEmitEvent == e.detail.realEvent)\n            return;\n        this.genericUpAction(e.detail.state, e.detail.realEvent);\n        if (this.options.onPressEnd) {\n            this.options.onPressEnd(e.detail.realEvent, this);\n        }\n    }\n    childPressMove(e) {\n        if (this.lastEmitEvent == e.detail.realEvent)\n            return;\n        this.genericMoveAction(e.detail.state, e.detail.realEvent);\n    }\n    lastEmitEvent;\n    emitTriggerFunction(action, e, el) {\n        let ev = new CustomEvent(\"trigger_pointer_\" + action, {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n            detail: {\n                state: this.state,\n                customFcts: this.customFcts,\n                realEvent: e\n            }\n        });\n        this.lastEmitEvent = e;\n        if (!el) {\n            el = this.element;\n        }\n        el.dispatchEvent(ev);\n    }\n    /**\n     * Destroy the Press instance byremoving all events\n     */\n    destroy() {\n        if (this.element) {\n            this.element.removeEventListener(\"pointerdown\", this.functionsBinded.downAction);\n            this.element.removeEventListener(\"touchstart\", this.functionsBinded.downActionDelay);\n            this.element.removeEventListener(\"trigger_pointer_pressstart\", this.functionsBinded.childPressStart);\n            this.element.removeEventListener(\"trigger_pointer_pressend\", this.functionsBinded.childPressEnd);\n            this.element.removeEventListener(\"trigger_pointer_pressmove\", this.functionsBinded.childPressMove);\n            document.removeEventListener(\"pointerup\", this.functionsBinded.upAction);\n            document.removeEventListener(\"pointercancel\", this.functionsBinded.upAction);\n            document.removeEventListener(\"touchend\", this.functionsBinded.upAction);\n            document.removeEventListener(\"touchcancel\", this.functionsBinded.upAction);\n            document.removeEventListener(\"pointermove\", this.functionsBinded.moveAction);\n        }\n    }\n}\nPressManager.Namespace=`Aventus`;\r\n_.PressManager=PressManager;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Partial","isStrong":true},{"fullName":"Aventus.PressManagerOptions","isStrong":true},{"fullName":"Aventus.Callback","isStrong":true},{"fullName":"Aventus.NormalizedEvent","isStrong":true},{"fullName":"Aventus.PressManagerState","isStrong":false},{"fullName":"Aventus.InternalCustomFunction","isStrong":false},{"fullName":"Aventus.InternalPointerEvent","isStrong":false},{"fullName":"Touch","isStrong":false}],"fullName":"Aventus.PressManager","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let DragAndDrop=class DragAndDrop {\n    /**\n     * Default offset before drag element\n     */\n    static defaultOffsetDrag = 20;\n    pressManager;\n    options;\n    startCursorPosition = { x: 0, y: 0 };\n    startElementPosition = { x: 0, y: 0 };\n    isEnable = true;\n    draggableElement;\n    constructor(options) {\n        this.options = this.getDefaultOptions(options.element);\n        this.mergeProperties(options);\n        this.mergeFunctions(options);\n        this.options.elementTrigger.style.touchAction = 'none';\n        this.pressManager = new PressManager({\n            element: this.options.elementTrigger,\n            onPressStart: this.onPressStart.bind(this),\n            onPressEnd: this.onPressEnd.bind(this),\n            onDragStart: this.onDragStart.bind(this),\n            onDrag: this.onDrag.bind(this),\n            onDragEnd: this.onDragEnd.bind(this),\n            offsetDrag: this.options.offsetDrag,\n            dragDirection: this.options.dragDirection,\n            stopPropagation: this.options.stopPropagation\n        });\n    }\n    getDefaultOptions(element) {\n        return {\n            applyDrag: true,\n            element: element,\n            elementTrigger: element,\n            offsetDrag: DragAndDrop.defaultOffsetDrag,\n            dragDirection: 'XY',\n            shadow: {\n                enable: false,\n                container: document.body,\n                removeOnStop: true,\n                transform: () => { },\n                delete: (el) => {\n                    el.remove();\n                }\n            },\n            strict: false,\n            targets: [],\n            usePercent: false,\n            stopPropagation: true,\n            useMouseFinalPosition: false,\n            useTransform: false,\n            isDragEnable: () => true,\n            getZoom: () => 1,\n            getOffsetX: () => 0,\n            getOffsetY: () => 0,\n            onPointerDown: (e) => { },\n            onPointerUp: (e) => { },\n            onStart: (e) => { },\n            onMove: (e) => { },\n            onStop: (e) => { },\n            onDrop: (element, targets) => { },\n            correctPosition: (position) => position\n        };\n    }\n    mergeProperties(options) {\n        if (options.element === void 0) {\n            throw \"You must define the element for the drag&drop\";\n        }\n        this.options.element = options.element;\n        if (options.elementTrigger === void 0) {\n            this.options.elementTrigger = this.options.element;\n        }\n        else {\n            this.options.elementTrigger = options.elementTrigger;\n        }\n        this.defaultMerge(options, \"applyDrag\");\n        this.defaultMerge(options, \"offsetDrag\");\n        this.defaultMerge(options, \"dragDirection\");\n        this.defaultMerge(options, \"strict\");\n        this.defaultMerge(options, \"targets\");\n        this.defaultMerge(options, \"usePercent\");\n        this.defaultMerge(options, \"stopPropagation\");\n        this.defaultMerge(options, \"useMouseFinalPosition\");\n        this.defaultMerge(options, \"useTransform\");\n        if (options.shadow !== void 0) {\n            this.options.shadow.enable = options.shadow.enable;\n            if (options.shadow.container !== void 0) {\n                this.options.shadow.container = options.shadow.container;\n            }\n            else {\n                this.options.shadow.container = document.body;\n            }\n            if (options.shadow.removeOnStop !== void 0) {\n                this.options.shadow.removeOnStop = options.shadow.removeOnStop;\n            }\n            if (options.shadow.transform !== void 0) {\n                this.options.shadow.transform = options.shadow.transform;\n            }\n            if (options.shadow.delete !== void 0) {\n                this.options.shadow.delete = options.shadow.delete;\n            }\n        }\n    }\n    mergeFunctions(options) {\n        this.defaultMerge(options, \"isDragEnable\");\n        this.defaultMerge(options, \"getZoom\");\n        this.defaultMerge(options, \"getOffsetX\");\n        this.defaultMerge(options, \"getOffsetY\");\n        this.defaultMerge(options, \"onPointerDown\");\n        this.defaultMerge(options, \"onPointerUp\");\n        this.defaultMerge(options, \"onStart\");\n        this.defaultMerge(options, \"onMove\");\n        this.defaultMerge(options, \"onStop\");\n        this.defaultMerge(options, \"onDrop\");\n        this.defaultMerge(options, \"correctPosition\");\n    }\n    defaultMerge(options, name) {\n        if (options[name] !== void 0) {\n            this.options[name] = options[name];\n        }\n    }\n    positionShadowRelativeToElement = { x: 0, y: 0 };\n    onPressStart(e) {\n        this.options.onPointerDown(e);\n    }\n    onPressEnd(e) {\n        this.options.onPointerUp(e);\n    }\n    onDragStart(e) {\n        this.isEnable = this.options.isDragEnable();\n        if (!this.isEnable) {\n            return false;\n        }\n        let draggableElement = this.options.element;\n        this.startCursorPosition = {\n            x: e.pageX,\n            y: e.pageY\n        };\n        this.startElementPosition = this.getBoundingBoxRelative(draggableElement);\n        if (this.options.shadow.enable) {\n            draggableElement = this.options.element.cloneNode(true);\n            let elBox = this.options.element.getBoundingClientRect();\n            let containerBox = this.options.shadow.container.getBoundingClientRect();\n            this.positionShadowRelativeToElement = {\n                x: elBox.x - containerBox.x,\n                y: elBox.y - containerBox.y\n            };\n            if (this.options.applyDrag) {\n                draggableElement.style.position = \"absolute\";\n                draggableElement.style.top = this.positionShadowRelativeToElement.y + this.options.getOffsetY() + 'px';\n                draggableElement.style.left = this.positionShadowRelativeToElement.x + this.options.getOffsetX() + 'px';\n                this.options.shadow.transform(draggableElement);\n                this.options.shadow.container.appendChild(draggableElement);\n            }\n        }\n        this.draggableElement = draggableElement;\n        return this.options.onStart(e);\n    }\n    onDrag(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let zoom = this.options.getZoom();\n        let diff = {\n            x: 0,\n            y: 0\n        };\n        if (this.options.shadow.enable) {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) + this.positionShadowRelativeToElement.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) + this.positionShadowRelativeToElement.y + this.options.getOffsetY(),\n            };\n        }\n        else {\n            diff = {\n                x: (e.pageX - this.startCursorPosition.x) / zoom + this.startElementPosition.x + this.options.getOffsetX(),\n                y: (e.pageY - this.startCursorPosition.y) / zoom + this.startElementPosition.y + this.options.getOffsetY()\n            };\n        }\n        let newPos = this.setPosition(diff);\n        this.options.onMove(e, newPos);\n    }\n    onDragEnd(e) {\n        if (!this.isEnable) {\n            return;\n        }\n        let targets = this.options.useMouseFinalPosition ? this.getMatchingTargetsWithMousePosition({\n            x: e.clientX,\n            y: e.clientY\n        }) : this.getMatchingTargets();\n        let draggableElement = this.draggableElement;\n        if (this.options.shadow.enable && this.options.shadow.removeOnStop) {\n            this.options.shadow.delete(draggableElement);\n        }\n        if (targets.length > 0) {\n            this.options.onDrop(this.options.element, targets);\n        }\n        this.options.onStop(e);\n    }\n    setPosition(position) {\n        let draggableElement = this.draggableElement;\n        if (this.options.usePercent) {\n            let elementParent = this.getOffsetParent(draggableElement);\n            if (elementParent instanceof HTMLElement) {\n                let percentPosition = {\n                    x: (position.x / elementParent.offsetWidth) * 100,\n                    y: (position.y / elementParent.offsetHeight) * 100\n                };\n                percentPosition = this.options.correctPosition(percentPosition);\n                if (this.options.applyDrag) {\n                    draggableElement.style.left = percentPosition.x + '%';\n                    draggableElement.style.top = percentPosition.y + '%';\n                }\n                return percentPosition;\n            }\n            else {\n                console.error(\"Can't find parent. Contact an admin\", draggableElement);\n            }\n        }\n        else {\n            position = this.options.correctPosition(position);\n            if (this.options.applyDrag) {\n                if (this.isLeftTopElement(draggableElement)) {\n                    draggableElement.style.left = position.x + 'px';\n                    draggableElement.style.top = position.y + 'px';\n                }\n                else {\n                    if (this.options.useTransform) {\n                        draggableElement.setAttribute(\"transform\", `translate(${position.x},${position.y})`);\n                    }\n                    else {\n                        draggableElement.style.left = position.x + 'px';\n                        draggableElement.style.top = position.y + 'px';\n                    }\n                }\n            }\n        }\n        return position;\n    }\n    getTargets() {\n        if (typeof this.options.targets == \"function\") {\n            return this.options.targets();\n        }\n        else {\n            return this.options.targets;\n        }\n    }\n    /**\n     * Get targets within the current element position is matching\n     */\n    getMatchingTargets() {\n        let draggableElement = this.draggableElement;\n        let matchingTargets = [];\n        let srcTargets = this.getTargets();\n        for (let target of srcTargets) {\n            let elementCoordinates = this.getBoundingBoxAbsolute(draggableElement);\n            let targetCoordinates = this.getBoundingBoxAbsolute(target);\n            let offsetX = this.options.getOffsetX();\n            let offsetY = this.options.getOffsetY();\n            let zoom = this.options.getZoom();\n            targetCoordinates.x += offsetX;\n            targetCoordinates.y += offsetY;\n            targetCoordinates.width *= zoom;\n            targetCoordinates.height *= zoom;\n            if (this.options.strict) {\n                if ((elementCoordinates.x >= targetCoordinates.x && elementCoordinates.x + elementCoordinates.width <= targetCoordinates.x + targetCoordinates.width) &&\n                    (elementCoordinates.y >= targetCoordinates.y && elementCoordinates.y + elementCoordinates.height <= targetCoordinates.y + targetCoordinates.height)) {\n                    matchingTargets.push(target);\n                }\n            }\n            else {\n                let elementLeft = elementCoordinates.x;\n                let elementRight = elementCoordinates.x + elementCoordinates.width;\n                let elementTop = elementCoordinates.y;\n                let elementBottom = elementCoordinates.y + elementCoordinates.height;\n                let targetLeft = targetCoordinates.x;\n                let targetRight = targetCoordinates.x + targetCoordinates.width;\n                let targetTop = targetCoordinates.y;\n                let targetBottom = targetCoordinates.y + targetCoordinates.height;\n                if (!(elementRight < targetLeft ||\n                    elementLeft > targetRight ||\n                    elementBottom < targetTop ||\n                    elementTop > targetBottom)) {\n                    matchingTargets.push(target);\n                }\n            }\n        }\n        return matchingTargets;\n    }\n    /**\n     * This function will return the targets that are matching with the mouse position\n     * @param mouse The mouse position\n     */\n    getMatchingTargetsWithMousePosition(mouse) {\n        let matchingTargets = [];\n        if (this.options.shadow.enable == false || this.options.shadow.container == null) {\n            console.warn(\"DragAndDrop : To use useMouseFinalPosition=true, you must enable shadow and set a container\");\n            return matchingTargets;\n        }\n        const container = this.options.shadow.container;\n        let xCorrected = mouse.x - container.getBoundingClientRect().left;\n        let yCorrected = mouse.y - container.getBoundingClientRect().top;\n        for (let target of this.getTargets()) {\n            if (this.isLeftTopElement(target)) {\n                if (this.matchPosition(target, { x: mouse.x, y: mouse.y })) {\n                    matchingTargets.push(target);\n                }\n            }\n            else {\n                if (this.matchPosition(target, { x: xCorrected, y: yCorrected })) {\n                    matchingTargets.push(target);\n                }\n            }\n        }\n        return matchingTargets;\n    }\n    matchPosition(element, point) {\n        let elementCoordinates = this.getBoundingBoxAbsolute(element);\n        if (point.x >= elementCoordinates.x &&\n            point.x <= elementCoordinates.x + elementCoordinates.width &&\n            point.y >= elementCoordinates.y &&\n            point.y <= elementCoordinates.y + elementCoordinates.height) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get element currently dragging\n     */\n    getElementDrag() {\n        return this.options.element;\n    }\n    /**\n     * Set targets where to drop\n     */\n    setTargets(targets) {\n        this.options.targets = targets;\n    }\n    /**\n     * Set targets where to drop\n     */\n    setTargetsFct(targets) {\n        this.options.targets = targets;\n    }\n    /**\n     * Destroy the current drag&drop instance\n     */\n    destroy() {\n        this.pressManager.destroy();\n    }\n    isLeftTopElement(element) {\n        for (let Type of DragElementLeftTopType) {\n            if (element instanceof Type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isXYElement(element) {\n        for (let Type of DragElementXYType) {\n            if (element instanceof Type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getCoordinateFromAttribute(element) {\n        if (this.options.useTransform) {\n            const transform = element.getAttribute(\"transform\");\n            const tvalue = transform?.match(/translate\\(([^,]+),([^,]+)\\)/);\n            const x = tvalue ? parseFloat(tvalue[1]) : 0;\n            const y = tvalue ? parseFloat(tvalue[2]) : 0;\n            return {\n                x: x,\n                y: y\n            };\n        }\n        return {\n            x: parseFloat(element.getAttribute(\"x\")),\n            y: parseFloat(element.getAttribute(\"y\"))\n        };\n    }\n    XYElementToRelativeBox(element) {\n        let coordinates = this.getCoordinateFromAttribute(element);\n        const width = parseFloat(element.getAttribute(\"width\"));\n        const height = parseFloat(element.getAttribute(\"height\"));\n        return {\n            x: coordinates.x,\n            y: coordinates.y,\n            width: width,\n            height: height,\n            bottom: coordinates.y + height,\n            right: coordinates.x + width,\n            top: coordinates.y,\n            left: coordinates.x,\n            toJSON() {\n                return JSON.stringify(this);\n            }\n        };\n    }\n    XYElementToAbsoluteBox(element) {\n        let coordinates = this.getCoordinateFromAttribute(element);\n        const parent = this.getOffsetParent(element);\n        if (parent) {\n            const box = parent.getBoundingClientRect();\n            coordinates = {\n                x: coordinates.x + box.x,\n                y: coordinates.y + box.y\n            };\n        }\n        const width = parseFloat(element.getAttribute(\"width\"));\n        const height = parseFloat(element.getAttribute(\"height\"));\n        return {\n            x: coordinates.x,\n            y: coordinates.y,\n            width: width,\n            height: height,\n            bottom: coordinates.y + height,\n            right: coordinates.x + width,\n            top: coordinates.y,\n            left: coordinates.x,\n            toJSON() {\n                return JSON.stringify(this);\n            }\n        };\n    }\n    getBoundingBoxAbsolute(element) {\n        if (this.isLeftTopElement(element)) {\n            if (element instanceof HTMLElement) {\n                const bounds = element.getBoundingClientRect();\n                return {\n                    x: bounds.x,\n                    y: bounds.y,\n                    width: bounds.width,\n                    height: bounds.height,\n                    bottom: bounds.bottom,\n                    right: bounds.right,\n                    top: bounds.top,\n                    left: bounds.left,\n                    toJSON() {\n                        return JSON.stringify(this);\n                    }\n                };\n            }\n        }\n        else if (this.isXYElement(element)) {\n            return this.XYElementToAbsoluteBox(element);\n        }\n        const parent = this.getOffsetParent(element);\n        if (parent instanceof HTMLElement) {\n            const rect = element.getBoundingClientRect();\n            const rectParent = parent.getBoundingClientRect();\n            const x = rect.left - rectParent.left;\n            const y = rect.top - rectParent.top;\n            return {\n                x: x,\n                y: y,\n                width: rect.width,\n                height: rect.height,\n                bottom: y + rect.height,\n                right: x + rect.width,\n                left: rect.left - rectParent.left,\n                top: rect.top - rectParent.top,\n                toJSON() {\n                    return JSON.stringify(this);\n                }\n            };\n        }\n        console.error(\"Element type not supported\");\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            bottom: 0,\n            right: 0,\n            top: 0,\n            left: 0,\n            toJSON() {\n                return JSON.stringify(this);\n            }\n        };\n    }\n    getBoundingBoxRelative(element) {\n        if (this.isLeftTopElement(element)) {\n            if (element instanceof HTMLElement) {\n                return {\n                    x: element.offsetLeft,\n                    y: element.offsetTop,\n                    width: element.offsetWidth,\n                    height: element.offsetHeight,\n                    bottom: element.offsetTop + element.offsetHeight,\n                    right: element.offsetLeft + element.offsetWidth,\n                    top: element.offsetTop,\n                    left: element.offsetLeft,\n                    toJSON() {\n                        return JSON.stringify(this);\n                    }\n                };\n            }\n        }\n        else if (this.isXYElement(element)) {\n            return this.XYElementToRelativeBox(element);\n        }\n        const parent = this.getOffsetParent(element);\n        if (parent instanceof HTMLElement) {\n            const rect = element.getBoundingClientRect();\n            const rectParent = parent.getBoundingClientRect();\n            const x = rect.left - rectParent.left;\n            const y = rect.top - rectParent.top;\n            return {\n                x: x,\n                y: y,\n                width: rect.width,\n                height: rect.height,\n                bottom: y + rect.height,\n                right: x + rect.width,\n                left: rect.left - rectParent.left,\n                top: rect.top - rectParent.top,\n                toJSON() {\n                    return JSON.stringify(this);\n                }\n            };\n        }\n        console.error(\"Element type not supported\");\n        return {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            bottom: 0,\n            right: 0,\n            top: 0,\n            left: 0,\n            toJSON() {\n                return JSON.stringify(this);\n            }\n        };\n    }\n    getOffsetParent(element) {\n        if (element instanceof HTMLElement) {\n            return element.offsetParent;\n        }\n        let current = element.parentNode;\n        while (current) {\n            if (current instanceof Element) {\n                const style = getComputedStyle(current);\n                if (style.position !== 'static') {\n                    return current;\n                }\n            }\n            if (current instanceof ShadowRoot) {\n                current = current.host;\n            }\n            else {\n                current = current.parentNode;\n            }\n        }\n        return null;\n    }\n}\nDragAndDrop.Namespace=`Aventus`;\r\n_.DragAndDrop=DragAndDrop;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.DragAndDropOptionsInternal","isStrong":false},{"fullName":"Aventus.Coordinate","isStrong":false},{"fullName":"Aventus.DragElement","isStrong":false},{"fullName":"Aventus.DragAndDropOptions","isStrong":false},{"fullName":"Aventus.NormalizedEvent","isStrong":false},{"fullName":"Aventus.TargetableElement","isStrong":false},{"fullName":"DOMRect","isStrong":false},{"fullName":"Aventus.DragElementLeftTop","isStrong":false},{"fullName":"Aventus.DragElementLeftTopType","isStrong":false},{"fullName":"Aventus.DragElementXY","isStrong":false},{"fullName":"Aventus.DragElementXYType","isStrong":false},{"fullName":"Aventus.AnyElement","isStrong":false},{"fullName":"ShadowRoot","isStrong":false}],"fullName":"Aventus.DragAndDrop","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ResizeObserver=class ResizeObserver {\n    callback;\n    targets;\n    fpsInterval = -1;\n    nextFrame;\n    entriesChangedEvent;\n    willTrigger;\n    static resizeObserverClassByObject = {};\n    static uniqueInstance;\n    static getUniqueInstance() {\n        if (!ResizeObserver.uniqueInstance) {\n            ResizeObserver.uniqueInstance = new window.ResizeObserver(entries => {\n                let allClasses = [];\n                for (let j = 0; j < entries.length; j++) {\n                    let entry = entries[j];\n                    let index = entry.target['sourceIndex'];\n                    if (ResizeObserver.resizeObserverClassByObject[index]) {\n                        for (let i = 0; i < ResizeObserver.resizeObserverClassByObject[index].length; i++) {\n                            let classTemp = ResizeObserver.resizeObserverClassByObject[index][i];\n                            classTemp.entryChanged(entry);\n                            if (allClasses.indexOf(classTemp) == -1) {\n                                allClasses.push(classTemp);\n                            }\n                        }\n                    }\n                }\n                for (let i = 0; i < allClasses.length; i++) {\n                    allClasses[i].triggerCb();\n                }\n            });\n        }\n        return ResizeObserver.uniqueInstance;\n    }\n    constructor(options) {\n        let realOption;\n        if (options instanceof Function) {\n            realOption = {\n                callback: options,\n            };\n        }\n        else {\n            realOption = options;\n        }\n        this.callback = realOption.callback;\n        this.targets = [];\n        if (!realOption.fps) {\n            realOption.fps = 60;\n        }\n        if (realOption.fps != -1) {\n            this.fpsInterval = 1000 / realOption.fps;\n        }\n        this.nextFrame = 0;\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n    }\n    /**\n     * Observe size changing for the element\n     */\n    observe(target) {\n        if (!target[\"sourceIndex\"]) {\n            target[\"sourceIndex\"] = Math.random().toString(36);\n            this.targets.push(target);\n            ResizeObserver.getUniqueInstance().observe(target);\n        }\n        if (!ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]]) {\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]] = [];\n        }\n        if (ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].indexOf(this) == -1) {\n            ResizeObserver.resizeObserverClassByObject[target[\"sourceIndex\"]].push(this);\n        }\n    }\n    /**\n     * Stop observing size changing for the element\n     */\n    unobserve(target) {\n        for (let i = 0; this.targets.length; i++) {\n            let tempTarget = this.targets[i];\n            if (tempTarget == target) {\n                let position = ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].indexOf(this);\n                if (position != -1) {\n                    ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].splice(position, 1);\n                }\n                if (ResizeObserver.resizeObserverClassByObject[target['sourceIndex']].length == 0) {\n                    delete ResizeObserver.resizeObserverClassByObject[target['sourceIndex']];\n                }\n                ResizeObserver.getUniqueInstance().unobserve(target);\n                this.targets.splice(i, 1);\n                return;\n            }\n        }\n    }\n    /**\n     * Destroy the resize observer\n     */\n    disconnect() {\n        for (let i = 0; this.targets.length; i++) {\n            this.unobserve(this.targets[i]);\n        }\n    }\n    entryChanged(entry) {\n        let index = entry.target.sourceIndex;\n        this.entriesChangedEvent[index] = entry;\n    }\n    triggerCb() {\n        if (!this.willTrigger) {\n            this.willTrigger = true;\n            this._triggerCb();\n        }\n    }\n    _triggerCb() {\n        let now = window.performance.now();\n        let elapsed = now - this.nextFrame;\n        if (this.fpsInterval != -1 && elapsed <= this.fpsInterval) {\n            requestAnimationFrame(() => {\n                this._triggerCb();\n            });\n            return;\n        }\n        this.nextFrame = now - (elapsed % this.fpsInterval);\n        let changed = Object.values(this.entriesChangedEvent);\n        this.entriesChangedEvent = {};\n        this.willTrigger = false;\n        setTimeout(() => {\n            this.callback(changed);\n        }, 0);\n    }\n}\nResizeObserver.Namespace=`Aventus`;\r\n_.ResizeObserver=ResizeObserver;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"CallableFunction","isStrong":false},{"fullName":"Aventus.WindowResizeObserver","isStrong":true},{"fullName":"Aventus.ResizeObserverOptions","isStrong":false}],"fullName":"Aventus.ResizeObserver","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Uri=class Uri {\n    static prepare(uri) {\n        let params = [];\n        let i = 0;\n        let regexState = uri.replace(/{.*?}/g, (group, position) => {\n            group = group.slice(1, -1);\n            let splitted = group.split(\":\");\n            let name = splitted[0].trim();\n            let type = \"string\";\n            let result = \"([^\\\\/]+)\";\n            i++;\n            if (splitted.length > 1) {\n                if (splitted[1].trim() == \"number\") {\n                    result = \"([0-9]+)\";\n                    type = \"number\";\n                }\n            }\n            params.push({\n                name,\n                type,\n                position: i\n            });\n            return result;\n        });\n        regexState = regexState.replace(/\\*/g, \".*?\").toLowerCase();\n        regexState = \"^\" + regexState + '$';\n        return {\n            regex: new RegExp(regexState),\n            params\n        };\n    }\n    static getParams(from, current) {\n        if (typeof from == \"string\") {\n            from = this.prepare(from);\n        }\n        let matches = from.regex.exec(current.toLowerCase());\n        if (matches) {\n            let slugs = {};\n            for (let param of from.params) {\n                if (param.type == \"number\") {\n                    slugs[param.name] = Number(matches[param.position]);\n                }\n                else {\n                    slugs[param.name] = matches[param.position];\n                }\n            }\n            return slugs;\n        }\n        return null;\n    }\n    static isActive(from, current) {\n        if (typeof from == \"string\") {\n            from = this.prepare(from);\n        }\n        return from.regex.test(current);\n    }\n    static normalize(path) {\n        const isAbsolute = path.startsWith('/');\n        const parts = path.split('/');\n        const normalizedParts = [];\n        for (let i = 0; i < parts.length; i++) {\n            if (parts[i] === '..') {\n                normalizedParts.pop();\n            }\n            else if (parts[i] !== '.' && parts[i] !== '') {\n                normalizedParts.push(parts[i]);\n            }\n        }\n        let normalizedPath = normalizedParts.join('/');\n        if (isAbsolute) {\n            normalizedPath = '/' + normalizedPath;\n        }\n        return normalizedPath;\n    }\n}\nUri.Namespace=`Aventus`;\r\n_.Uri=Uri;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.PreparedUri","isStrong":false},{"fullName":"Aventus.UriParams","isStrong":false},{"fullName":"Aventus.UriParamsValue","isStrong":false}],"fullName":"Aventus.Uri","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let RamError=class RamError extends GenericError {\n}\nRamError.Namespace=`Aventus`;\r\n_.RamError=RamError;\r\n","dependances":[{"fullName":"Aventus.GenericError","isStrong":true},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"Storybook","isStrong":false}],"fullName":"Aventus.RamError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ResultRamWithError=class ResultRamWithError extends ResultWithError {\n}\nResultRamWithError.Namespace=`Aventus`;\r\n_.ResultRamWithError=ResultRamWithError;\r\n","dependances":[{"fullName":"Aventus.ResultWithError","isStrong":true},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Storybook","isStrong":false}],"fullName":"Aventus.ResultRamWithError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let VoidRamWithError=class VoidRamWithError extends VoidWithError {\n}\nVoidRamWithError.Namespace=`Aventus`;\r\n_.VoidRamWithError=VoidRamWithError;\r\n","dependances":[{"fullName":"Aventus.VoidWithError","isStrong":true},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Storybook","isStrong":false}],"fullName":"Aventus.VoidRamWithError","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let GenericRam=class GenericRam {\n    /**\n     * The current namespace\n     */\n    static Namespace = \"\";\n    // public static get Namespace(): string { return \"\"; }\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    subscribers = {\n        created: [],\n        updated: [],\n        deleted: [],\n    };\n    recordsSubscribers = new Map();\n    /**\n     * List of stored item by index key\n     */\n    records = new Map();\n    actionGuard = new ActionGuard();\n    constructor() {\n        if (this.constructor == GenericRam) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.getIdWithError = this.getIdWithError.bind(this);\n        this.getId = this.getId.bind(this);\n        this.save = this.save.bind(this);\n        this.saveWithError = this.saveWithError.bind(this);\n        this.onCreated = this.onCreated.bind(this);\n        this.offCreated = this.offCreated.bind(this);\n        this.onUpdated = this.onUpdated.bind(this);\n        this.offUpdated = this.offUpdated.bind(this);\n        this.onDeleted = this.onDeleted.bind(this);\n        this.offDeleted = this.offDeleted.bind(this);\n        this.get = this.get.bind(this);\n        this.getWithError = this.getWithError.bind(this);\n        this.getById = this.getById.bind(this);\n        this.getByIdWithError = this.getByIdWithError.bind(this);\n        this.getByIds = this.getByIds.bind(this);\n        this.getByIdsWithError = this.getByIdsWithError.bind(this);\n        this.getAll = this.getAll.bind(this);\n        this.getAllWithError = this.getAllWithError.bind(this);\n        this.getList = this.getList.bind(this);\n        this.getListWithError = this.getListWithError.bind(this);\n        this.createList = this.createList.bind(this);\n        this.createListWithError = this.createListWithError.bind(this);\n        this.create = this.create.bind(this);\n        this.createWithError = this.createWithError.bind(this);\n        this.updateList = this.updateList.bind(this);\n        this.updateListWithError = this.updateListWithError.bind(this);\n        this.update = this.update.bind(this);\n        this.updateWithError = this.updateWithError.bind(this);\n        this.deleteList = this.deleteList.bind(this);\n        this.deleteListWithError = this.deleteListWithError.bind(this);\n        this.delete = this.delete.bind(this);\n        this.deleteWithError = this.deleteWithError.bind(this);\n        this.deleteById = this.deleteById.bind(this);\n        this.deleteByIdWithError = this.deleteByIdWithError.bind(this);\n    }\n    /**\n     * Get item id\n     */\n    getIdWithError(item) {\n        let action = new ResultRamWithError();\n        let idTemp = item[this.defineIndexKey()];\n        if (idTemp !== undefined) {\n            action.result = idTemp;\n        }\n        else {\n            action.errors.push(new RamError(RamErrorCode.noId, \"no key found for item\"));\n        }\n        return action;\n    }\n    /**\n     * Get item id\n     */\n    getId(item) {\n        let result = this.getIdWithError(item);\n        if (result.success) {\n            return result.result;\n        }\n        throw 'no key found for item';\n    }\n    /**\n     * Prevent adding Watch element\n     */\n    removeWatch(element) {\n        let byPass = element;\n        if (byPass.__isProxy) {\n            return byPass.getTarget();\n        }\n        return element;\n    }\n    /**\n     * Add function update, onUpdate, offUpdate, delete, onDelete, offDelete\n     */\n    addRamAction(Base) {\n        let that = this;\n        return class ActionClass extends Base {\n            static get className() {\n                return Base.className || Base.name;\n            }\n            get className() {\n                return Base.className || Base.name;\n            }\n            async update(newData = {}) {\n                let id = that.getId(this);\n                let oldData = that.records.get(id);\n                if (oldData) {\n                    that.mergeObject(oldData, newData, { replaceUndefinedWithKey: true });\n                    let result = await that.update(oldData);\n                    return result;\n                }\n                return undefined;\n            }\n            async updateWithError(newData = {}) {\n                const result = new ResultRamWithError();\n                let queryId = that.getIdWithError(this);\n                if (!queryId.success || !queryId.result) {\n                    result.errors = queryId.errors;\n                    return result;\n                }\n                let oldData = that.records.get(queryId.result);\n                if (oldData) {\n                    that.mergeObject(oldData, newData, { replaceUndefinedWithKey: true });\n                    let result = await that.updateWithError(oldData);\n                    return result;\n                }\n                result.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"Can't find this item inside the ram\"));\n                return result;\n            }\n            onUpdate(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                let sub = that.recordsSubscribers.get(id);\n                if (sub && !sub.updated.includes(callback)) {\n                    sub.updated.push(callback);\n                }\n            }\n            offUpdate(callback) {\n                let id = that.getId(this);\n                let sub = that.recordsSubscribers.get(id);\n                if (sub) {\n                    let index = sub.updated.indexOf(callback);\n                    if (index != -1) {\n                        sub.updated.splice(index, 1);\n                    }\n                }\n            }\n            async delete() {\n                let id = that.getId(this);\n                await that.deleteById(id);\n            }\n            async deleteWithError() {\n                const result = new VoidRamWithError();\n                let queryId = that.getIdWithError(this);\n                if (!queryId.success || !queryId.result) {\n                    result.errors = queryId.errors;\n                    return result;\n                }\n                const queryDelete = await that.deleteByIdWithError(queryId.result);\n                result.errors = queryDelete.errors;\n                return result;\n            }\n            onDelete(callback) {\n                let id = that.getId(this);\n                if (!that.recordsSubscribers.has(id)) {\n                    that.recordsSubscribers.set(id, {\n                        created: [],\n                        updated: [],\n                        deleted: []\n                    });\n                }\n                let sub = that.recordsSubscribers.get(id);\n                if (sub && !sub.deleted.includes(callback)) {\n                    sub.deleted.push(callback);\n                }\n            }\n            offDelete(callback) {\n                let id = that.getId(this);\n                let sub = that.recordsSubscribers.get(id);\n                if (sub) {\n                    let index = sub.deleted.indexOf(callback);\n                    if (index != -1) {\n                        sub.deleted.splice(index, 1);\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Transform the object into the object stored inside Ram\n     */\n    getObjectForRam(objJson) {\n        let T = this.addRamAction(this.getTypeForData(objJson));\n        let item = new T();\n        this.mergeObject(item, objJson);\n        return item;\n    }\n    /**\n     * Add element inside Ram or update it. The instance inside the ram is unique and ll never be replaced\n     */\n    async addOrUpdateData(item, result) {\n        let resultTemp = null;\n        try {\n            let idWithError = this.getIdWithError(item);\n            if (idWithError.success && idWithError.result !== undefined) {\n                let id = idWithError.result;\n                if (this.records.has(id)) {\n                    let uniqueRecord = this.records.get(id);\n                    await this.beforeRecordSet(uniqueRecord);\n                    this.mergeObject(uniqueRecord, item);\n                    await this.afterRecordSet(uniqueRecord);\n                    resultTemp = 'updated';\n                }\n                else {\n                    let realObject = this.getObjectForRam(item);\n                    await this.beforeRecordSet(realObject);\n                    this.records.set(id, realObject);\n                    await this.afterRecordSet(realObject);\n                    resultTemp = 'created';\n                }\n                result.result = this.records.get(id);\n            }\n            else {\n                result.errors = [...result.errors, ...idWithError.errors];\n                resultTemp = null;\n            }\n        }\n        catch (e) {\n            result.errors.push(new RamError(RamErrorCode.unknow, e));\n            resultTemp = null;\n        }\n        return resultTemp;\n    }\n    /**\n     * Merge object and create real instance of class\n     */\n    mergeObject(item, objJson, options) {\n        if (!item) {\n            return;\n        }\n        if (!options) {\n            options = {\n                replaceUndefined: true\n            };\n        }\n        Json.classFromJson(item, objJson, options);\n    }\n    /**\n     * Create or update the item\n     */\n    async save(item, ...args) {\n        let action = await this.saveWithError(item, ...args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create or update the item\n     */\n    async saveWithError(item, ...args) {\n        let action = new ResultRamWithError();\n        let resultTemp = await this.getIdWithError(item);\n        if (resultTemp.success && resultTemp.result !== undefined) {\n            if (resultTemp.result) {\n                return this.updateWithError(item, ...args);\n            }\n            else {\n                return this.createWithError(item, ...args);\n            }\n        }\n        else {\n            action.errors = resultTemp.errors;\n        }\n        return action;\n    }\n    async beforeRecordSet(item) { }\n    async afterRecordSet(item) { }\n    async beforeRecordDelete(item) { }\n    async afterRecordDelete(item) { }\n    publish(type, data) {\n        let callbacks = [...this.subscribers[type]];\n        for (let callback of callbacks) {\n            callback(data);\n        }\n        let sub = this.recordsSubscribers.get(this.getId(data));\n        if (sub) {\n            let localCallbacks = [...sub[type]];\n            for (let localCallback of localCallbacks) {\n                localCallback(data);\n            }\n        }\n    }\n    subscribe(type, cb) {\n        if (!this.subscribers[type].includes(cb)) {\n            this.subscribers[type].push(cb);\n        }\n    }\n    unsubscribe(type, cb) {\n        let index = this.subscribers[type].indexOf(cb);\n        if (index != -1) {\n            this.subscribers[type].splice(index, 1);\n        }\n    }\n    /**\n    * Add a callback that ll be triggered when a new item is stored\n    */\n    onCreated(cb) {\n        this.subscribe('created', cb);\n    }\n    /**\n     * Remove a created callback\n     */\n    offCreated(cb) {\n        this.unsubscribe('created', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is updated\n     */\n    onUpdated(cb) {\n        this.subscribe('updated', cb);\n    }\n    /**\n     * Remove an updated callback\n     */\n    offUpdated(cb) {\n        this.unsubscribe('updated', cb);\n    }\n    /**\n     * Add a callback that ll be triggered when an item is deleted\n     */\n    onDeleted(cb) {\n        this.subscribe('deleted', cb);\n    }\n    /**\n     * Remove an deleted callback\n     */\n    offDeleted(cb) {\n        this.unsubscribe('deleted', cb);\n    }\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async get(id) {\n        return await this.getById(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist (alias for getById)\n     */\n    async getWithError(id) {\n        return await this.getByIdWithError(id);\n    }\n    ;\n    /**\n     * Get an item by id if exist\n     */\n    async getById(id) {\n        let action = await this.getByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Get an item by id if exist\n     */\n    async getByIdWithError(id) {\n        return this.actionGuard.run(['getByIdWithError', id], async () => {\n            let action = new ResultRamWithError();\n            await this.beforeGetById(id, action);\n            if (action.success) {\n                if (this.records.has(id)) {\n                    action.result = this.records.get(id);\n                    await this.afterGetById(action);\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                }\n            }\n            return action;\n        });\n    }\n    /**\n     * Trigger before getting an item by id\n     */\n    async beforeGetById(id, result) { }\n    ;\n    /**\n     * Trigger after getting an item by id\n     */\n    async afterGetById(result) { }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIds(ids) {\n        let result = await this.getByIdsWithError(ids);\n        if (result.success) {\n            return result.result ?? [];\n        }\n        return [];\n    }\n    ;\n    /**\n     * Get multiple items by ids\n     */\n    async getByIdsWithError(ids) {\n        return this.actionGuard.run(['getByIdsWithError', ids], async () => {\n            let action = new ResultRamWithError();\n            action.result = [];\n            await this.beforeGetByIds(ids, action);\n            if (action.success) {\n                action.result = [];\n                for (let id of ids) {\n                    let rec = this.records.get(id);\n                    if (rec) {\n                        action.result.push(rec);\n                    }\n                    else {\n                        action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't find the item \" + id + \" inside ram\"));\n                    }\n                }\n                if (action.success) {\n                    await this.afterGetByIds(action);\n                }\n            }\n            return action;\n        });\n    }\n    ;\n    /**\n     * Trigger before getting a list of items by id\n     */\n    async beforeGetByIds(ids, result) { }\n    ;\n    /**\n     * Trigger after getting a list of items by id\n     */\n    async afterGetByIds(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAll() {\n        let result = await this.getAllWithError();\n        if (result.success) {\n            return result.result ?? new Map();\n        }\n        return new Map();\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getAllWithError() {\n        return this.actionGuard.run(['getAllWithError'], async () => {\n            let action = new ResultRamWithError();\n            action.result = new Map();\n            await this.beforeGetAll(action);\n            if (action.success) {\n                action.result = this.records;\n                await this.afterGetAll(action);\n            }\n            return action;\n        });\n    }\n    ;\n    /**\n     * Trigger before getting all items inside Ram\n     */\n    async beforeGetAll(result) { }\n    ;\n    /**\n     * Trigger after getting all items inside Ram\n     */\n    async afterGetAll(result) { }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getList() {\n        let data = await this.getAll();\n        return Array.from(data.values());\n    }\n    ;\n    /**\n     * Get all elements inside the Ram\n     */\n    async getListWithError() {\n        let action = new ResultRamWithError();\n        action.result = [];\n        let result = await this.getAllWithError();\n        if (result.success) {\n            if (result.result) {\n                action.result = Array.from(result.result.values());\n            }\n            else {\n                action.result = [];\n            }\n        }\n        else {\n            action.errors = result.errors;\n        }\n        return action;\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createList(list) {\n        let result = await this.createListWithError(list);\n        return result.result ?? [];\n    }\n    /**\n     * Create a list of items inside ram\n     */\n    async createListWithError(list) {\n        list = this.removeWatch(list);\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeCreateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n                action.result = [];\n            }\n            for (let item of list) {\n                let resultItem = await this._create(item, true);\n                if (resultItem.success && resultItem.result) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterCreateList(action);\n            }\n        }\n        return action;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async create(item, ...args) {\n        let action = await this.createWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Create an item inside ram\n     */\n    async createWithError(item, ...args) {\n        return await this._create(item, false);\n    }\n    async _create(item, fromList) {\n        item = this.removeWatch(item);\n        return this.actionGuard.run(['_create', item], async () => {\n            let action = new ResultRamWithError();\n            await this.beforeCreateItem(item, fromList, action);\n            if (action.success) {\n                if (action.result) {\n                    item = action.result;\n                }\n                let resultTemp = this.getIdWithError(item);\n                if (resultTemp.success) {\n                    await this.addOrUpdateData(item, action);\n                    if (!action.success) {\n                        return action;\n                    }\n                    await this.afterCreateItem(action, fromList);\n                    if (!action.success) {\n                        action.result = undefined;\n                    }\n                    else if (action.result) {\n                        this.publish('created', action.result);\n                    }\n                }\n                else {\n                    action.errors = resultTemp.errors;\n                }\n            }\n            return action;\n        });\n    }\n    /**\n     * Trigger before creating a list of items\n     */\n    async beforeCreateList(list, result) {\n    }\n    ;\n    /**\n     * Trigger before creating an item\n     */\n    async beforeCreateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after creating an item\n     */\n    async afterCreateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after creating a list of items\n     */\n    async afterCreateList(result) {\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateList(list) {\n        let result = await this.updateListWithError(list);\n        return result.result ?? [];\n    }\n    ;\n    /**\n     * Update a list of items inside ram\n     */\n    async updateListWithError(list) {\n        list = this.removeWatch(list);\n        let action = new ResultRamWithError();\n        action.result = [];\n        await this.beforeUpdateList(list, action);\n        if (action.success) {\n            if (action.result.length > 0) {\n                list = action.result;\n                action.result = [];\n            }\n            for (let item of list) {\n                let resultItem = await this._update(item, true);\n                if (resultItem.success && resultItem.result) {\n                    action.result.push(resultItem.result);\n                }\n                else {\n                    action.errors = [...action.errors, ...resultItem.errors];\n                }\n            }\n            if (action.success) {\n                await this.afterUpdateList(action);\n            }\n        }\n        return action;\n    }\n    ;\n    /**\n     * Update an item inside ram\n     */\n    async update(item, ...args) {\n        let action = await this.updateWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n     * Update an item inside ram\n     */\n    async updateWithError(item, ...args) {\n        return await this._update(item, false);\n    }\n    async _update(item, fromList) {\n        item = this.removeWatch(item);\n        return this.actionGuard.run(['_update', item], async () => {\n            let action = new ResultRamWithError();\n            let resultTemp = await this.getIdWithError(item);\n            if (resultTemp.success && resultTemp.result !== undefined) {\n                let key = resultTemp.result;\n                if (this.records.has(key)) {\n                    if (this.records.get(key) == item) {\n                        console.warn(\"You are updating the same item. You should clone the object first to avoid weird effect\");\n                    }\n                    await this.beforeUpdateItem(item, fromList, action);\n                    if (!action.success) {\n                        return action;\n                    }\n                    if (action.result) {\n                        item = action.result;\n                    }\n                    await this.addOrUpdateData(item, action);\n                    if (!action.success) {\n                        return action;\n                    }\n                    await this.afterUpdateItem(action, fromList);\n                    if (!action.success) {\n                        action.result = undefined;\n                    }\n                    else if (action.result) {\n                        this.publish('updated', action.result);\n                    }\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't update the item \" + key + \" because it wasn't found inside ram\"));\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n            return action;\n        });\n    }\n    ;\n    /**\n     * Trigger before updating a list of items\n     */\n    async beforeUpdateList(list, result) {\n    }\n    ;\n    /**\n    * Trigger before updating an item\n    */\n    async beforeUpdateItem(item, fromList, result) {\n    }\n    ;\n    /**\n     * Trigger after updating an item\n     */\n    async afterUpdateItem(result, fromList) {\n    }\n    ;\n    /**\n     * Trigger after updating a list of items\n     */\n    async afterUpdateList(result) {\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteList(list) {\n        let result = await this.deleteListWithError(list);\n        return result.result ?? [];\n    }\n    ;\n    /**\n     * Delete a list of items inside ram\n     */\n    async deleteListWithError(list) {\n        list = this.removeWatch(list);\n        let action = new ResultRamWithError();\n        action.result = [];\n        let deleteResult = new VoidWithError();\n        await this.beforeDeleteList(list, deleteResult);\n        if (!deleteResult.success) {\n            action.errors = deleteResult.errors;\n        }\n        for (let item of list) {\n            let resultItem = await this._delete(item, true);\n            if (resultItem.success && resultItem.result) {\n                action.result.push(resultItem.result);\n            }\n            else {\n                action.errors = [...action.errors, ...resultItem.errors];\n            }\n        }\n        if (action.success) {\n            await this.afterDeleteList(action);\n        }\n        return action;\n    }\n    ;\n    /**\n     * Delete an item inside ram\n     */\n    async delete(item, ...args) {\n        let action = await this.deleteWithError(item, args);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    ;\n    /**\n    * Delete an item inside ram\n    */\n    async deleteWithError(item, ...args) {\n        return await this._delete(item, false);\n    }\n    ;\n    /**\n     * Delete an item by id inside ram\n     */\n    async deleteById(id) {\n        let action = await this.deleteByIdWithError(id);\n        if (action.success) {\n            return action.result;\n        }\n        return undefined;\n    }\n    /**\n    * Delete an item by id inside ram\n    */\n    async deleteByIdWithError(id) {\n        let item = this.records.get(id);\n        if (item) {\n            return await this._delete(item, false);\n        }\n        let result = new ResultRamWithError();\n        result.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't delete the item \" + id + \" because it wasn't found inside ram\"));\n        return result;\n    }\n    async _delete(item, fromList) {\n        item = this.removeWatch(item);\n        return this.actionGuard.run(['_delete', item], async () => {\n            let action = new ResultRamWithError();\n            let resultTemp = await this.getIdWithError(item);\n            if (resultTemp.success && resultTemp.result) {\n                let key = resultTemp.result;\n                let oldItem = this.records.get(key);\n                if (oldItem) {\n                    let deleteResult = new VoidWithError();\n                    await this.beforeDeleteItem(oldItem, fromList, deleteResult);\n                    if (!deleteResult.success) {\n                        action.errors = deleteResult.errors;\n                        return action;\n                    }\n                    this.beforeRecordDelete(oldItem);\n                    this.records.delete(key);\n                    this.afterRecordDelete(oldItem);\n                    action.result = oldItem;\n                    await this.afterDeleteItem(action, fromList);\n                    if (!action.success) {\n                        action.result = undefined;\n                    }\n                    else {\n                        this.publish('deleted', action.result);\n                    }\n                    this.recordsSubscribers.delete(key);\n                }\n                else {\n                    action.errors.push(new RamError(RamErrorCode.noItemInsideRam, \"can't delete the item \" + key + \" because it wasn't found inside ram\"));\n                }\n            }\n            else {\n                action.errors = resultTemp.errors;\n            }\n            return action;\n        });\n    }\n    /**\n     * Trigger before deleting a list of items\n     */\n    async beforeDeleteList(list, result) { }\n    ;\n    /**\n     * Trigger before deleting an item\n     */\n    async beforeDeleteItem(item, fromList, result) { }\n    ;\n    /**\n     * Trigger after deleting an item\n     */\n    async afterDeleteItem(result, fromList) { }\n    ;\n    /**\n     * Trigger after deleting a list of items\n     */\n    async afterDeleteList(result) { }\n}\nGenericRam.Namespace=`Aventus`;\r\n_.GenericRam=GenericRam;\r\n","dependances":[{"fullName":"Aventus.IRam","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"Aventus.RamSubscribers","isStrong":false},{"fullName":"Aventus.RamItem","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.ActionGuard","isStrong":false},{"fullName":"BindThis","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.RamError","isStrong":false},{"fullName":"Aventus.RamErrorCode","isStrong":false},{"fullName":"X","isStrong":false},{"fullName":"B","isStrong":false},{"fullName":"Base","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.VoidRamWithError","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"Aventus.JsonFromOptions","isStrong":false},{"fullName":"Aventus.Json","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false}],"fullName":"Aventus.GenericRam","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Ram=class Ram extends GenericRam {\n}\nRam.Namespace=`Aventus`;\r\n_.Ram=Ram;\r\n","dependances":[{"fullName":"Aventus.GenericRam","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.IData","isStrong":false}],"fullName":"Aventus.Ram","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let StateManager=class StateManager {\n    subscribers = {};\n    static canBeActivate(statePattern, stateName) {\n        let stateInfo = Uri.prepare(statePattern);\n        return stateInfo.regex.test(stateName);\n    }\n    activeState;\n    changeStateMutex = new Mutex();\n    canChangeStateCbs = [];\n    afterStateChanged = new Callback();\n    /**\n     * Subscribe actions for a state or a state list\n     */\n    subscribe(statePatterns, callbacks, autoActiveState = true) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to subscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (!this.subscribers.hasOwnProperty(statePattern)) {\n                let res = Uri.prepare(statePattern);\n                let isActive = this.activeState !== undefined && res.regex.test(this.activeState.name);\n                this.subscribers[statePattern] = {\n                    \"regex\": res.regex,\n                    \"params\": res.params,\n                    \"callbacks\": {\n                        \"active\": [],\n                        \"inactive\": [],\n                        \"askChange\": [],\n                    },\n                    \"isActive\": isActive,\n                };\n            }\n            if (callbacks.active) {\n                if (!Array.isArray(callbacks.active)) {\n                    callbacks.active = [callbacks.active];\n                }\n                for (let activeFct of callbacks.active) {\n                    this.subscribers[statePattern].callbacks.active.push(activeFct);\n                    if (this.subscribers[statePattern].isActive && this.activeState && autoActiveState) {\n                        let slugs = Uri.getParams(this.subscribers[statePattern], this.activeState.name);\n                        if (slugs) {\n                            activeFct(this.activeState, slugs);\n                        }\n                    }\n                }\n            }\n            if (callbacks.inactive) {\n                if (!Array.isArray(callbacks.inactive)) {\n                    callbacks.inactive = [callbacks.inactive];\n                }\n                for (let inactiveFct of callbacks.inactive) {\n                    this.subscribers[statePattern].callbacks.inactive.push(inactiveFct);\n                }\n            }\n            if (callbacks.askChange) {\n                if (!Array.isArray(callbacks.askChange)) {\n                    callbacks.askChange = [callbacks.askChange];\n                }\n                for (let askChangeFct of callbacks.askChange) {\n                    this.subscribers[statePattern].callbacks.askChange.push(askChangeFct);\n                }\n            }\n        }\n    }\n    /**\n     *\n     */\n    activateAfterSubscribe(statePatterns, callbacks) {\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (callbacks.active) {\n                if (!Array.isArray(callbacks.active)) {\n                    callbacks.active = [callbacks.active];\n                }\n                for (let activeFct of callbacks.active) {\n                    if (this.subscribers[statePattern].isActive && this.activeState) {\n                        let slugs = Uri.getParams(this.subscribers[statePattern], this.activeState.name);\n                        if (slugs) {\n                            activeFct(this.activeState, slugs);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Unsubscribe actions for a state or a state list\n     */\n    unsubscribe(statePatterns, callbacks) {\n        if (!callbacks.active && !callbacks.inactive && !callbacks.askChange) {\n            this._log(`Trying to unsubscribe to state : ${statePatterns} with no callbacks !`, \"warning\");\n            return;\n        }\n        if (!Array.isArray(statePatterns)) {\n            statePatterns = [statePatterns];\n        }\n        for (let statePattern of statePatterns) {\n            if (this.subscribers[statePattern]) {\n                if (callbacks.active) {\n                    if (!Array.isArray(callbacks.active)) {\n                        callbacks.active = [callbacks.active];\n                    }\n                    for (let activeFct of callbacks.active) {\n                        let index = this.subscribers[statePattern].callbacks.active.indexOf(activeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.active.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.inactive) {\n                    if (!Array.isArray(callbacks.inactive)) {\n                        callbacks.inactive = [callbacks.inactive];\n                    }\n                    for (let inactiveFct of callbacks.inactive) {\n                        let index = this.subscribers[statePattern].callbacks.inactive.indexOf(inactiveFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.inactive.splice(index, 1);\n                        }\n                    }\n                }\n                if (callbacks.askChange) {\n                    if (!Array.isArray(callbacks.askChange)) {\n                        callbacks.askChange = [callbacks.askChange];\n                    }\n                    for (let askChangeFct of callbacks.askChange) {\n                        let index = this.subscribers[statePattern].callbacks.askChange.indexOf(askChangeFct);\n                        if (index !== -1) {\n                            this.subscribers[statePattern].callbacks.askChange.splice(index, 1);\n                        }\n                    }\n                }\n                if (this.subscribers[statePattern].callbacks.active.length === 0 &&\n                    this.subscribers[statePattern].callbacks.inactive.length === 0 &&\n                    this.subscribers[statePattern].callbacks.askChange.length === 0) {\n                    delete this.subscribers[statePattern];\n                }\n            }\n        }\n    }\n    onAfterStateChanged(cb) {\n        this.afterStateChanged.add(cb);\n    }\n    offAfterStateChanged(cb) {\n        this.afterStateChanged.remove(cb);\n    }\n    assignDefaultState(stateName) {\n        return new EmptyState(stateName);\n    }\n    canChangeState(cb) {\n        this.canChangeStateCbs.push(cb);\n    }\n    /**\n     * Activate a current state\n     */\n    async setState(state) {\n        let result = await this.changeStateMutex.safeRunLastAsync(async () => {\n            let stateToUse;\n            if (typeof state == \"string\") {\n                stateToUse = this.assignDefaultState(state);\n            }\n            else {\n                stateToUse = state;\n            }\n            if (!stateToUse) {\n                this._log(\"state is undefined\", \"error\");\n                this.changeStateMutex.release();\n                return false;\n            }\n            for (let cb of this.canChangeStateCbs) {\n                if (!(await cb(stateToUse))) {\n                    return false;\n                }\n            }\n            let canChange = true;\n            if (this.activeState) {\n                let activeToInactive = [];\n                let inactiveToActive = [];\n                let triggerActive = [];\n                canChange = await this.activeState.askChange(this.activeState, stateToUse);\n                if (canChange) {\n                    for (let statePattern in this.subscribers) {\n                        let subscriber = this.subscribers[statePattern];\n                        if (subscriber.isActive) {\n                            let clone = [...subscriber.callbacks.askChange];\n                            let currentSlug = Uri.getParams(subscriber, this.activeState.name);\n                            if (currentSlug) {\n                                for (let i = 0; i < clone.length; i++) {\n                                    let askChange = clone[i];\n                                    if (!await askChange(this.activeState, stateToUse, currentSlug)) {\n                                        canChange = false;\n                                        break;\n                                    }\n                                }\n                            }\n                            let slugs = Uri.getParams(subscriber, stateToUse.name);\n                            if (slugs === null) {\n                                activeToInactive.push(subscriber);\n                            }\n                            else {\n                                triggerActive.push({\n                                    subscriber: subscriber,\n                                    params: slugs\n                                });\n                            }\n                        }\n                        else {\n                            let slugs = Uri.getParams(subscriber, stateToUse.name);\n                            if (slugs) {\n                                inactiveToActive.push({\n                                    subscriber,\n                                    params: slugs\n                                });\n                            }\n                        }\n                        if (!canChange) {\n                            break;\n                        }\n                    }\n                }\n                if (canChange) {\n                    const oldState = this.activeState;\n                    this.activeState = stateToUse;\n                    oldState.onInactivate(stateToUse);\n                    for (let subscriber of activeToInactive) {\n                        subscriber.isActive = false;\n                        let oldSlug = Uri.getParams(subscriber, oldState.name);\n                        if (oldSlug) {\n                            let oldSlugNotNull = oldSlug;\n                            let callbacks = [...subscriber.callbacks.inactive];\n                            for (let callback of callbacks) {\n                                callback(oldState, stateToUse, oldSlugNotNull);\n                            }\n                        }\n                    }\n                    for (let trigger of triggerActive) {\n                        let callbacks = [...trigger.subscriber.callbacks.active];\n                        for (let callback of callbacks) {\n                            callback(stateToUse, trigger.params);\n                        }\n                    }\n                    for (let trigger of inactiveToActive) {\n                        trigger.subscriber.isActive = true;\n                        let callbacks = [...trigger.subscriber.callbacks.active];\n                        for (let callback of callbacks) {\n                            callback(stateToUse, trigger.params);\n                        }\n                    }\n                    stateToUse.onActivate();\n                }\n            }\n            else {\n                this.activeState = stateToUse;\n                for (let key in this.subscribers) {\n                    let slugs = Uri.getParams(this.subscribers[key], stateToUse.name);\n                    if (slugs) {\n                        let slugsNotNull = slugs;\n                        this.subscribers[key].isActive = true;\n                        let callbacks = [...this.subscribers[key].callbacks.active];\n                        for (let callback of callbacks) {\n                            callback(stateToUse, slugsNotNull);\n                        }\n                    }\n                }\n                stateToUse.onActivate();\n            }\n            this.afterStateChanged.trigger();\n            return true;\n        });\n        return result ?? false;\n    }\n    getState() {\n        return this.activeState;\n    }\n    /**\n     * Check if a state is in the subscribers and active, return true if it is, false otherwise\n     */\n    isStateActive(statePattern) {\n        return Uri.isActive(statePattern, this.activeState?.name ?? '');\n    }\n    /**\n     * Get slugs information for the current state, return null if state isn't active\n     */\n    getStateSlugs(statePattern) {\n        return Uri.getParams(statePattern, this.activeState?.name ?? '');\n    }\n    // 0 = error only / 1 = errors and warning / 2 = error, warning and logs (not implemented)\n    logLevel() {\n        return 0;\n    }\n    _log(msg, type) {\n        if (type === \"error\") {\n            console.error(msg);\n        }\n        else if (type === \"warning\" && this.logLevel() > 0) {\n            console.warn(msg);\n        }\n        else if (type === \"info\" && this.logLevel() > 1) {\n            console.log(msg);\n        }\n    }\n}\nStateManager.Namespace=`Aventus`;\r\n_.StateManager=StateManager;\r\n","dependances":[{"fullName":"Aventus.IStateManager","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Subscriber","isStrong":false},{"fullName":"Aventus.Uri","isStrong":false},{"fullName":"Aventus.Mutex","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.Callback","isStrong":false},{"fullName":"Aventus.StateAction","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Aventus.UriParamsValue","isStrong":false},{"fullName":"Aventus.EmptyState","isStrong":false},{"fullName":"Aventus.State","isStrong":false}],"fullName":"Aventus.StateManager","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let State=class State {\n    /**\n     * Activate a custom state inside a specific manager\n     * It ll be a generic state with no information inside exept name\n     */\n    static async activate(stateName, manager) {\n        return await manager.setState(stateName);\n    }\n    /**\n     * Activate this state inside a specific manager\n     */\n    async activate(manager) {\n        return await manager.setState(this);\n    }\n    onActivate() {\n    }\n    onInactivate(nextState) {\n    }\n    async askChange(state, nextState) {\n        return true;\n    }\n}\nState.Namespace=`Aventus`;\r\n_.State=State;\r\n","dependances":[{"fullName":"Aventus.IState","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Promise","isStrong":false}],"fullName":"Aventus.State","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let EmptyState=class EmptyState extends State {\n    localName;\n    constructor(stateName) {\n        super();\n        this.localName = stateName;\n    }\n    /**\n     * @inheritdoc\n     */\n    get name() {\n        return this.localName;\n    }\n}\nEmptyState.Namespace=`Aventus`;\r\n_.EmptyState=EmptyState;\r\n","dependances":[{"fullName":"Aventus.State","isStrong":true},{"fullName":"Aventus.IState","isStrong":true},{"fullName":"Storybook","isStrong":false}],"fullName":"Aventus.EmptyState","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let TemplateInstance=class TemplateInstance {\n    context;\n    content;\n    actions;\n    component;\n    _components = {};\n    firstRenderUniqueCb = {};\n    firstRenderCb = [];\n    firstChild;\n    lastChild;\n    computeds = [];\n    renderingComputeds = [];\n    loopRegisteries = {};\n    loops = [];\n    ifs = [];\n    isDestroyed = false;\n    constructor(component, content, actions, loops, ifs, context) {\n        this.component = component;\n        this.content = content;\n        this.actions = actions;\n        this.ifs = ifs;\n        this.loops = loops;\n        this.context = context ? context : new TemplateContext(component);\n        this.firstChild = content.firstElementChild;\n        this.lastChild = content.lastElementChild;\n        this.selectElements();\n        this.transformActionsListening();\n    }\n    render() {\n        this.updateContext();\n        this.bindEvents();\n        for (let cb of this.firstRenderCb) {\n            cb();\n        }\n        for (let key in this.firstRenderUniqueCb) {\n            this.firstRenderUniqueCb[key]();\n        }\n        this.renderSubTemplate();\n    }\n    destructor() {\n        this.isDestroyed = true;\n        for (let name in this.loopRegisteries) {\n            let register = this.loopRegisteries[name];\n            for (let item of register.templates) {\n                item.destructor();\n            }\n            for (let item of register.computeds) {\n                item.destroy();\n            }\n            if (register.unsub) {\n                register.unsub();\n            }\n        }\n        this.loopRegisteries = {};\n        this.context.destructor();\n        for (let computed of this.computeds) {\n            computed.destroy();\n        }\n        for (let computed of this.renderingComputeds) {\n            computed.destroy();\n        }\n        this.computeds = [];\n        this.removeFromDOM();\n    }\n    removeFromDOM(avoidTrigger = false) {\n        if (avoidTrigger) {\n            let node = this.firstChild;\n            while (node && node != this.lastChild) {\n                let next = node.nextElementSibling;\n                node.parentNode?.removeChild(node);\n                node = next;\n            }\n            this.lastChild?.parentNode?.removeChild(this.lastChild);\n        }\n        else {\n            let node = this.firstChild;\n            while (node && node != this.lastChild) {\n                let next = node.nextElementSibling;\n                node.remove();\n                node = next;\n            }\n            this.lastChild?.remove();\n        }\n    }\n    selectElements() {\n        this._components = {};\n        let idEls = Array.from(this.content.querySelectorAll('[_id]'));\n        for (let idEl of idEls) {\n            let id = idEl.attributes['_id'].value;\n            if (!this._components[id]) {\n                this._components[id] = [];\n            }\n            this._components[id].push(idEl);\n        }\n        if (this.actions.elements) {\n            for (let element of this.actions.elements) {\n                let components = [];\n                for (let id of element.ids) {\n                    if (this._components[id]) {\n                        components = [...components, ...this._components[id]];\n                    }\n                }\n                if (element.isArray) {\n                    setValueToObject(element.name, this.component, components);\n                }\n                else if (components[0]) {\n                    setValueToObject(element.name, this.component, components[0]);\n                }\n            }\n        }\n    }\n    updateContext() {\n        if (this.actions.contextEdits) {\n            for (let contextEdit of this.actions.contextEdits) {\n                this.renderContextEdit(contextEdit);\n            }\n        }\n    }\n    renderContextEdit(edit) {\n        let _class = edit.once ? ComputedNoRecomputed : Computed;\n        let computed = new _class(() => {\n            try {\n                return edit.fct(this.context);\n            }\n            catch (e) {\n            }\n            return {};\n        });\n        computed.subscribe((action, path, value, dones) => {\n            for (let key in computed.value) {\n                let newValue = computed.value[key];\n                this.context.updateWatch(key, newValue, dones);\n            }\n        });\n        this.computeds.push(computed);\n        for (let key in computed.value) {\n            this.context.registerWatch(key, computed.value[key]);\n        }\n    }\n    bindEvents() {\n        if (this.actions.events) {\n            for (let event of this.actions.events) {\n                this.bindEvent(event);\n            }\n        }\n        if (this.actions.pressEvents) {\n            for (let event of this.actions.pressEvents) {\n                this.bindPressEvent(event);\n            }\n        }\n    }\n    bindEvent(event) {\n        if (!this._components[event.id]) {\n            return;\n        }\n        if (event.isCallback) {\n            for (let el of this._components[event.id]) {\n                let cb = getValueFromObject(event.eventName, el);\n                cb?.add((...args) => {\n                    try {\n                        return event.fct(this.context, args);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                });\n            }\n        }\n        else {\n            for (let el of this._components[event.id]) {\n                el.addEventListener(event.eventName, (e) => {\n                    try {\n                        event.fct(e, this.context);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                });\n            }\n        }\n    }\n    bindPressEvent(event) {\n        let id = event['id'];\n        if (id && this._components[id]) {\n            let clone = {};\n            for (let temp in event) {\n                if (temp != 'id') {\n                    if (event[temp] instanceof Function) {\n                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };\n                    }\n                    else {\n                        clone[temp] = event[temp];\n                    }\n                }\n            }\n            clone.element = this._components[id];\n            PressManager.create(clone);\n        }\n    }\n    transformActionsListening() {\n        if (this.actions.content) {\n            for (let name in this.actions.content) {\n                this.transformChangeAction(name, this.actions.content[name]);\n            }\n        }\n        if (this.actions.injection) {\n            for (let injection of this.actions.injection) {\n                this.transformInjectionAction(injection);\n            }\n        }\n        if (this.actions.bindings) {\n            for (let binding of this.actions.bindings) {\n                this.transformBindigAction(binding);\n            }\n        }\n    }\n    transformChangeAction(name, change) {\n        const [id, attr] = name.split(\"°\");\n        if (!this._components[id])\n            return;\n        let apply = () => { };\n        if (attr == \"@HTML\") {\n            apply = () => {\n                let value = this.context.print(computed.value);\n                for (const el of this._components[id])\n                    el.innerHTML = value;\n            };\n        }\n        else {\n            apply = () => {\n                let value = this.context.print(computed.value);\n                if (value === \"false\") {\n                    for (const el of this._components[id]) {\n                        el.removeAttribute(attr);\n                    }\n                }\n                else {\n                    for (const el of this._components[id]) {\n                        el.setAttribute(attr, value);\n                    }\n                }\n            };\n        }\n        let _class = change.once ? ComputedNoRecomputed : Computed;\n        let computed = new _class(() => {\n            try {\n                return change.fct(this.context);\n            }\n            catch (e) {\n                if (e instanceof TypeError && e.message.includes(\"undefined\")) {\n                    if (computed instanceof ComputedNoRecomputed) {\n                        computed.isInit = false;\n                    }\n                }\n                else {\n                    console.error(e);\n                }\n            }\n            return \"\";\n        });\n        let timeout;\n        computed.subscribe((action, path, value, dones) => {\n            clearTimeout(timeout);\n            // add timeout to group change that append on the same frame (for example index update)\n            timeout = setTimeout(() => {\n                if (computed.isDestroy)\n                    return;\n                apply();\n            });\n        });\n        this.renderingComputeds.push(computed);\n        this.firstRenderUniqueCb[name] = () => {\n            apply();\n        };\n    }\n    transformInjectionAction(injection) {\n        if (!this._components[injection.id])\n            return;\n        let _class = injection.once ? ComputedNoRecomputed : Computed;\n        let computed = new _class(() => {\n            try {\n                return injection.inject(this.context);\n            }\n            catch (e) {\n                if (e instanceof TypeError && e.message.includes(\"undefined\")) {\n                    if (computed instanceof ComputedNoRecomputed) {\n                        computed.isInit = false;\n                    }\n                }\n                else {\n                    console.error(e);\n                }\n            }\n        });\n        this.computeds.push(computed);\n        computed.subscribe((action, path, value, dones) => {\n            for (const el of this._components[injection.id]) {\n                if (el instanceof WebComponent && el.__watch && Object.hasOwn(el.__watch, injection.injectionName)) {\n                    el.__watch.__injectedDones(dones);\n                }\n                el[injection.injectionName] = computed.value;\n            }\n        });\n        this.firstRenderCb.push(() => {\n            for (const el of this._components[injection.id]) {\n                el[injection.injectionName] = computed.value;\n            }\n        });\n    }\n    transformBindigAction(binding) {\n        let isLocalChange = false;\n        let _class = binding.once ? ComputedNoRecomputed : Computed;\n        let computed = new _class(() => {\n            try {\n                return binding.inject(this.context);\n            }\n            catch (e) {\n                if (e instanceof TypeError && e.message.includes(\"undefined\")) {\n                    if (computed instanceof ComputedNoRecomputed) {\n                        computed.isInit = false;\n                    }\n                }\n                else {\n                    console.error(e);\n                }\n            }\n        });\n        this.computeds.push(computed);\n        computed.subscribe((action, path, value, dones) => {\n            if (isLocalChange)\n                return;\n            for (const el of this._components[binding.id]) {\n                if (el instanceof WebComponent && el.__watch && Object.hasOwn(el.__watch, binding.injectionName)) {\n                    el.__watch.__injectedDones(dones);\n                }\n                el[binding.injectionName] = computed.value;\n            }\n        });\n        this.firstRenderCb.push(() => {\n            for (const el of this._components[binding.id]) {\n                el[binding.injectionName] = computed.value;\n            }\n        });\n        if (binding.isCallback) {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        let cb = getValueFromObject(fct, el);\n                        cb?.add((value) => {\n                            let valueToSet = getValueFromObject(binding.injectionName, el);\n                            isLocalChange = true;\n                            binding.extract(this.context, valueToSet);\n                            isLocalChange = false;\n                        });\n                    }\n                }\n            });\n        }\n        else {\n            this.firstRenderCb.push(() => {\n                for (var el of this._components[binding.id]) {\n                    for (let fct of binding.eventNames) {\n                        el.addEventListener(fct, (e) => {\n                            let valueToSet = getValueFromObject(binding.injectionName, e.target);\n                            isLocalChange = true;\n                            binding.extract(this.context, valueToSet);\n                            isLocalChange = false;\n                        });\n                    }\n                }\n            });\n        }\n    }\n    renderSubTemplate() {\n        for (let loop of this.loops) {\n            this.renderLoop(loop);\n        }\n        for (let _if of this.ifs) {\n            this.renderIf(_if);\n        }\n    }\n    renderLoop(loop) {\n        if (loop.func) {\n            this.renderLoopComplex(loop);\n        }\n        else if (loop.simple) {\n            this.renderLoopSimple(loop, loop.simple);\n        }\n    }\n    resetLoopComplex(anchorId) {\n        if (this.loopRegisteries[anchorId]) {\n            for (let item of this.loopRegisteries[anchorId].templates) {\n                item.destructor();\n            }\n            for (let item of this.loopRegisteries[anchorId].computeds) {\n                item.destroy();\n            }\n        }\n        this.loopRegisteries[anchorId] = {\n            templates: [],\n            computeds: [],\n        };\n    }\n    renderLoopComplex(loop) {\n        if (!loop.func)\n            return;\n        let fctsTemp = loop.func.bind(this.component)(this.context);\n        let fcts = {\n            apply: fctsTemp.apply,\n            condition: fctsTemp.condition,\n            transform: fctsTemp.transform ?? (() => { })\n        };\n        this.resetLoopComplex(loop.anchorId);\n        let computedsCondition = [];\n        let alreadyRecreated = false;\n        const createComputedCondition = () => {\n            let compCondition = new Computed(() => {\n                return fcts.condition();\n            });\n            compCondition.value;\n            compCondition.subscribe((action, path, value) => {\n                if (!alreadyRecreated) {\n                    alreadyRecreated = true;\n                    this.renderLoopComplex(loop);\n                }\n            });\n            computedsCondition.push(compCondition);\n            this.loopRegisteries[loop.anchorId].computeds.push(compCondition);\n            return compCondition;\n        };\n        let result = [];\n        let compCondition = createComputedCondition();\n        while (compCondition.value) {\n            result.push(fcts.apply());\n            fcts.transform();\n            compCondition = createComputedCondition();\n        }\n        let anchor = this._components[loop.anchorId][0];\n        for (let i = 0; i < result.length; i++) {\n            let context = new TemplateContext(this.component, result[i], this.context, this.loopRegisteries[loop.anchorId]);\n            let content = loop.template.template?.content.cloneNode(true);\n            document.adoptNode(content);\n            customElements.upgrade(content);\n            let actions = loop.template.actions;\n            let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);\n            instance.render();\n            anchor.parentNode?.insertBefore(instance.content, anchor);\n            this.loopRegisteries[loop.anchorId].templates.push(instance);\n        }\n    }\n    resetLoopSimple(anchorId, basePath) {\n        let register = this.loopRegisteries[anchorId];\n        if (register?.unsub) {\n            register.unsub();\n        }\n        this.resetLoopComplex(anchorId);\n    }\n    renderLoopSimple(loop, simple) {\n        let onThis = simple.data.startsWith(\"this.\");\n        let basePath = this.context.normalizePath(simple.data);\n        this.resetLoopSimple(loop.anchorId, basePath);\n        let getElements = () => this.context.getValueFromItem(basePath);\n        let elements = getElements();\n        if (!elements) {\n            let currentPath = basePath;\n            while (currentPath != '' && !elements) {\n                let splittedPath = currentPath.split(\".\");\n                splittedPath.pop();\n                currentPath = splittedPath.join(\".\");\n                elements = this.context.getValueFromItem(currentPath);\n            }\n            if (!elements && onThis) {\n                const splittedPath = basePath.split(\".\");\n                const firstPart = splittedPath.length > 0 ? splittedPath[0] : null;\n                if (firstPart && this.component.__signals[firstPart]) {\n                    elements = this.component.__signals[firstPart];\n                }\n                else {\n                    elements = this.component.__watch;\n                }\n            }\n            if (!elements || !(elements.__isProxy || elements instanceof Signal)) {\n                debugger;\n            }\n            const subTemp = (action, path, value) => {\n                if (basePath.startsWith(path) || path == \"*\") {\n                    elements.unsubscribe(subTemp);\n                    this.renderLoopSimple(loop, simple);\n                    return;\n                }\n            };\n            elements.subscribe(subTemp);\n            return;\n        }\n        let indexName = this.context.registerIndex();\n        let keys = Object.keys(elements);\n        if (elements.__isProxy) {\n            let regexArray = new RegExp(\"^\\\\[(\\\\d+?)\\\\]$\");\n            let regexObject = new RegExp(\"^([^\\\\.]*)$\");\n            let sub = (action, path, value) => {\n                if (path == \"\") {\n                    this.renderLoopSimple(loop, simple);\n                    return;\n                }\n                if (action == WatchAction.UPDATED) {\n                    return;\n                }\n                let index = undefined;\n                regexArray.lastIndex = 0;\n                regexObject.lastIndex = 0;\n                let resultArray = regexArray.exec(path);\n                if (resultArray) {\n                    index = Number(resultArray[1]);\n                }\n                else {\n                    let resultObject = regexObject.exec(path);\n                    if (resultObject) {\n                        let oldKey = resultObject[1];\n                        if (action == WatchAction.CREATED) {\n                            keys = Object.keys(getElements());\n                            index = keys.indexOf(oldKey);\n                        }\n                        else if (action == WatchAction.DELETED) {\n                            index = keys.indexOf(oldKey);\n                            keys = Object.keys(getElements());\n                        }\n                    }\n                }\n                if (index !== undefined) {\n                    let registry = this.loopRegisteries[loop.anchorId];\n                    if (action == WatchAction.CREATED) {\n                        let context = new TemplateContext(this.component, {}, this.context, registry);\n                        context.registerLoop(basePath, index, indexName, simple.index, simple.item, onThis);\n                        let content = loop.template.template?.content.cloneNode(true);\n                        document.adoptNode(content);\n                        customElements.upgrade(content);\n                        let actions = loop.template.actions;\n                        let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);\n                        instance.render();\n                        let anchor;\n                        if (index < registry.templates.length) {\n                            anchor = registry.templates[index].firstChild;\n                        }\n                        else {\n                            anchor = this._components[loop.anchorId][0];\n                        }\n                        anchor?.parentNode?.insertBefore(instance.content, anchor);\n                        registry.templates.splice(index, 0, instance);\n                        for (let i = index + 1; i < registry.templates.length; i++) {\n                            registry.templates[i].context.increaseIndex(indexName);\n                        }\n                    }\n                    else if (action == WatchAction.DELETED) {\n                        registry.templates[index].destructor();\n                        registry.templates.splice(index, 1);\n                        for (let i = index; i < registry.templates.length; i++) {\n                            registry.templates[i].context.decreaseIndex(indexName);\n                        }\n                    }\n                }\n            };\n            this.loopRegisteries[loop.anchorId].unsub = () => {\n                elements.unsubscribe(sub);\n            };\n            elements.subscribe(sub);\n        }\n        let anchor = this._components[loop.anchorId][0];\n        for (let i = 0; i < keys.length; i++) {\n            let context = new TemplateContext(this.component, {}, this.context, this.loopRegisteries[loop.anchorId]);\n            context.registerLoop(basePath, i, indexName, simple.index, simple.item, onThis);\n            let content = loop.template.template?.content.cloneNode(true);\n            document.adoptNode(content);\n            customElements.upgrade(content);\n            let actions = loop.template.actions;\n            let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);\n            instance.render();\n            anchor.parentNode?.insertBefore(instance.content, anchor);\n            this.loopRegisteries[loop.anchorId].templates.push(instance);\n        }\n    }\n    renderIf(_if) {\n        // this.renderIfMemory(_if);\n        this.renderIfRecreate(_if);\n    }\n    renderIfMemory(_if) {\n        let computeds = [];\n        let instances = [];\n        if (!this._components[_if.anchorId] || this._components[_if.anchorId].length == 0)\n            return;\n        let anchor = this._components[_if.anchorId][0];\n        let currentActive = -1;\n        const calculateActive = () => {\n            let newActive = -1;\n            for (let i = 0; i < _if.parts.length; i++) {\n                if (computeds[i].value) {\n                    newActive = i;\n                    break;\n                }\n            }\n            if (newActive == currentActive) {\n                return;\n            }\n            if (currentActive != -1) {\n                let instance = instances[currentActive];\n                let node = instance.firstChild;\n                while (node && node != instance.lastChild) {\n                    let next = node.nextElementSibling;\n                    instance.content.appendChild(node);\n                    node = next;\n                }\n                if (instance.lastChild)\n                    instance.content.appendChild(instance.lastChild);\n            }\n            currentActive = newActive;\n            if (instances[currentActive])\n                anchor.parentNode?.insertBefore(instances[currentActive].content, anchor);\n        };\n        for (let i = 0; i < _if.parts.length; i++) {\n            const part = _if.parts[i];\n            let _class = part.once ? ComputedNoRecomputed : Computed;\n            let computed = new _class(() => {\n                return part.condition(this.context);\n            });\n            computeds.push(computed);\n            computed.subscribe(() => {\n                calculateActive();\n            });\n            this.computeds.push(computed);\n            let context = new TemplateContext(this.component, {}, this.context);\n            let content = part.template.template?.content.cloneNode(true);\n            document.adoptNode(content);\n            customElements.upgrade(content);\n            let actions = part.template.actions;\n            let instance = new TemplateInstance(this.component, content, actions, part.template.loops, part.template.ifs, context);\n            instances.push(instance);\n            instance.render();\n        }\n        calculateActive();\n    }\n    renderIfRecreate(_if) {\n        let computeds = [];\n        if (!this._components[_if.anchorId] || this._components[_if.anchorId].length == 0)\n            return;\n        let anchor = this._components[_if.anchorId][0];\n        let currentActive = undefined;\n        let currentActiveNb = -1;\n        const createContext = () => {\n            if (currentActiveNb < 0 || currentActiveNb > _if.parts.length - 1) {\n                currentActive = undefined;\n                return;\n            }\n            const part = _if.parts[currentActiveNb];\n            let context = new TemplateContext(this.component, {}, this.context);\n            let content = part.template.template?.content.cloneNode(true);\n            document.adoptNode(content);\n            customElements.upgrade(content);\n            let actions = part.template.actions;\n            let instance = new TemplateInstance(this.component, content, actions, part.template.loops, part.template.ifs, context);\n            currentActive = instance;\n            instance.render();\n            anchor.parentNode?.insertBefore(currentActive.content, anchor);\n        };\n        for (let i = 0; i < _if.parts.length; i++) {\n            const part = _if.parts[i];\n            let _class = part.once ? ComputedNoRecomputed : Computed;\n            let computed = new _class(() => {\n                return part.condition(this.context);\n            });\n            computeds.push(computed);\n            computed.subscribe(() => {\n                calculateActive();\n            });\n            this.computeds.push(computed);\n        }\n        const calculateActive = () => {\n            let newActive = -1;\n            for (let i = 0; i < _if.parts.length; i++) {\n                if (computeds[i].value) {\n                    newActive = i;\n                    break;\n                }\n            }\n            if (newActive == currentActiveNb) {\n                return;\n            }\n            if (currentActive) {\n                currentActive.destructor();\n            }\n            currentActiveNb = newActive;\n            createContext();\n        };\n        calculateActive();\n    }\n}\nTemplateInstance.Namespace=`Aventus`;\r\n_.TemplateInstance=TemplateInstance;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Internal","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.Effect","isStrong":false},{"fullName":"Aventus.LoopRegistery","isStrong":false},{"fullName":"Aventus.Loop","isStrong":false},{"fullName":"Aventus.If","isStrong":false},{"fullName":"Aventus.setValueToObject","isStrong":false},{"fullName":"Aventus.ContextEdit","isStrong":false},{"fullName":"Aventus.ComputedNoRecomputed","isStrong":false},{"fullName":"Aventus.Computed","isStrong":false},{"fullName":"Aventus.ActionEvent","isStrong":false},{"fullName":"Aventus.getValueFromObject","isStrong":false},{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.ActionChange","isStrong":false},{"fullName":"Aventus.ActionInjection","isStrong":false},{"fullName":"Aventus.ActionBindings","isStrong":false},{"fullName":"Required","isStrong":false},{"fullName":"Aventus.LoopFct","isStrong":false},{"fullName":"Aventus.LoopSimple","isStrong":false},{"fullName":"Signal","isStrong":false},{"fullName":"Aventus.WatcherFunction","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false}],"fullName":"Aventus.TemplateInstance","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let TemplateContext=class TemplateContext {\n    data = {};\n    comp;\n    computeds = [];\n    watch;\n    registry;\n    isDestroyed = false;\n    constructor(component, data = {}, parentContext, registry) {\n        this.comp = component;\n        this.registry = registry;\n        this.watch = Watcher.get({});\n        let that = this;\n        for (let key in data) {\n            if (data[key].__isProxy) {\n                Object.defineProperty(this.data, key, {\n                    get() {\n                        return data[key];\n                    }\n                });\n            }\n            else {\n                this.watch[key] = data[key];\n                Object.defineProperty(this.data, key, {\n                    get() {\n                        return that.watch[key];\n                    }\n                });\n            }\n        }\n        if (parentContext) {\n            const descriptors = Object.getOwnPropertyDescriptors(parentContext.data);\n            for (let name in descriptors) {\n                Object.defineProperty(this.data, name, {\n                    get() {\n                        return parentContext.data[name];\n                    }\n                });\n            }\n        }\n    }\n    print(value) {\n        return value == null ? \"\" : value + \"\";\n    }\n    registerIndex() {\n        let name = \"index\";\n        let i = 0;\n        let fullName = name + i;\n        while (this.watch[fullName] !== undefined) {\n            i++;\n            fullName = name + i;\n        }\n        return fullName;\n    }\n    registerLoop(dataName, _indexValue, _indexName, indexName, itemName, onThis) {\n        this.watch[_indexName] = _indexValue;\n        let getItems;\n        let mustBeRecomputed = /if|switch|\\?|\\[.+?\\]/g.test(dataName);\n        let _class = mustBeRecomputed ? Computed : ComputedNoRecomputed;\n        if (!onThis) {\n            getItems = new _class(() => {\n                return getValueFromObject(dataName, this.data);\n            });\n        }\n        else {\n            dataName = dataName.replace(/^this\\./, '');\n            getItems = new _class(() => {\n                return getValueFromObject(dataName, this.comp);\n            });\n        }\n        let getIndex = new ComputedNoRecomputed(() => {\n            let items = getItems.value;\n            if (!items)\n                throw 'impossible';\n            let keys = Object.keys(items);\n            let index = keys[_getIndex.value];\n            if (/^[0-9]+$/g.test(index))\n                return Number(index);\n            return index;\n        });\n        let getItem = new ComputedNoRecomputed(() => {\n            let items = getItems.value;\n            if (!items)\n                throw 'impossible';\n            let keys = Object.keys(items);\n            let index = keys[_getIndex.value];\n            let element = items[index];\n            if (element === undefined && (Array.isArray(items) || !items)) {\n                if (this.registry) {\n                    let indexNb = Number(_getIndex.value);\n                    if (!isNaN(indexNb)) {\n                        this.registry.templates[indexNb].destructor();\n                        this.registry.templates.splice(indexNb, 1);\n                        for (let i = indexNb; i < this.registry.templates.length; i++) {\n                            this.registry.templates[i].context.decreaseIndex(_indexName);\n                        }\n                    }\n                }\n            }\n            return element;\n        });\n        let _getIndex = new ComputedNoRecomputed(() => {\n            return this.watch[_indexName];\n        });\n        this.computeds.push(getIndex);\n        this.computeds.push(getItem);\n        this.computeds.push(_getIndex);\n        if (itemName) {\n            Object.defineProperty(this.data, itemName, {\n                get() {\n                    return getItem.value;\n                }\n            });\n        }\n        if (indexName) {\n            Object.defineProperty(this.data, indexName, {\n                get() {\n                    return getIndex.value;\n                }\n            });\n        }\n    }\n    updateIndex(newIndex, _indexName) {\n        // let items: any[] | {};\n        // if(!dataName.startsWith(\"this.\")) {\n        //     let comp = new Computed(() => {\n        //         return getValueFromObject(dataName, this.data);\n        //     });\n        //     fullName = dataName.replace(/^this\\./, '');\n        //     items = getValueFromObject(fullName, this.comp);\n        // if(Array.isArray(items)) {\n        //     let regex = new RegExp(\"^(\" + fullName.replace(/\\./g, \"\\\\.\") + \")\\\\[(\\\\d+?)\\\\]\");\n        //     for(let computed of computeds) {\n        //         for(let cb of computed.callbacks) {\n        //             cb.path = cb.path.replace(regex, \"$1[\" + newIndex + \"]\");\n        //     let oldKey = Object.keys(items)[this.watch[_indexName]]\n        //     let newKey = Object.keys(items)[newIndex]\n        //     let regex = new RegExp(\"^(\" + fullName.replace(/\\./g, \"\\\\.\") + \"\\\\.)(\" + oldKey + \")($|\\\\.)\");\n        //     for (let computed of computeds) {\n        //         for (let cb of computed.callbacks) {\n        //             cb.path = cb.path.replace(regex, \"$1\" + newKey + \"$3\")\n        this.watch[_indexName] = newIndex;\n    }\n    increaseIndex(_indexName) {\n        this.updateIndex(this.watch[_indexName] + 1, _indexName);\n    }\n    decreaseIndex(_indexName) {\n        this.updateIndex(this.watch[_indexName] - 1, _indexName);\n    }\n    destructor() {\n        this.isDestroyed = true;\n        for (let computed of this.computeds) {\n            computed.destroy();\n        }\n        this.computeds = [];\n    }\n    registerWatch(name, value) {\n        let that = this;\n        that.watch[name] = value;\n        Object.defineProperty(that.data, name, {\n            get() {\n                return that.watch[name];\n            }\n        });\n    }\n    updateWatch(name, value, dones) {\n        if (Watcher.is(this.watch[name])) {\n            this.watch[name].__injectedDones(dones);\n        }\n        this.watch[name] = value;\n    }\n    normalizePath(path) {\n        path = path.replace(/^this\\./, '');\n        const regex = /\\[(.*?)\\]/g;\n        let m;\n        while ((m = regex.exec(path)) !== null) {\n            if (m.index === regex.lastIndex) {\n                regex.lastIndex++;\n            }\n            let name = m[1];\n            let result = getValueFromObject(name, this.data);\n            if (result !== undefined) {\n                path = path.replace(m[0], `[${result}]`);\n            }\n        }\n        return path;\n    }\n    getValueFromItem(name) {\n        if (!name)\n            return undefined;\n        let result = getValueFromObject(name, this.data);\n        if (result !== undefined) {\n            return result;\n        }\n        result = getValueFromObject(name, this.comp);\n        if (result !== undefined) {\n            return result;\n        }\n        return undefined;\n    }\n    setValueToItem(name, value) {\n        setValueToObject(name, this.comp, value);\n    }\n}\nTemplateContext.Namespace=`Aventus`;\r\n_.TemplateContext=TemplateContext;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Computed","isStrong":false},{"fullName":"Aventus.LoopRegistery","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.ComputedNoRecomputed","isStrong":false},{"fullName":"Aventus.getValueFromObject","isStrong":false},{"fullName":"RegExpExecArray","isStrong":false},{"fullName":"Aventus.setValueToObject","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false}],"fullName":"Aventus.TemplateContext","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let Template=class Template {\n    static validatePath(path, pathToCheck) {\n        if (pathToCheck.startsWith(path)) {\n            return true;\n        }\n        return false;\n    }\n    cst;\n    constructor(component) {\n        this.cst = component;\n    }\n    htmlParts = [];\n    setHTML(data) {\n        this.htmlParts.push(data);\n    }\n    generateTemplate() {\n        this.template = document.createElement('template');\n        let currentHTML = \"<slot></slot>\";\n        let previousSlots = {\n            default: '<slot></slot>'\n        };\n        for (let htmlPart of this.htmlParts) {\n            for (let blockName in htmlPart.blocks) {\n                if (!previousSlots.hasOwnProperty(blockName)) {\n                    throw \"can't found slot with name \" + blockName;\n                }\n                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);\n            }\n            for (let slotName in htmlPart.slots) {\n                previousSlots[slotName] = htmlPart.slots[slotName];\n            }\n        }\n        this.template.innerHTML = currentHTML;\n    }\n    /**\n     * Used by the for loop and the if\n     * @param template\n     */\n    setTemplate(template) {\n        this.template = document.createElement('template');\n        this.template.innerHTML = template;\n    }\n    template;\n    actions = {};\n    setActions(actions) {\n        if (!this.actions) {\n            this.actions = actions;\n        }\n        else {\n            if (actions.elements) {\n                if (!this.actions.elements) {\n                    this.actions.elements = [];\n                }\n                this.actions.elements = [...actions.elements, ...this.actions.elements];\n            }\n            if (actions.events) {\n                if (!this.actions.events) {\n                    this.actions.events = [];\n                }\n                this.actions.events = [...actions.events, ...this.actions.events];\n            }\n            if (actions.pressEvents) {\n                if (!this.actions.pressEvents) {\n                    this.actions.pressEvents = [];\n                }\n                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];\n            }\n            if (actions.content) {\n                if (!this.actions.content) {\n                    this.actions.content = actions.content;\n                }\n                else {\n                    for (let contextProp in actions.content) {\n                        if (!this.actions.content[contextProp]) {\n                            this.actions.content[contextProp] = actions.content[contextProp];\n                        }\n                        else {\n                            throw 'this should be impossible';\n                        }\n                    }\n                }\n            }\n            if (actions.injection) {\n                if (!this.actions.injection) {\n                    this.actions.injection = actions.injection;\n                }\n                else {\n                    for (let contextProp in actions.injection) {\n                        if (!this.actions.injection[contextProp]) {\n                            this.actions.injection[contextProp] = actions.injection[contextProp];\n                        }\n                        else {\n                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.bindings) {\n                if (!this.actions.bindings) {\n                    this.actions.bindings = actions.bindings;\n                }\n                else {\n                    for (let contextProp in actions.bindings) {\n                        if (!this.actions.bindings[contextProp]) {\n                            this.actions.bindings[contextProp] = actions.bindings[contextProp];\n                        }\n                        else {\n                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };\n                        }\n                    }\n                }\n            }\n            if (actions.contextEdits) {\n                if (!this.actions.contextEdits) {\n                    this.actions.contextEdits = [];\n                }\n                this.actions.contextEdits = [...actions.contextEdits, ...this.actions.contextEdits];\n            }\n        }\n    }\n    loops = [];\n    addLoop(loop) {\n        this.loops.push(loop);\n    }\n    ifs = [];\n    addIf(_if) {\n        this.ifs.push(_if);\n    }\n    createInstance(component) {\n        let content = this.template.content.cloneNode(true);\n        document.adoptNode(content);\n        customElements.upgrade(content);\n        return new TemplateInstance(component, content, this.actions, this.loops, this.ifs);\n    }\n}\nTemplate.Namespace=`Aventus`;\r\n_.Template=Template;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateHTML","isStrong":false},{"fullName":"Aventus.Actions","isStrong":false},{"fullName":"Aventus.Loop","isStrong":false},{"fullName":"Aventus.If","isStrong":false},{"fullName":"Aventus.TemplateInstance","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false}],"fullName":"Aventus.Template","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let WebComponent=class WebComponent extends HTMLElement {\n    /**\n     * Add attributes informations\n     */\n    static get observedAttributes() {\n        return [];\n    }\n    _first;\n    _isReady;\n    /**\n     * Determine if the component is ready (postCreation done)\n     */\n    get isReady() {\n        return this._isReady;\n    }\n    /**\n     * The current namespace\n     */\n    static Namespace = \"\";\n    /**\n     * The current Tag / empty if abstract class\n     */\n    static Tag = \"\";\n    /**\n     * Get the unique type for the data. Define it as the namespace + class name\n     */\n    static get Fullname() { return this.Namespace + \".\" + this.name; }\n    /**\n     * The current namespace\n     */\n    get namespace() {\n        return this.constructor['Namespace'];\n    }\n    /**\n     * Get the name of the component class\n     */\n    getClassName() {\n        return this.constructor.name;\n    }\n    /**\n     * The current tag\n     */\n    get tag() {\n        return this.constructor['Tag'];\n    }\n    /**\n    * Get the unique type for the data. Define it as the namespace + class name\n    */\n    get $type() {\n        return this.constructor['Fullname'];\n    }\n    __onChangeFct = {};\n    __watch;\n    __watchActions = {};\n    __watchActionsCb = {};\n    __watchFunctions = {};\n    __watchFunctionsComputed = {};\n    __pressManagers = [];\n    __signalActions = {};\n    __signals = {};\n    __isDefaultState = true;\n    __defaultActiveState = new Map();\n    __defaultInactiveState = new Map();\n    __statesList = {};\n    constructor() {\n        super();\n        if (this.constructor == WebComponent) {\n            throw \"can't instanciate an abstract class\";\n        }\n        this.__removeNoAnimations = this.__removeNoAnimations.bind(this);\n        if (document.readyState === \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", this.__removeNoAnimations);\n        }\n        this._first = true;\n        this._isReady = false;\n        this.__renderTemplate();\n        this.__registerWatchesActions();\n        this.__registerPropertiesActions();\n        this.__registerSignalsActions();\n        this.__createStates();\n        this.__subscribeState();\n        if (this.constructor == WebComponent) {\n            throw \"can't instanciate an abstract class\";\n        }\n    }\n    /**\n     * Remove all listeners\n     * State + press\n     */\n    destructor() {\n        WebComponentInstance.removeInstance(this);\n        this.__unsubscribeState();\n        for (let press of this.__pressManagers) {\n            press.destroy();\n        }\n        for (let name in this.__watchFunctionsComputed) {\n            this.__watchFunctionsComputed[name].destroy();\n        }\n        for (let name in this.__signals) {\n            this.__signals[name].destroy();\n        }\n        // TODO add missing info for destructor();\n        this.postDestruction();\n        this.destructChildren();\n    }\n    destructChildren() {\n        const recu = (el) => {\n            for (let child of Array.from(el.children)) {\n                if (child instanceof WebComponent) {\n                    child.destructor();\n                }\n                else if (child instanceof HTMLElement) {\n                    recu(child);\n                }\n            }\n            if (el.shadowRoot) {\n                for (let child of Array.from(el.shadowRoot.children)) {\n                    if (child instanceof WebComponent) {\n                        child.destructor();\n                    }\n                    else if (child instanceof HTMLElement) {\n                        recu(child);\n                    }\n                }\n            }\n        };\n        recu(this);\n    }\n    __addWatchesActions(name, fct) {\n        if (!this.__watchActions[name]) {\n            this.__watchActions[name] = [];\n            this.__watchActionsCb[name] = (action, path, value) => {\n                for (let fct of this.__watchActions[name]) {\n                    fct(this, action, path, value);\n                }\n                if (this.__onChangeFct[name]) {\n                    for (let fct of this.__onChangeFct[name]) {\n                        fct(path);\n                    }\n                }\n            };\n        }\n        if (fct) {\n            this.__watchActions[name].push(fct);\n        }\n    }\n    __addWatchesFunctions(infos) {\n        for (let info of infos) {\n            let realName;\n            let autoInit;\n            if (typeof info == \"string\") {\n                realName = info;\n                autoInit = false;\n            }\n            else {\n                realName = info.name;\n                autoInit = info.autoInit;\n            }\n            if (!this.__watchFunctions[realName]) {\n                this.__watchFunctions[realName] = { autoInit };\n            }\n        }\n    }\n    __registerWatchesActions() {\n        if (Object.keys(this.__watchActions).length > 0) {\n            if (!this.__watch) {\n                let defaultValue = {};\n                this.__defaultValuesWatch(defaultValue);\n                this.__watch = Watcher.get(defaultValue, (type, path, element) => {\n                    try {\n                        let action = this.__watchActionsCb[path.split(\".\")[0]] || this.__watchActionsCb[path.split(\"[\")[0]];\n                        action(type, path, element);\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                });\n            }\n        }\n        for (let name in this.__watchFunctions) {\n            this.__watchFunctionsComputed[name] = Watcher.computed(this[name].bind(this));\n            if (this.__watchFunctions[name].autoInit) {\n                this.__watchFunctionsComputed[name].value;\n            }\n        }\n    }\n    __addSignalActions(name, fct) {\n        this.__signalActions[name] = () => {\n            fct(this);\n        };\n    }\n    __registerSignalsActions() {\n        if (Object.keys(this.__signals).length > 0) {\n            const defaultValues = {};\n            for (let name in this.__signals) {\n                this.__registerSignalsAction(name);\n                this.__defaultValuesSignal(defaultValues);\n            }\n            for (let name in defaultValues) {\n                this.__signals[name].value = defaultValues[name];\n            }\n        }\n    }\n    __registerSignalsAction(name) {\n        this.__signals[name] = new Signal(undefined, () => {\n            if (this.__signalActions[name]) {\n                this.__signalActions[name]();\n            }\n        });\n    }\n    __defaultValuesSignal(s) { }\n    __addPropertyActions(name, fct) {\n        if (!this.__onChangeFct[name]) {\n            this.__onChangeFct[name] = [];\n        }\n        if (fct) {\n            this.__onChangeFct[name].push(() => {\n                fct(this);\n            });\n        }\n    }\n    __registerPropertiesActions() { }\n    static __style = ``;\n    static __template;\n    __templateInstance;\n    styleBefore(addStyle) {\n        addStyle(\"@default\");\n    }\n    styleAfter(addStyle) {\n    }\n    __getStyle() {\n        return [WebComponent.__style];\n    }\n    __getHtml() { }\n    __getStatic() {\n        return WebComponent;\n    }\n    static __styleSheets = {};\n    __renderStyles() {\n        let sheets = {};\n        const addStyle = (name) => {\n            let sheet = Style.get(name);\n            if (sheet) {\n                sheets[name] = sheet;\n            }\n        };\n        this.styleBefore(addStyle);\n        let localStyle = new CSSStyleSheet();\n        let styleTxt = this.__getStyle().join(\"\\r\\n\");\n        if (styleTxt.length > 0) {\n            localStyle.replace(styleTxt);\n            sheets['@local'] = localStyle;\n        }\n        this.styleAfter(addStyle);\n        return sheets;\n    }\n    __renderTemplate() {\n        let staticInstance = this.__getStatic();\n        if (!staticInstance.__template || staticInstance.__template.cst != staticInstance) {\n            staticInstance.__template = new Template(staticInstance);\n            this.__getHtml();\n            this.__registerTemplateAction();\n            staticInstance.__template.generateTemplate();\n            staticInstance.__styleSheets = this.__renderStyles();\n        }\n        this.__templateInstance = staticInstance.__template.createInstance(this);\n        let shadowRoot = this.attachShadow({ mode: 'open' });\n        shadowRoot.adoptedStyleSheets = [...Object.values(staticInstance.__styleSheets), Style.noAnimation];\n        shadowRoot.appendChild(this.__templateInstance.content);\n        // customElements.upgrade(shadowRoot);\n        return shadowRoot;\n    }\n    __registerTemplateAction() {\n    }\n    connectedCallback() {\n        if (this._first) {\n            WebComponentInstance.addInstance(this);\n            this._first = false;\n            this.__defaultValues();\n            this.__upgradeAttributes();\n            this.__activateState();\n            this.__templateInstance?.render();\n            this.__removeNoAnimations();\n        }\n        else {\n            setTimeout(() => {\n                this.postConnect();\n            });\n        }\n    }\n    disconnectedCallback() {\n        setTimeout(() => {\n            this.postDisonnect();\n        });\n    }\n    __onReadyCb = [];\n    onReady(cb) {\n        if (this._isReady) {\n            cb();\n        }\n        else {\n            this.__onReadyCb.push(cb);\n        }\n    }\n    __setReady() {\n        this._isReady = true;\n        this.dispatchEvent(new CustomEvent('postCreationDone'));\n        let cbs = [...this.__onReadyCb];\n        for (let cb of cbs) {\n            cb();\n        }\n        this.__onReadyCb = [];\n    }\n    __removeNoAnimations() {\n        if (document.readyState !== \"loading\") {\n            setTimeout(() => {\n                this.postCreation();\n                this.__setReady();\n                this.shadowRoot.adoptedStyleSheets = Object.values(this.__getStatic().__styleSheets);\n                document.removeEventListener(\"DOMContentLoaded\", this.__removeNoAnimations);\n                this.postConnect();\n            }, 50);\n        }\n    }\n    __defaultValues() { }\n    __defaultValuesWatch(w) { }\n    __upgradeAttributes() { }\n    __listBoolProps() {\n        return [];\n    }\n    __upgradeProperty(prop) {\n        let boolProps = this.__listBoolProps();\n        if (boolProps.indexOf(prop) != -1) {\n            if (this.hasAttribute(prop) && (this.getAttribute(prop) === \"true\" || this.getAttribute(prop) === \"\")) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n            else {\n                this.removeAttribute(prop);\n                delete this[prop];\n                this[prop] = false;\n            }\n        }\n        else {\n            if (this.hasAttribute(prop)) {\n                let value = this.getAttribute(prop);\n                delete this[prop];\n                this[prop] = value;\n            }\n            else if (Object.hasOwn(this, prop)) {\n                const value = this[prop];\n                delete this[prop];\n                this[prop] = value;\n            }\n        }\n    }\n    __correctGetter(prop) {\n        if (Object.hasOwn(this, prop)) {\n            const value = this[prop];\n            delete this[prop];\n            this[prop] = value;\n        }\n    }\n    __getStateManager(managerClass) {\n        let mClass;\n        if (managerClass instanceof StateManager) {\n            mClass = managerClass;\n        }\n        else {\n            mClass = Instance.get(managerClass);\n        }\n        return mClass;\n    }\n    __addActiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultActiveState.has(mClass)) {\n            this.__defaultActiveState.set(mClass, []);\n        }\n        this.__defaultActiveState.get(mClass)?.push(cb);\n    }\n    __addInactiveDefState(managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__defaultInactiveState.has(mClass)) {\n            this.__defaultInactiveState.set(mClass, []);\n        }\n        this.__defaultInactiveState.get(mClass)?.push(cb);\n    }\n    __addActiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass)?.active.push(cb);\n    }\n    __addInactiveState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass)?.inactive.push(cb);\n    }\n    __addAskChangeState(statePattern, managerClass, cb) {\n        let mClass = this.__getStateManager(managerClass);\n        this.__statesList[statePattern].get(mClass)?.askChange.push(cb);\n    }\n    __createStates() { }\n    __createStatesList(statePattern, managerClass) {\n        if (!this.__statesList[statePattern]) {\n            this.__statesList[statePattern] = new Map();\n        }\n        let mClass = this.__getStateManager(managerClass);\n        if (!this.__statesList[statePattern].has(mClass)) {\n            this.__statesList[statePattern].set(mClass, {\n                active: [],\n                inactive: [],\n                askChange: []\n            });\n        }\n    }\n    __inactiveDefaultState(managerClass) {\n        if (this.__isDefaultState) {\n            this.__isDefaultState = false;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultInactiveState.has(mClass)) {\n                let fcts = this.__defaultInactiveState.get(mClass) ?? [];\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __activeDefaultState(nextStep, managerClass) {\n        if (!this.__isDefaultState) {\n            for (let pattern in this.__statesList) {\n                if (StateManager.canBeActivate(pattern, nextStep)) {\n                    let mClass = this.__getStateManager(managerClass);\n                    if (this.__statesList[pattern].has(mClass)) {\n                        return;\n                    }\n                }\n            }\n            this.__isDefaultState = true;\n            let mClass = this.__getStateManager(managerClass);\n            if (this.__defaultActiveState.has(mClass)) {\n                let fcts = this.__defaultActiveState.get(mClass) ?? [];\n                for (let fct of fcts) {\n                    fct.bind(this)();\n                }\n            }\n        }\n    }\n    __subscribeState() {\n        if (!this.isReady && this.__stateCleared) {\n            return;\n        }\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                let el = this.__statesList[route].get(managerClass);\n                if (el) {\n                    managerClass.subscribe(route, el, false);\n                }\n            }\n        }\n    }\n    __activateState() {\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                let el = this.__statesList[route].get(managerClass);\n                if (el) {\n                    managerClass.activateAfterSubscribe(route, el);\n                }\n            }\n        }\n    }\n    __stateCleared = false;\n    __unsubscribeState() {\n        for (let route in this.__statesList) {\n            for (const managerClass of this.__statesList[route].keys()) {\n                let el = this.__statesList[route].get(managerClass);\n                if (el) {\n                    managerClass.unsubscribe(route, el);\n                }\n            }\n        }\n        this.__stateCleared = true;\n    }\n    dateToString(d) {\n        if (typeof d == 'string') {\n            d = this.stringToDate(d);\n        }\n        if (d instanceof Date) {\n            return new Date(d.getTime() - (d.getTimezoneOffset() * 60000)).toISOString().split(\"T\")[0];\n        }\n        return null;\n    }\n    dateTimeToString(dt) {\n        if (typeof dt == 'string') {\n            dt = this.stringToDate(dt);\n        }\n        if (dt instanceof Date) {\n            return new Date(dt.getTime() - (dt.getTimezoneOffset() * 60000)).toISOString().slice(0, -1);\n        }\n        return null;\n    }\n    stringToDate(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    stringToDateTime(s) {\n        let td = new Date(s);\n        let d = new Date(td.getTime() + (td.getTimezoneOffset() * 60000));\n        if (isNaN(d)) {\n            return null;\n        }\n        return d;\n    }\n    getBoolean(val) {\n        if (val === true || val === 1 || val === 'true' || val === '') {\n            return true;\n        }\n        else if (val === false || val === 0 || val === 'false' || val === null || val === undefined) {\n            return false;\n        }\n        console.error(\"error parsing boolean value \" + val);\n        return false;\n    }\n    __registerPropToWatcher(name) {\n        if (Watcher._register) {\n            Watcher._register.register(this.getReceiver(name), name, Watcher._register.version, name);\n        }\n    }\n    getStringAttr(name) {\n        return this.getAttribute(name)?.replace(/&avquot;/g, '\"') ?? undefined;\n    }\n    setStringAttr(name, val) {\n        if (val === undefined || val === null) {\n            this.removeAttribute(name);\n        }\n        else {\n            this.setAttribute(name, (val + \"\").replace(/\"/g, '&avquot;'));\n        }\n    }\n    getStringProp(name) {\n        this.__registerPropToWatcher(name);\n        return this.getStringAttr(name);\n    }\n    getNumberAttr(name) {\n        return Number(this.getAttribute(name));\n    }\n    setNumberAttr(name, val) {\n        if (val === undefined || val === null) {\n            this.removeAttribute(name);\n        }\n        else {\n            this.setAttribute(name, val);\n        }\n    }\n    getNumberProp(name) {\n        this.__registerPropToWatcher(name);\n        return this.getNumberAttr(name);\n    }\n    getBoolAttr(name) {\n        return this.hasAttribute(name);\n    }\n    setBoolAttr(name, val) {\n        val = this.getBoolean(val);\n        if (val) {\n            this.setAttribute(name, 'true');\n        }\n        else {\n            this.removeAttribute(name);\n        }\n    }\n    getBoolProp(name) {\n        this.__registerPropToWatcher(name);\n        return this.getBoolAttr(name);\n    }\n    getDateAttr(name) {\n        if (!this.hasAttribute(name)) {\n            return undefined;\n        }\n        return this.stringToDate(this.getAttribute(name));\n    }\n    setDateAttr(name, val) {\n        let valTxt = this.dateToString(val);\n        if (valTxt === null) {\n            this.removeAttribute(name);\n        }\n        else {\n            this.setAttribute(name, valTxt);\n        }\n    }\n    getDateProp(name) {\n        this.__registerPropToWatcher(name);\n        return this.getDateAttr(name);\n    }\n    getDateTimeAttr(name) {\n        if (!this.hasAttribute(name))\n            return undefined;\n        return this.stringToDateTime(this.getAttribute(name));\n    }\n    setDateTimeAttr(name, val) {\n        let valTxt = this.dateTimeToString(val);\n        if (valTxt === null) {\n            this.removeAttribute(name);\n        }\n        else {\n            this.setAttribute(name, valTxt);\n        }\n    }\n    getDateTimeProp(name) {\n        this.__registerPropToWatcher(name);\n        return this.getDateTimeAttr(name);\n    }\n    __propertyReceivers = {};\n    getReceiver(name) {\n        if (!this.__propertyReceivers[name]) {\n            let that = this;\n            let result = {\n                __subscribes: [],\n                subscribe(fct) {\n                    let index = this.__subscribes.indexOf(fct);\n                    if (index == -1) {\n                        this.__subscribes.push(fct);\n                    }\n                },\n                unsubscribe(fct) {\n                    let index = this.__subscribes.indexOf(fct);\n                    if (index > -1) {\n                        this.__subscribes.splice(index, 1);\n                    }\n                },\n                onChange() {\n                    for (let fct of this.__subscribes) {\n                        fct(WatchAction.UPDATED, name, that[name]);\n                    }\n                },\n                __path: name\n            };\n            this.__propertyReceivers[name] = result;\n        }\n        return this.__propertyReceivers[name];\n    }\n    attributeChangedCallback(name, oldValue, newValue) {\n        if (oldValue !== newValue || !this.isReady) {\n            if (this.__propertyReceivers.hasOwnProperty(name)) {\n                this.__propertyReceivers[name].onChange();\n            }\n            if (this.__onChangeFct.hasOwnProperty(name)) {\n                for (let fct of this.__onChangeFct[name]) {\n                    fct('');\n                }\n            }\n        }\n    }\n    /**\n     * Remove a component from the dom\n     * If desctruct is set to true, the component will be fully destroyed\n     */\n    remove(destruct = true) {\n        super.remove();\n        if (destruct) {\n            this.destructor();\n        }\n    }\n    /**\n     * Function triggered when the component is destroyed\n     */\n    postDestruction() { }\n    /**\n     * Function triggered the first time the component is rendering inside DOM\n     */\n    postCreation() { }\n    /**\n    * Function triggered each time the component is rendering inside DOM\n    */\n    postConnect() { }\n    /**\n    * Function triggered each time the component is removed from the DOM\n    */\n    postDisonnect() { }\n    /**\n     * Find a parent by tagname if exist\n     */\n    findParentByTag(tagname, untilNode) {\n        return ElementExtension.findParentByTag(this, tagname, untilNode);\n    }\n    /**\n     * Find a parent by class name if exist\n     */\n    findParentByClass(classname, untilNode) {\n        return ElementExtension.findParentByClass(this, classname, untilNode);\n    }\n    /**\n     * Find a parent by type if exist\n     */\n    findParentByType(type, untilNode) {\n        return ElementExtension.findParentByType(this, type, untilNode);\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    findParentsByTag(tagname, untilNode) {\n        return ElementExtension.findParentsByTag(this, tagname, untilNode);\n    }\n    /**\n     * Find list of parents by custom check\n     */\n    findParents(tagname, check, untilNode) {\n        return ElementExtension.findParents(this, check, untilNode);\n    }\n    /**\n     * Find list of parents by custom check\n     */\n    findParent(tagname, check, untilNode) {\n        return ElementExtension.findParent(this, check, untilNode);\n    }\n    /**\n     * Check if element contains a child\n     */\n    containsChild(el) {\n        return ElementExtension.containsChild(this, el);\n    }\n    /**\n     * Get elements inside slot\n     */\n    getElementsInSlot(slotName) {\n        return ElementExtension.getElementsInSlot(this, slotName);\n    }\n    /**\n     * Get nodes inside slot\n     */\n    getNodesInSlot(slotName) {\n        return ElementExtension.getNodesInSlot(this, slotName);\n    }\n    /**\n     * Get active element from the shadowroot or the document\n     */\n    getActiveElement(document) {\n        return ElementExtension.getActiveElement(document ?? this.shadowRoot);\n    }\n}\nWebComponent.Namespace=`Aventus`;\r\n_.WebComponent=WebComponent;\r\n","dependances":[{"fullName":"Aventus.DefaultComponent","isStrong":true},{"fullName":"Storybook","isStrong":false},{"fullName":"Dependances","isStrong":false},{"fullName":"Aventus.WebComponentInstance","isStrong":false},{"fullName":"Internal","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false},{"fullName":"Aventus.Computed","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.Signal","isStrong":false},{"fullName":"Map","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Aventus.State","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.Watcher","isStrong":false},{"fullName":"Aventus.Template","isStrong":true},{"fullName":"Aventus.TemplateInstance","isStrong":false},{"fullName":"CSSStyleSheet","isStrong":true},{"fullName":"Aventus.Style","isStrong":false},{"fullName":"Aventus.Instance","isStrong":false},{"fullName":"Date","isStrong":false},{"fullName":"Aventus.EffectReceiver","isStrong":false},{"fullName":"Aventus.WatcherChange","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.ElementExtension","isStrong":false}],"fullName":"Aventus.WebComponent","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let WebComponentInstance=class WebComponentInstance {\n    static __allDefinitions = [];\n    static __allInstances = [];\n    /**\n     * Last definition insert datetime\n     */\n    static lastDefinition = 0;\n    static registerDefinition(def) {\n        WebComponentInstance.lastDefinition = Date.now();\n        WebComponentInstance.__allDefinitions.push(def);\n    }\n    static removeDefinition(def) {\n        WebComponentInstance.lastDefinition = Date.now();\n        let index = WebComponentInstance.__allDefinitions.indexOf(def);\n        if (index > -1) {\n            WebComponentInstance.__allDefinitions.splice(index, 1);\n        }\n    }\n    /**\n     * Get all sub classes of type\n     */\n    static getAllClassesOf(type) {\n        let result = [];\n        for (let def of WebComponentInstance.__allDefinitions) {\n            if (def.prototype instanceof type) {\n                result.push(def);\n            }\n        }\n        return result;\n    }\n    /**\n     * Get all registered definitions\n     */\n    static getAllDefinitions() {\n        return WebComponentInstance.__allDefinitions;\n    }\n    static addInstance(instance) {\n        this.__allInstances.push(instance);\n    }\n    static removeInstance(instance) {\n        let index = this.__allInstances.indexOf(instance);\n        if (index > -1) {\n            this.__allInstances.splice(index, 1);\n        }\n    }\n    static getAllInstances(type) {\n        let result = [];\n        for (let instance of this.__allInstances) {\n            if (instance instanceof type) {\n                result.push(instance);\n            }\n        }\n        return result;\n    }\n    static create(type) {\n        let _class = customElements.get(type);\n        if (_class) {\n            return new _class();\n        }\n        let splitted = type.split(\".\");\n        let current = window;\n        for (let part of splitted) {\n            current = current[part];\n        }\n        if (current && current.prototype instanceof WebComponent) {\n            return new current();\n        }\n        return null;\n    }\n}\nWebComponentInstance.Namespace=`Aventus`;\r\n_.WebComponentInstance=WebComponentInstance;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":true},{"fullName":"T","isStrong":false}],"fullName":"Aventus.WebComponentInstance","required":false,"type":1,"isExported":true,"convertibleName":""},{"code":"let ElementExtension=class ElementExtension {\n    /**\n     * Find a parent by custom check\n     */\n    static findParent(element, check, untilNode) {\n        let el = element;\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (check(el)) {\n                return el;\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a list of parent by custom check\n     */\n    static findParents(element, check, untilNode) {\n        let result = [];\n        let el = element;\n        if (el) {\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n        }\n        while (el) {\n            if (check(el)) {\n                result.push(el);\n            }\n            if (el instanceof ShadowRoot) {\n                el = el.host;\n            }\n            else {\n                el = el.parentNode;\n            }\n            if (el == untilNode) {\n                break;\n            }\n        }\n        return result;\n    }\n    /**\n     * Find a parent by tagname if exist Static.findParentByTag(this, \"av-img\")\n     */\n    static findParentByTag(element, tagname, untilNode) {\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        const checkFunc = (el) => {\n            return tagname.indexOf((el.nodeName || el.tagName).toLowerCase()) != -1;\n        };\n        return this.findParent(element, checkFunc, untilNode);\n    }\n    /**\n     * Find a parent by class name if exist Static.findParentByClass(this, \"my-class-img\") = querySelector('.my-class-img')\n     */\n    static findParentByClass(element, classname, untilNode) {\n        if (!Array.isArray(classname)) {\n            classname = [classname];\n        }\n        const check = (el) => {\n            for (let classnameTemp of classname) {\n                if (el['classList'] && el['classList'].contains(classnameTemp)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        return this.findParent(element, check, untilNode);\n    }\n    static findParentByType(element, types, untilNode) {\n        if (!Array.isArray(types)) {\n            types = [types];\n        }\n        let isValid = true;\n        for (let type of types) {\n            if (typeof type == \"function\" && type['prototype']['constructor'])\n                continue;\n            isValid = false;\n        }\n        if (isValid) {\n            let checkFunc = (el) => {\n                for (let type of types) {\n                    const t = type;\n                    if (el instanceof t) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            return this.findParent(element, checkFunc, untilNode);\n        }\n        console.error(\"you must provide a class inside this function\");\n        return null;\n    }\n    /**\n     * Find list of parents by tagname\n     */\n    static findParentsByTag(element, tagname, untilNode) {\n        let el = element;\n        if (Array.isArray(tagname)) {\n            for (let i = 0; i < tagname.length; i++) {\n                tagname[i] = tagname[i].toLowerCase();\n            }\n        }\n        else {\n            tagname = [tagname.toLowerCase()];\n        }\n        let check = (el) => {\n            return tagname.indexOf((el.nodeName || el['tagName']).toLowerCase()) != -1;\n        };\n        return this.findParents(element, check, untilNode);\n    }\n    /**\n     * Check if element contains a child\n     */\n    static containsChild(element, child) {\n        var rootScope = element.getRootNode();\n        var elScope = child.getRootNode();\n        while (elScope != rootScope) {\n            if (!elScope['host']) {\n                return false;\n            }\n            child = elScope['host'];\n            elScope = elScope['host'].getRootNode();\n        }\n        return element.contains(child);\n    }\n    /**\n     * Get element inside slot\n     */\n    static getElementsInSlot(element, slotName) {\n        let result = [];\n        if (element.shadowRoot) {\n            let slotEl;\n            if (slotName) {\n                slotEl = element.shadowRoot.querySelector('slot[name=\"' + slotName + '\"]');\n            }\n            else {\n                slotEl = element.shadowRoot.querySelector(\"slot:not([name])\");\n                if (!slotEl) {\n                    slotEl = element.shadowRoot.querySelector(\"slot\");\n                }\n            }\n            while (true) {\n                if (!slotEl) {\n                    return result;\n                }\n                var listChild = Array.from(slotEl.assignedElements());\n                if (!listChild) {\n                    return result;\n                }\n                let slotFound = false;\n                for (let i = 0; i < listChild.length; i++) {\n                    let child = listChild[i];\n                    if (listChild[i].nodeName == \"SLOT\") {\n                        slotEl = listChild[i];\n                        slotFound = true;\n                    }\n                    else if (child instanceof HTMLElement) {\n                        result.push(child);\n                    }\n                }\n                if (!slotFound) {\n                    return result;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Get element inside slot\n     */\n    static getNodesInSlot(element, slotName) {\n        let result = [];\n        if (element.shadowRoot) {\n            let slotEl;\n            if (slotName) {\n                slotEl = element.shadowRoot.querySelector('slot[name=\"' + slotName + '\"]');\n            }\n            else {\n                slotEl = element.shadowRoot.querySelector(\"slot:not([name])\");\n                if (!slotEl) {\n                    slotEl = element.shadowRoot.querySelector(\"slot\");\n                }\n            }\n            while (true) {\n                if (!slotEl) {\n                    return result;\n                }\n                var listChild = Array.from(slotEl.assignedNodes());\n                if (!listChild) {\n                    return result;\n                }\n                let slotFound = false;\n                for (let i = 0; i < listChild.length; i++) {\n                    let child = listChild[i];\n                    if (listChild[i].nodeName == \"SLOT\") {\n                        slotEl = listChild[i];\n                        slotFound = true;\n                    }\n                    else if (child instanceof Node) {\n                        result.push(child);\n                    }\n                }\n                if (!slotFound) {\n                    return result;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Get deeper element inside dom at the position X and Y\n     */\n    static getElementAtPosition(x, y, startFrom) {\n        var _realTarget = (el, i = 0) => {\n            if (i == 50) {\n                debugger;\n            }\n            if (el.shadowRoot && x !== undefined && y !== undefined) {\n                const elements = el.shadowRoot.elementsFromPoint(x, y);\n                var newEl = elements.length > 0 ? elements[0] : null;\n                if (newEl && newEl != el && (el.shadowRoot.contains(newEl) || el.contains(newEl))) {\n                    return _realTarget(newEl, i + 1);\n                }\n            }\n            return el;\n        };\n        if (startFrom == null) {\n            startFrom = document.body;\n        }\n        return _realTarget(startFrom);\n    }\n    /**\n     * Get active element from the define root\n     */\n    static getActiveElement(root = document) {\n        if (!root)\n            return null;\n        let el = root.activeElement;\n        while (el instanceof WebComponent) {\n            let elTemp = el.shadowRoot?.activeElement;\n            if (!elTemp)\n                return el;\n            el = elTemp;\n        }\n        return el;\n    }\n}\nElementExtension.Namespace=`Aventus`;\r\n_.ElementExtension=ElementExtension;\r\n","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"ShadowRoot","isStrong":false},{"fullName":"Aventus.WebComponent","isStrong":false}],"fullName":"Aventus.ElementExtension","required":false,"type":1,"isExported":true,"convertibleName":""}],"existing":[{"fullName":"Aventus.DebuggerConfig","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.ActionBindings","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false}]},{"fullName":"Aventus.ActionInjection","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false}]},{"fullName":"Aventus.ActionEventCallback","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false}]},{"fullName":"Aventus.ActionEventListener","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false}]},{"fullName":"Aventus.ContextEdit","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false}]},{"fullName":"Aventus.If","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false},{"fullName":"Aventus.Template","isStrong":false}]},{"fullName":"Aventus.LoopSimple","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.LoopFct","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.TemplateHTML","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.DefaultComponent","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.StringLiteral","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.Constructor","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.OnlyConstructor","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.AnyConstructor","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.OnlyConstructor","isStrong":false}]},{"fullName":"Aventus.RamSubscribers","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.KeysObject","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.IRam","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.UriParamsValue","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.StateSlug","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.UriParamsValue","isStrong":false}]},{"fullName":"Aventus.StateAskChangeFct","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.State","isStrong":false}]},{"fullName":"Aventus.StateInactivationFct","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Aventus.State","isStrong":false}]},{"fullName":"Aventus.UriParams","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.ResourceLoaderHeadOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.ResourceLoaderOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.WindowResizeObserver","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"globalThis.ResizeObserver","isStrong":false}]},{"fullName":"Aventus.ResizeObserverOptions","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"CallableFunction","isStrong":false}]},{"fullName":"Aventus.Pointer","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Touch","isStrong":false}]},{"fullName":"Aventus.PressManagerState","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false}]},{"fullName":"Aventus.Coordinate","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.InternalCustomFunction","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false},{"fullName":"Aventus.NormalizedEvent","isStrong":false}]},{"fullName":"Aventus.InternalPointerEvent","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.PressManagerState","isStrong":false},{"fullName":"Aventus.InternalCustomFunction","isStrong":false},{"fullName":"Aventus.NormalizedEvent","isStrong":false}]},{"fullName":"Aventus.PressManagerOptions","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.NormalizedEvent","isStrong":false},{"fullName":"Aventus.PressManager","isStrong":false}]},{"fullName":"Aventus.TargetableElement","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.DragElementLeftTop","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"InstanceType","isStrong":false}]},{"fullName":"Aventus.DragElementXY","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"InstanceType","isStrong":false}]},{"fullName":"Aventus.ContainerElement","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.AnyElement","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TargetableElement","isStrong":false},{"fullName":"Aventus.ContainerElement","isStrong":false}]},{"fullName":"Aventus.AnimationOptionsInternal","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.AnimationOptions","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Partial","isStrong":false},{"fullName":"Aventus.AnimationOptionsInternal","isStrong":false}]},{"fullName":"Aventus.RouterOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.HttpRouterOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.IsNotVoid","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.WatcherFunctionInternal","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}]},{"fullName":"Aventus.WatcherFunction","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}]},{"fullName":"Aventus.WatcherAllowed","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}]},{"fullName":"Aventus.Asyncable","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Promise","isStrong":false}]},{"fullName":"Aventus.Enum","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.EnumValue","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Enum","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.ClassCopyOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.SchemaType","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.JsonFromOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.JsonToOptions","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.IData","dependances":[{"fullName":"Storybook","isStrong":false}]},{"fullName":"Aventus.Schema","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.SchemaType","isStrong":false}]},{"fullName":"Aventus.IConverterTransform","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Object","isStrong":false},{"fullName":"Aventus.ClassCopyOptions","isStrong":false}]},{"fullName":"Aventus.ExtractFromError","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"U","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false}]},{"fullName":"Aventus.HttpRequestOptions","dependances":[{"fullName":"Aventus.HttpRequest","isStrong":false},{"fullName":"Aventus.Asyncable","isStrong":false},{"fullName":"Aventus.VoidWithError","isStrong":false},{"fullName":"Aventus.ResultWithError","isStrong":false},{"fullName":"T","isStrong":false}]},{"fullName":"Aventus.WatcherChange","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.WatchAction","isStrong":false}]},{"fullName":"Aventus.EffectReceiver","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.WatcherChange","isStrong":false}]},{"fullName":"Aventus.RouterType","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.HttpRouter","isStrong":false}]},{"fullName":"Aventus.RouteType","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.HttpRoute","isStrong":false}]},{"fullName":"Aventus.DragElement","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.DragElementXY","isStrong":false},{"fullName":"Aventus.DragElementLeftTop","isStrong":false}]},{"fullName":"Aventus.DragAndDropOptionsShadow","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.ContainerElement","isStrong":false},{"fullName":"Aventus.DragElement","isStrong":false}]},{"fullName":"Aventus.DragAndDropOptions","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.DragElement","isStrong":false},{"fullName":"Aventus.DragAndDropOptionsShadow","isStrong":false},{"fullName":"Aventus.TargetableElement","isStrong":false},{"fullName":"Aventus.NormalizedEvent","isStrong":false},{"fullName":"Aventus.Coordinate","isStrong":false}]},{"fullName":"Aventus.DragAndDropOptionsInternal","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Required","isStrong":false},{"fullName":"Aventus.DragAndDropOptions","isStrong":false},{"fullName":"Aventus.DragAndDropOptionsShadow","isStrong":false}]},{"fullName":"Aventus.PreparedUri","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"RegExp","isStrong":false},{"fullName":"Aventus.UriParams","isStrong":false}]},{"fullName":"Aventus.IRamAction","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.KeysObject","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.ResultRamWithError","isStrong":false},{"fullName":"Aventus.VoidRamWithError","isStrong":false}]},{"fullName":"Aventus.RamItem","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.IData","isStrong":false},{"fullName":"T","isStrong":false},{"fullName":"Aventus.IRamAction","isStrong":false}]},{"fullName":"Aventus.StateActivationFct","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateSlug","isStrong":false},{"fullName":"Aventus.State","isStrong":false}]},{"fullName":"Aventus.Subscriber","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"RegExp","isStrong":false},{"fullName":"Aventus.StateActivationFct","isStrong":false},{"fullName":"Aventus.StateInactivationFct","isStrong":false},{"fullName":"Aventus.StateAskChangeFct","isStrong":false}]},{"fullName":"Aventus.StateAction","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateActivationFct","isStrong":false},{"fullName":"Aventus.StateInactivationFct","isStrong":false},{"fullName":"Aventus.StateAskChangeFct","isStrong":false}]},{"fullName":"Aventus.IStateManager","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateAction","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.UriParamsValue","isStrong":false},{"fullName":"Aventus.State","isStrong":false}]},{"fullName":"Aventus.IState","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.StateManager","isStrong":false},{"fullName":"Promise","isStrong":false},{"fullName":"Aventus.State","isStrong":false}]},{"fullName":"Aventus.Loop","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.Template","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false},{"fullName":"Aventus.LoopFct","isStrong":false},{"fullName":"Aventus.LoopSimple","isStrong":false}]},{"fullName":"Aventus.ActionEvent","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.ActionEventListener","isStrong":false},{"fullName":"Aventus.ActionEventCallback","isStrong":false}]},{"fullName":"Aventus.LoopRegistery","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateInstance","isStrong":false},{"fullName":"Aventus.Computed","isStrong":false}]},{"fullName":"Aventus.ActionChange","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.TemplateContext","isStrong":false}]},{"fullName":"Aventus.Actions","dependances":[{"fullName":"Storybook","isStrong":false},{"fullName":"Aventus.ActionChange","isStrong":false},{"fullName":"Aventus.ActionInjection","isStrong":false},{"fullName":"Aventus.ActionBindings","isStrong":false},{"fullName":"Aventus.ActionEvent","isStrong":false},{"fullName":"Aventus.PressManagerOptions","isStrong":false},{"fullName":"Aventus.ContextEdit","isStrong":false}]}]}
//#endregion js src //
//#region css def //
{}
//#endregion css def //
//#region css //
{}
//#endregion css //
//#region html //
{}
//#endregion html //
//#region dependances //
[]
//#endregion dependances //
