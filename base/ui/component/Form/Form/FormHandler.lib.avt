import { type Constructor, type FormHandlerConfig, type FormPart, type FormPartValidate, type FormSchema, type FormValidate, type FormValidateResult, type IFormElement, type InternalForm, type InternalFormPart, type WithError } from "./FormType.lib.avt";
import { Validator } from "./Validator.lib.avt";

namespace Form {


    export class FormHandler<T> {

        @Internal()
        public static _globalConfig?: FormHandlerConfig<any>;

        private __watcher: any;

        public get item(): T | undefined {
            return this.__watcher.item;
        }

        public set item(item: T | undefined) {
            this.__watcher.item = item;
        }

        public get parts(): InternalForm<T> {
            return this.__watcher.form;
        }

        private _elements: { [K in keyof T]?: IFormElement[]; } = {};

        public get elements(): { [K in keyof T]?: IFormElement[]; } {
            return { ...this._elements };
        }
        private _globalValidation?: FormValidate;
        private _validateOnChange: boolean = false;
        private _handleValidateNoInputError?: (errors: { [K in keyof T]?: string[]; }) => any;
        private _handleExecuteNoInputError?: (errors: Aventus.GenericError[]) => any;


        public onItemChange: Aventus.Callback<(action: Aventus.WatchAction, path: string, value: any) => void> = new Aventus.Callback();


        public constructor(schema: FormSchema<T>, config?: FormHandlerConfig<T>) {
            this._globalValidation = config?.validate ?? FormHandler._globalConfig?.validate;
            this._validateOnChange = config?.validateOnChange ?? FormHandler._globalConfig?.validateOnChange ?? false;
            this._handleValidateNoInputError = config?.handleValidateNoInputError ?? FormHandler._globalConfig?.handleValidateNoInputError;
            this._handleExecuteNoInputError = config?.handleExecuteNoInputError ?? FormHandler._globalConfig?.handleExecuteNoInputError;

            this.onWatcherChanged = this.onWatcherChanged.bind(this);
            this.__watcher = Aventus.Watcher.get({
                form: {}
            }, this.onWatcherChanged);

            this.__watcher.form = this.transformForm(schema);
        }


        protected transformForm(form: FormSchema<T>): InternalForm<T> {
            const result = form as InternalForm<T>;
            const normalizePart = (part: FormSchema<T>[keyof T]) => {
                let needTransform = true;
                if(typeof part == 'object' && !Array.isArray(part)) {
                    const keys = Object.keys(part);
                    const keysAllows: (keyof FormPart)[] = ['validate', 'validateOnChange'];
                    let isValid = true;
                    for(let i = 0; i < keys.length; i++) {
                        const allows = keysAllows as string[];
                        if(!allows.includes(keys[i])) {
                            isValid = false;
                            break;
                        }
                    }
                    if(isValid) {
                        needTransform = false;
                    }
                }

                if(needTransform) {
                    return {
                        validate:part
                    } as FormPart<T[keyof T]>
                }
                return part as FormPart<T[keyof T]>
            }
            const createKey = (key: keyof T) => {
                form[key] = normalizePart(form[key]);
                this.transformFormPart(key, form[key]);
            };
            for(let key in result) {
                createKey(key);
            }
            return result;
        }
        protected transformFormPart(key: keyof T, part: FormPart | undefined) {
            if(!part) return;

            const realPart = part as InternalFormPart;
            realPart.onValidation = new Aventus.Callback();
            realPart.onValueChange = new Aventus.Callback();
            if(part.validate) {
                const isValidate = (validate: FormPartValidate<T> | Constructor<Validator<any>>): validate is FormPartValidate<any> => {
                    return validate.name == "validate";
                };
                let validate: FormPartValidate<any>;
                if(Array.isArray(part.validate)) {
                    const fcts: FormPartValidate<any>[] = [];
                    for(let temp of part.validate) {
                        if(temp instanceof Validator) {
                            fcts.push(temp.validate);
                        }
                        else {
                            let resultTemp = new temp();
                            fcts.push(resultTemp.validate);
                        }
                    }
                    validate = async (value, name, globalFct) => {
                        let result: string[] = [];
                        for(let fct of fcts) {
                            const temp = await fct(value, name, globalFct);
                            if(temp === false) {
                                result.push('Le champs n\'est pas valide');
                            }
                            else if(Array.isArray(temp)) {
                                for(let error of temp) {
                                    result.push(error);
                                }
                            }
                            else if(typeof temp == 'string') {
                                result.push(temp);
                            }
                        }
                        return result.length == 0 ? undefined : result;
                    };
                }
                else if(part.validate instanceof Validator) {
                    validate = part.validate.validate;
                }
                else if(isValidate(part.validate)) {
                    validate = part.validate;
                }
                else {
                    let cst = part.validate;
                    let resultTemp = new cst() as Validator<any>;
                    validate = resultTemp.validate;
                }
                realPart.validate = validate;
            }
            realPart.test = async () => {
                const result = await this.validate(key);
                return result;
            };
            if(!this._elements[key]) {
                this._elements[key] = [];
            }
            realPart.register = (el) => {
                if(this._elements[key] && !this._elements[key].includes(el)) {
                    this._elements[key].push(el);
                }
            };
            realPart.unregister = (el) => {
                if(!this._elements[key]) return;
                const index = this._elements[key].indexOf(el);
                if(index != -1) {
                    this._elements[key].splice(index, 1);
                }
            };
            realPart.value = {
                get: () => {
                    return Aventus.getValueFromObject(key as string, this.item);
                },
                set: (value: any) => {
                    return Aventus.setValueToObject(key as string, this.item, value);
                }
            };
            return
        }



        protected async onWatcherChanged(action: Aventus.WatchAction, path: string, value: any) {
            if(!this.parts) return;
            if(path == "item") {
                for(let key in this.parts) {
                    let formPart = this.parts[key] as InternalFormPart;
                    formPart.onValueChange.trigger();
                }
            }
            else if(path.startsWith("item.")) {
                let key = path.substring("item.".length);
                if(this.parts[key]) {
                    let formPart = this.parts[key] as InternalFormPart;
                    formPart.onValueChange.trigger();
                    const validateOnChange = formPart.validateOnChange === undefined ? this._validateOnChange : formPart.validateOnChange;
                    if(validateOnChange) {
                        this.validate(key as keyof T);
                    }
                }
                this.onItemChange.trigger(action, key, value);
            }
        }
        private async _validate(key: keyof T | undefined): Promise<{ [key: string]: string[]; }> {
            try {
                if(!this.parts) return { "@general": ["Aucun formulaire trouvÃ©"] };

                if(key !== undefined) {
                    let errorsForm: string[] = [];
                    if(this.parts[key]) {
                        let formPart = this.parts[key] as InternalFormPart;
                        let value = formPart.value.get();

                        const resultToError = (result: FormValidateResult) => {
                            if(result === false) {
                                errorsForm.push('Le champs n\'est pas valide');
                            }
                            else if(typeof result == 'string' && result !== "") {
                                errorsForm.push(result);
                            }
                            else if(Array.isArray(result)) {
                                errorsForm = [...errorsForm, ...result];
                            }
                        };

                        if(formPart.validate) {
                            const global = async () => {
                                if(this._globalValidation) {
                                    const result = await this._globalValidation(key as string, value);
                                    resultToError(result);
                                }
                            };

                            let result = await formPart.validate(value, key as string, global);
                            resultToError(result);


                        }
                        else if(this._globalValidation) {
                            const result = await this._globalValidation(key as string, value);
                            resultToError(result);
                        }

                        const proms = formPart.onValidation.trigger(errorsForm);
                        const errors2d = await Promise.all(proms);
                        const errors: string[] = [];
                        for(let errorsTemp of errors2d) {
                            for(let errorTemp of errorsTemp) {
                                if(!errors.includes(errorTemp)) {
                                    errors.push(errorTemp);
                                }
                            }
                        }
                        errorsForm = errors;
                    }
                    return errorsForm.length == 0 ? {} : { [key]: errorsForm };
                }

                let errors: { [key: string]: string[]; } = {};
                for(let key in this.parts) {
                    errors = { ...errors, ...await this._validate(key) };
                }

                return errors;
            } catch(e) {
                return { "@general": [e + ""] };
            }
        }

        public async validate(key: keyof T): Promise<boolean>;
        public async validate(): Promise<boolean>;
        public async validate(key?: keyof T): Promise<boolean> {
            const result = await this._validate(key);
            const unhandle: { [K in keyof T]?: string[]; } = {};
            let triggerUnhandle = false;
            for(let key in result) {
                // si on ne trouve pas de formElement, on affiche un message
                if(!this._elements[key] || this._elements[key].length == 0) {
                    triggerUnhandle = true;
                    unhandle[key] = result[key];
                }
            }

            if(triggerUnhandle && this._handleValidateNoInputError) {
                this._handleValidateNoInputError(unhandle);
            }

            return Object.keys(result).length == 0;
        }

        public async execute<X>(query: Aventus.Asyncable<WithError<X>>): Promise<WithError<X>> {
            let queryResult = await query;

            if(queryResult.errors.length > 0) {
                queryResult.errors = this.parseErrors(queryResult);
                if(queryResult.errors.length > 0 && this._handleExecuteNoInputError) {
                    this._handleExecuteNoInputError(queryResult.errors);
                }
            }
            return queryResult;
        }

        public parseErrors<X>(queryResult: WithError<X>): Aventus.GenericError[] {
            let noPrintErrors: Aventus.GenericError[] = [];
            const elements = this.elements;
            for(let error of queryResult.errors) {
                if(error.details) {
                    let found = false;
                    for(let detail of error.details) {
                        if(Object.hasOwn(detail, "Name")) {
                            if(elements[detail.Name]) {
                                for(const element of elements[detail.Name]) {
                                    element.errors.push(error.message);
                                }
                                found = true;
                                break;
                            }
                        }
                    }
                    if(found) {
                        continue;
                    }
                }
                noPrintErrors.push(error);
            }
            return noPrintErrors;
        }
    }
}