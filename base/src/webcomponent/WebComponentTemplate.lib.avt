import { Computed, Effect, WatchAction, Watcher, type WatcherFunction } from "../lib/Watcher.lib.avt";
import { PressManager, type PressManagerOptions } from "../lib/PressManager.lib.avt";
import { WebComponent } from "./WebComponent.lib.avt";

type TemplateHTML = { slots: { [name: string]: string; }, blocks: { [name: string]: string; }; };

type ActionChange = {
    fct: (c: TemplateContext) => string;
};
type ActionInjection = {
    id: string,
    injectionName: string;
    inject: (c: TemplateContext) => any;
    path?: string;
};
type ActionBindings = {
    id: string,
    valueName: string,
    eventNames: string[],
    isCallback?: boolean,
    path?: string,
};
type ActionEventListener = (e: Event, c: TemplateContext) => void;
type ActionEventCallback = (c: TemplateContext, ...args: any) => void;
type ActionEvent = {
    id: string,
    eventName: string,
    isCallback?: boolean,
    fct: ActionEventListener & ActionEventCallback,
};

type Actions = {
    elements?: { name: string, ids: string[], isArray?: boolean; }[],
    content?: { [id_attr: string]: ActionChange; },
    injection?: {
        [contextProp: string]: ActionInjection[];
    };
    bindings?: {
        [contextProp: string]: ActionBindings[];
    };
    events?: ActionEvent[];
    pressEvents?: PressManagerOptions[];
};
type LoopFct = {
    transform?: () => void;
    condition: () => boolean,
    apply: () => { [key: string]: any; };
};
type LoopSimple = {
    data: string,
    item?: string,
    index?: string,
};
type Loop = {
    anchorId: string,
    template: Template;
    func?: (c: WebComponent) => LoopFct,
    simple?: LoopSimple,
};
type If = {
    anchorId: string;
    parts: {
        condition: (c: TemplateContext) => boolean;
        template: Template;
    }[];
};

export class Template {
    public static setValueToItem(path: string, obj: any, value: any) {
        let splitted = path.split(".");
        for(let i = 0; i < splitted.length - 1; i++) {
            let split = splitted[i];
            if(!obj[split]) {
                obj[split] = {};
            }
            obj = obj[split];
        }
        obj[splitted[splitted.length - 1]] = value;
    }
    public static getValueFromItem(path: string, obj: any) {
        let splitted = path.split(".");
        for(let i = 0; i < splitted.length - 1; i++) {
            let split = splitted[i];
            if(!obj[split] || typeof obj[split] !== 'object') {
                return undefined;
            }
            obj = obj[split];
        }
        if(!obj || typeof obj !== 'object') {
            return undefined;
        }
        return obj[splitted[splitted.length - 1]];
    }
    public static validatePath(path: string, pathToCheck: string) {
        if(pathToCheck.startsWith(path)) {
            return true;
        }
        return false;
    }

    public cst: typeof WebComponent;
    public constructor(component: typeof WebComponent) {
        this.cst = component;
    }

    //#region only used for main template
    private htmlParts: TemplateHTML[] = [];
    public setHTML(data: TemplateHTML) {
        this.htmlParts.push(data);
    }
    public generateTemplate(): void {
        this.template = document.createElement('template');
        let currentHTML = "<slot></slot>";
        let previousSlots: { [name: string]: string; } = {
            default: '<slot></slot>'
        };
        for(let htmlPart of this.htmlParts) {
            for(let blockName in htmlPart.blocks) {
                if(!previousSlots.hasOwnProperty(blockName)) {
                    throw "can't found slot with name " + blockName;
                }
                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);
            }
            for(let slotName in htmlPart.slots) {
                previousSlots[slotName] = htmlPart.slots[slotName];
            }
        }
        this.template.innerHTML = currentHTML;
    }
    //#endregion

    /**
     * Used by the for loop and the if
     * @param template 
     */
    public setTemplate(template: string) {
        this.template = document.createElement('template');
        this.template.innerHTML = template;
    }

    public template!: HTMLTemplateElement;
    public actions: Actions = {};
    public setActions(actions: Actions) {
        if(!this.actions) {
            this.actions = actions;
        }
        else {
            if(actions.elements) {
                if(!this.actions.elements) { this.actions.elements = []; }
                this.actions.elements = [...actions.elements, ...this.actions.elements];
            }
            if(actions.events) {
                if(!this.actions.events) { this.actions.events = []; }
                this.actions.events = [...actions.events, ...this.actions.events];
            }
            if(actions.pressEvents) {
                if(!this.actions.pressEvents) { this.actions.pressEvents = []; }
                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];
            }


            if(actions.content) {
                if(!this.actions.content) {
                    this.actions.content = actions.content;
                }
                else {
                    for(let contextProp in actions.content) {
                        if(!this.actions.content[contextProp]) {
                            this.actions.content[contextProp] = actions.content[contextProp];
                        }
                        else {
                            throw 'this should be impossible';
                        }
                    }
                }
            }

            if(actions.injection) {
                if(!this.actions.injection) {
                    this.actions.injection = actions.injection;
                }
                else {
                    for(let contextProp in actions.injection) {
                        if(!this.actions.injection[contextProp]) {
                            this.actions.injection[contextProp] = actions.injection[contextProp];
                        }
                        else {
                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };
                        }
                    }
                }
            }

            if(actions.bindings) {
                if(!this.actions.bindings) {
                    this.actions.bindings = actions.bindings;
                }
                else {
                    for(let contextProp in actions.bindings) {
                        if(!this.actions.bindings[contextProp]) {
                            this.actions.bindings[contextProp] = actions.bindings[contextProp];
                        }
                        else {
                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };
                        }
                    }
                }
            }
        }
    }

    public loops: Loop[] = [];
    public addLoop(loop: Loop) {
        this.loops.push(loop);
    }

    public ifs: If[] = [];
    public addIf(_if: If) {
        this.ifs.push(_if);
    }


    public createInstance(component: WebComponent) {
        let content = this.template.content.cloneNode(true) as DocumentFragment;
        return new TemplateInstance(component, content, this.actions, this.loops, this.ifs);
    }
}



export class TemplateInstance {
    private context: TemplateContext;
    public content: DocumentFragment;
    private actions: Actions;
    private component: WebComponent;
    private _components: { [key: string]: HTMLElement[]; } = {};
    private firstRenderUniqueCb: { [key: string]: () => void; } = {};
    private firstRenderCb: (() => void)[] = [];
    public firstChild: HTMLElement | null;
    public lastChild: HTMLElement | null;
    private computeds: Effect[] = [];
    private renderingComputeds: Effect[] = [];
    private loopRegisteries: {
        [name: string]: {
            templates: TemplateInstance[],
            computeds: Computed[],
            sub?: (change: WatcherFunction) => void;
        };
    } = {};
    private loops: Loop[] = [];
    private ifs: If[] = [];



    public constructor(component: WebComponent, content: DocumentFragment, actions: Actions, loops: Loop[], ifs: If[], context?: TemplateContext) {
        this.component = component;
        this.content = content;
        this.actions = actions;
        this.ifs = ifs;
        this.loops = loops;
        this.context = context ? context : new TemplateContext(component);
        this.firstChild = content.firstElementChild as HTMLElement;
        this.lastChild = content.lastElementChild as HTMLElement;

        this.selectElements();
        this.transformActionsListening();
    }

    public render() {
        this.bindEvents();
        for(let cb of this.firstRenderCb) {
            cb();
        }
        for(let key in this.firstRenderUniqueCb) {
            this.firstRenderUniqueCb[key]();
        }

        this.renderSubTemplate();
    }

    public destructor() {
        for(let name in this.loopRegisteries) {
            for(let item of this.loopRegisteries[name].templates) {
                item.destructor();
            }
            for(let item of this.loopRegisteries[name].computeds) {
                item.destroy();
            }
        }
        this.loopRegisteries = {};

        this.context.destructor();
        for(let computed of this.computeds) {
            computed.destroy();
        }
        for(let computed of this.renderingComputeds) {
            computed.destroy();
        }
        this.computeds = [];
        this.removeFromDOM();
    }
    public removeFromDOM(avoidTrigger: boolean = false) {
        if(avoidTrigger) {
            let node: Element | null = this.firstChild;
            while(node && node != this.lastChild) {
                let next = node.nextElementSibling;
                node.parentNode?.removeChild(node);
                node = next;
            }
            this.lastChild?.parentNode?.removeChild(this.lastChild);
        }
        else {
            let node: Element | null = this.firstChild;
            while(node && node != this.lastChild) {
                let next = node.nextElementSibling;
                node.remove();
                node = next;
            }
            this.lastChild?.remove();
        }
    }

    private selectElements() {
        this._components = {};
        let idEls = Array.from(this.content.querySelectorAll('[_id]'));
        for(let idEl of idEls) {
            let id = idEl.attributes['_id'].value;
            if(!this._components[id]) {
                this._components[id] = [];
            }
            this._components[id].push(idEl as HTMLElement);
        }
        if(this.actions.elements) {
            for(let element of this.actions.elements) {
                let components: HTMLElement[] = [];
                for(let id of element.ids) {
                    if(this._components[id]) {
                        components = [...components, ...this._components[id]];
                    }
                }
                if(element.isArray) {
                    Template.setValueToItem(element.name, this.component, components);
                }
                else if(components[0]) {
                    Template.setValueToItem(element.name, this.component, components[0]);
                }
            }
        }
    }


    private bindEvents() {
        if(this.actions.events) {
            for(let event of this.actions.events) {
                this.bindEvent(event);
            }
        }
        if(this.actions.pressEvents) {
            for(let event of this.actions.pressEvents) {
                this.bindPressEvent(event);
            }
        }
    }
    private bindEvent(event: ActionEvent) {
        if(!this._components[event.id]) {
            return;
        }
        if(event.isCallback) {
            for(let el of this._components[event.id]) {
                let cb = Template.getValueFromItem(event.eventName, el);
                cb?.add((...args) => {
                    // TODO check if it's working
                    event.fct(this.context, args);
                });
            }
        }
        else {
            for(let el of this._components[event.id]) {
                el.addEventListener(event.eventName, (e) => { event.fct(e, this.context); });
            }
        }
    }
    private bindPressEvent(event: PressManagerOptions) {
        let id = event['id'];
        if(id && this._components[id]) {
            let clone: any = {};
            for(let temp in event) {
                if(temp != 'id') {
                    if(event[temp] instanceof Function) {
                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };
                    }
                    else {
                        clone[temp] = event[temp];
                    }
                }
            }
            clone.element = this._components[id];
            PressManager.create(clone);
        }
    }

    private transformActionsListening() {
        if(this.actions.content) {
            for(let name in this.actions.content) {
                this.transformChangeAction(name, this.actions.content[name]);
            }
        }
        if(this.actions.injection) {
            for(let name in this.actions.injection) {
                for(let injection of this.actions.injection[name]) {
                    this.transformInjectionAction(name, injection);
                }
            }
        }
        if(this.actions.bindings) {
            for(let name in this.actions.bindings) {
                for(let binding of this.actions.bindings[name]) {
                    this.transformBindigAction(name, binding);
                }
            }
        }
    }

    private transformChangeAction(name: string, change: ActionChange) {
        const [id, attr] = name.split("°");
        if(!this._components[id]) return;

        let computed: Computed<string>;
        let apply = () => { };
        if(attr == "@HTML") {
            apply = () => {
                let value = this.context.print(computed.value);
                for(const el of this._components[id])
                    el.innerHTML = value;
            };
        }
        else {
            apply = () => {
                let value = this.context.print(computed.value);
                if(value === "false") {
                    for(const el of this._components[id]) {
                        el.removeAttribute(attr);
                    }
                }
                else {
                    for(const el of this._components[id]) {
                        el.setAttribute(attr, value);
                    }
                }
            };
        }

        computed = new Computed<string>(() => {
            return change.fct(this.context);
        });

        let timeout: number;
        computed.subscribe((action, path, value) => {
            clearTimeout(timeout);
            // add timeout to group change that append on the same frame (for example index update)
            timeout = setTimeout(() => {
                apply();
            });

        });

        this.renderingComputeds.push(computed);

        this.firstRenderUniqueCb[name] = () => {
            apply();
        };
    }

    private transformInjectionAction(name: string, injection: ActionInjection) {
        if(!this._components[injection.id]) return;
        if(injection.path) {
            this.context.registerChange(name, (path) => {
                if(Template.validatePath(path, injection.path ?? '')) {
                    for(const el of this._components[injection.id]) {
                        el[injection.injectionName] = injection.inject(this.context);
                    }
                }
            });
        }
        else {
            this.context.registerChange(name, (path) => {
                for(const el of this._components[injection.id]) {
                    el[injection.injectionName] = injection.inject(this.context);
                }
            });
        }
        this.firstRenderCb.push(() => {
            for(const el of this._components[injection.id]) {
                el[injection.injectionName] = injection.inject(this.context);
            }
        });
    }

    private transformBindigAction(name: string, binding: ActionBindings) {
        if(!this._components[binding.id]) return;
        if(binding.path) {
            this.context.registerChange(name, (path) => {
                let bindingPath = binding.path ?? '';
                if(Template.validatePath(path, bindingPath)) {
                    let valueToSet = this.context.getValueFromItem(bindingPath);
                    for(const el of this._components[binding.id]) {
                        Template.setValueToItem(binding.valueName, el, valueToSet);
                    }
                }
            });
        }
        else {
            binding.path = name;
            this.context.registerChange(name, (path) => {
                let valueToSet = this.context.getValueFromItem(name);
                for(const el of this._components[binding.id]) {
                    Template.setValueToItem(binding.valueName, el, valueToSet);
                }
            });
        }

        if(binding.isCallback) {
            this.firstRenderCb.push(() => {
                for(var el of this._components[binding.id]) {
                    for(let fct of binding.eventNames) {
                        let cb = Template.getValueFromItem(fct, el);
                        cb?.add((value) => {
                            this.context.setValueToItem(binding.path ?? '', value);
                        });
                    }
                    let valueToSet = this.context.getValueFromItem(binding.path ?? '');
                    Template.setValueToItem(binding.valueName, el, valueToSet);
                }
            });
        }
        else {
            this.firstRenderCb.push(() => {
                for(var el of this._components[binding.id]) {
                    for(let fct of binding.eventNames) {
                        el.addEventListener(fct, (e) => {
                            let valueToSet = Template.getValueFromItem(binding.valueName, e.target);
                            this.context.setValueToItem(binding.path ?? '', valueToSet);
                        });
                    }
                    let valueToSet = this.context.getValueFromItem(binding.path ?? '');
                    Template.setValueToItem(binding.valueName, el, valueToSet);
                }
            });
        }
    }

    private renderSubTemplate() {
        for(let loop of this.loops) {
            this.renderLoop(loop);
        }
        for(let _if of this.ifs) {
            this.renderIf(_if);
        }
    }
    private renderLoop(loop: Loop) {
        if(loop.func) {
            // it's a complex rendering
            let fctsTemp = loop.func(this.component);
            let fcts: Required<LoopFct> = {
                apply: fctsTemp.apply,
                condition: fctsTemp.condition,
                transform: fctsTemp.transform ?? (() => { })
            };
            this.renderLoopComplex(loop, fcts);
        }
        else if(loop.simple) {
            this.renderLoopSimple(loop, loop.simple);
        }
    }
    private resetLoop(loop: Loop) {
        if(this.loopRegisteries[loop.anchorId]) {
            for(let item of this.loopRegisteries[loop.anchorId].templates) {
                item.destructor();
            }
            for(let item of this.loopRegisteries[loop.anchorId].computeds) {
                item.destroy();
            }

            if(loop.simple && this.loopRegisteries[loop.anchorId].sub) {
                let elements = this.context.getValueFromItem(loop.simple.data.replace(/^this\./, ''));
                if(elements) {
                    elements.unsubscribe(this.loopRegisteries[loop.anchorId].sub);
                }
            }
        }
        this.loopRegisteries[loop.anchorId] = {
            templates: [],
            computeds: [],
        };
    }
    private renderLoopComplex(loop: Loop, fcts: Required<LoopFct>) {
        this.resetLoop(loop);
        let computedsCondition: Computed[] = [];
        let alreadyRecreated = false;
        const createComputedCondition = () => {
            let compCondition = new Computed<any>(() => {
                return fcts.condition();
            });
            compCondition.value;
            compCondition.subscribe((action, path, value) => {
                if(!alreadyRecreated) {
                    alreadyRecreated = true;
                    this.renderLoopComplex(loop, fcts);
                }
            });
            computedsCondition.push(compCondition);
            this.loopRegisteries[loop.anchorId].computeds.push(compCondition);
            return compCondition;
        };

        let result: any[] = [];
        let compCondition = createComputedCondition();
        while(compCondition.value) {
            result.push(fcts.apply());
            fcts.transform();
            compCondition = createComputedCondition();
        }


        let anchor = this._components[loop.anchorId][0];
        for(let i = 0; i < result.length; i++) {
            let context = new TemplateContext(this.component, result[i], this.context);
            let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = loop.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);
            instance.render();
            anchor.parentNode?.insertBefore(instance.content, anchor);
            this.loopRegisteries[loop.anchorId].templates.push(instance);
        }
    }
    private renderLoopSimple(loop: Loop, simple: LoopSimple) {
        this.resetLoop(loop);
        let basePath = simple.data.replace(/^this\./, '');
        let getElements = () => this.context.getValueFromItem(basePath);
        let elements = getElements();
        let indexName = this.context.registerIndex();
        let keys = Object.keys(elements);
        if(elements.__isProxy) {
            let regexArray = new RegExp(basePath.replace(/\./g, "\\.") + "\\[(\\d+?)\\]$");
            let regexObject = new RegExp(basePath.replace(/\./g, "\\.") + "\\.([^\\.]*)$");
            let sub: WatcherFunction = (action, path, value) => {
                if(path == basePath) {
                    this.renderLoopSimple(loop, simple);
                    return;
                }
                // updated is deal by other function
                if(action == WatchAction.UPDATED) {
                    return;
                }

                let index: undefined | number = undefined;
                regexArray.lastIndex = 0;
                regexObject.lastIndex = 0;
                let resultArray = regexArray.exec(path);
                if(resultArray) {
                    index = Number(resultArray[1]);
                }
                else {
                    let resultObject = regexObject.exec(path);
                    if(resultObject) {
                        let oldKey = resultObject[1];
                        if(action == WatchAction.CREATED) {
                            keys = Object.keys(getElements());
                            index = keys.indexOf(oldKey);
                        }
                        else if(action == WatchAction.DELETED) {
                            index = keys.indexOf(oldKey);
                            keys = Object.keys(getElements());
                        }


                    }
                }

                if(index !== undefined) {
                    let registry = this.loopRegisteries[loop.anchorId];
                    if(action == WatchAction.CREATED) {
                        let context = new TemplateContext(this.component, {}, this.context);
                        context.registerLoop(simple.data, index, indexName, simple.index, simple.item);
                        let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
                        let actions = loop.template.actions;
                        let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);
                        instance.render();

                        let anchor: HTMLElement | null;
                        if(index < registry.templates.length) {
                            anchor = registry.templates[index].firstChild;
                        }
                        else {
                            anchor = this._components[loop.anchorId][0];
                        }

                        anchor?.parentNode?.insertBefore(instance.content, anchor);
                        registry.templates.splice(index, 0, instance);
                        for(let i = index + 1; i < registry.templates.length; i++) {
                            let computeds = registry.templates[i].renderingComputeds;
                            registry.templates[i].context.increaseIndex(indexName, simple.data, computeds);

                        }
                    }
                    else if(action == WatchAction.DELETED) {
                        registry.templates[index].destructor();
                        registry.templates.splice(index, 1);
                        for(let i = index; i < registry.templates.length; i++) {
                            let computeds = registry.templates[i].renderingComputeds;
                            registry.templates[i].context.decreaseIndex(indexName, simple.data, computeds);
                        }
                    }
                }
            };
            elements.subscribe(sub);
        }

        let anchor = this._components[loop.anchorId][0];
        for(let i = 0; i < keys.length; i++) {
            let context = new TemplateContext(this.component, {}, this.context);
            context.registerLoop(simple.data, i, indexName, simple.index, simple.item);
            let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = loop.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);
            instance.render();
            anchor.parentNode?.insertBefore(instance.content, anchor);
            this.loopRegisteries[loop.anchorId].templates.push(instance);
        }
    }

    private renderIf(_if: If) {
        let computeds: Computed<boolean>[] = [];
        let instances: TemplateInstance[] = [];
        let anchor = this._components[_if.anchorId][0];
        let currentActive: number = -1;
        const calculateActive = () => {
            let newActive = -1;
            for(let i = 0; i < _if.parts.length; i++) {
                if(computeds[i].value) {
                    newActive = i;
                    break;
                }
            }

            if(newActive == currentActive) {
                return;
            }

            if(currentActive != -1) {
                let instance = instances[currentActive];
                let node: Element | null = instance.firstChild;
                while(node && node != instance.lastChild) {
                    let next = node.nextElementSibling;
                    instance.content.appendChild(node);
                    node = next;
                }
                if(instance.lastChild)
                    instance.content.appendChild(instance.lastChild);
            }

            currentActive = newActive;
            anchor.parentNode?.insertBefore(instances[currentActive].content, anchor);
        };

        for(let i = 0; i < _if.parts.length; i++) {
            const part = _if.parts[i];
            let computed = new Computed<boolean>(() => {
                return part.condition(this.context);
            });
            computeds.push(computed);
            computed.subscribe(() => {
                calculateActive();
            });
            this.computeds.push(computed);



            let context = new TemplateContext(this.component, {}, this.context);
            let content = part.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = part.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, part.template.loops, part.template.ifs, context);
            instances.push(instance);
            instance.render();
        }

        calculateActive();
    }

}

export class TemplateContext {
    public data: { [name: string]: any; } = {};
    public comp: WebComponent;
    private computeds: Computed[] = [];
    private watch: any;

    public constructor(component: WebComponent, data: { [key: string]: any; } = {}, parentContext?: TemplateContext) {
        this.comp = component;
        this.watch = Watcher.get({ ...data });
        let that = this;
        for(let key in data) {
            Object.defineProperty(this.data, key, {
                get() {
                    return that.watch[key];
                }
            });
        }

        if(parentContext) {
            const descriptors = Object.getOwnPropertyDescriptors(parentContext.data);
            for(let name in descriptors) {
                Object.defineProperty(this.data, name, {
                    get() {
                        return parentContext.data[name];
                    }
                });
            }
        }
    }

    public print(value: any) {
        return value == null ? "" : value + "";
    }


    public registerIndex() {
        let name = "index";
        let i = 0;
        let fullName = name + i;
        while(this.watch[fullName] !== undefined) {
            i++;
            fullName = name + i;
        }
        return fullName;
    }

    public registerLoop(dataName: string, _indexValue: number, _indexName: string, indexName?: string, itemName?: string) {
        this.watch[_indexName] = _indexValue;
        let getItems: () => any[];
        if(!dataName.startsWith("this.")) {
            getItems = () => {
                return Template.getValueFromItem(dataName, this.data);
            };
        }
        else {
            dataName = dataName.replace(/^this\./, '');
            getItems = () => {
                return Template.getValueFromItem(dataName, this.comp);
            };
        }

        let getIndex: Computed<any> = new Computed(() => {
            let keys = Object.keys(getItems());
            let index = keys[_getIndex.value];
            if(/^[0-9]+$/g.test(index)) return Number(index);
            return index;
        });
        let getItem: Computed<any> = new Computed(() => {
            let keys = Object.keys(getItems());
            let index = keys[_getIndex.value];
            return getItems()[index];
        });
        let _getIndex: Computed<any> = new Computed(() => {
            return this.watch[_indexName];
        });

        this.computeds.push(getIndex);
        this.computeds.push(getItem);
        this.computeds.push(_getIndex);
        if(itemName) {
            Object.defineProperty(this.data, itemName, {
                get() {
                    return getItem.value;
                }
            });
        }
        if(indexName) {
            Object.defineProperty(this.data, indexName, {
                get() {
                    return getIndex.value;
                }
            });
        }
    }

    private updateIndex(newIndex: number, _indexName: string, dataName: string, computeds: Effect[]) {
        let fullName: string;
        let items: any[] | {};
        if(!dataName.startsWith("this.")) {
            let comp = new Computed(() => {
                return Template.getValueFromItem(dataName, this.data);
            });
            items = comp.value;
            fullName = comp.callbacks[comp.callbacks.length - 1].path;
        }
        else {
            fullName = dataName.replace(/^this\./, '');
            items = Template.getValueFromItem(fullName, this.comp);
        }

        if(Array.isArray(items)) {
            let regex = new RegExp("^(" + fullName.replace(/\./g, "\\.") + ")\\[(\\d+?)\\]");
            for(let computed of computeds) {
                for(let cb of computed.callbacks) {
                    regex.lastIndex = 0;
                    cb.path = cb.path.replace(regex, "$1[" + newIndex + "]");
                }
            }
        }
        else {
            // let oldKey = Object.keys(items)[this.watch[_indexName]]
            // let newKey = Object.keys(items)[newIndex]
            // let regex = new RegExp("^(" + fullName.replace(/\./g, "\\.") + "\\.)(" + oldKey + ")($|\\.)");
            // for (let computed of computeds) {
            //     for (let cb of computed.callbacks) {
            //         regex.lastIndex = 0;
            //         cb.path = cb.path.replace(regex, "$1" + newKey + "$3")
            //     }
            // }
        }

        this.watch[_indexName] = newIndex;
    }
    public increaseIndex(_indexName: string, dataName: string, computeds: Effect[]) {
        this.updateIndex(this.watch[_indexName] + 1, _indexName, dataName, computeds);
    }
    public decreaseIndex(_indexName: string, dataName: string, computeds: Effect[]) {
        this.updateIndex(this.watch[_indexName] - 1, _indexName, dataName, computeds);
    }



    public registerChange(name: string, fct: (path: string) => void) {
        let computed: Computed<any>;
        if(name.startsWith("°")) {
            // it's a local variable from another loop
            computed = new Computed(() => {
                return Template.getValueFromItem(name, this.data);
            });
        }
        else {
            // its a variable from the component
            computed = new Computed(() => {
                return Template.getValueFromItem(name, this.comp);
            });
        }
        this.computeds.push(computed);
        computed.subscribe((action, path, value) => {
            fct(path);
        });
    }

    public destructor() {
        for(let computed of this.computeds) {
            computed.destroy();
        }
        this.computeds = [];
    }


    public getValueFromItem(name: string) {
        let result = Template.getValueFromItem(name, this.data);
        if(result !== undefined) {
            return result;
        }

        result = Template.getValueFromItem(name, this.comp);
        if(result !== undefined) {
            return result;
        }

        return undefined;
    }
    public setValueToItem(name: string, value: any) {
        Template.setValueToItem(name, this.comp, value);
    }
}

