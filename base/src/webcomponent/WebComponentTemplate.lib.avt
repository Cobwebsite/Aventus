import { Computed, ComputedNoRecomputed, Effect, WatchAction, Watcher, type WatcherFunction } from "../lib/Watcher.lib.avt";
import { PressManager, type PressManagerOptions } from "../lib/PressManager.lib.avt";
import { WebComponent } from "./WebComponent.lib.avt";
import { getValueFromObject, setValueToObject } from "../tools/CompareObject.lib.avt";

type TemplateHTML = { slots: { [name: string]: string; }, blocks: { [name: string]: string; }; };

type ActionChange = {
    fct: (c: TemplateContext) => string;
    once?: boolean;
};
type ActionInjection = {
    id: string,
    injectionName: string;
    inject: (c: TemplateContext) => any;
    once?: boolean;
};
type ActionBindings = {
    id: string,
    injectionName: string,
    eventNames: string[],
    inject: (c: TemplateContext) => any,
    extract: (c: TemplateContext, v: any) => any,
    isCallback?: boolean,
    once?: boolean;
};
type ActionEventListener = (e: Event, c: TemplateContext) => void;
type ActionEventCallback = (c: TemplateContext, ...args: any) => void;
type ActionEvent = {
    id: string,
    eventName: string,
    isCallback?: boolean,
    fct: ActionEventListener & ActionEventCallback,
};

type Actions = {
    elements?: { name: string, ids: string[], isArray?: boolean; }[],
    content?: { [id_attr: string]: ActionChange; },
    injection?: ActionInjection[];
    bindings?: ActionBindings[];
    events?: ActionEvent[];
    pressEvents?: PressManagerOptions[];
    contextEdits?: ContextEdit[];
};
type LoopFct = {
    transform?: () => void;
    condition: () => boolean,
    apply: () => { [key: string]: any; };
};
type LoopSimple = {
    data: string,
    item?: string,
    index?: string,
};
type Loop = {
    anchorId: string,
    template: Template;
    func?: (c: TemplateContext) => LoopFct,
    simple?: LoopSimple,
};
type LoopRegistery = {
    templates: TemplateInstance[],
    computeds: Computed[],
    sub?: WatcherFunction;
};
type If = {
    anchorId: string;
    parts: {
        condition: (c: TemplateContext) => boolean;
        template: Template;
        once?: boolean;
    }[];
};

type ContextEdit = {
    fct: (c: TemplateContext) => { [key: string]: any; };
    once?: boolean;
};

export class Template {
    public static validatePath(path: string, pathToCheck: string) {
        if(pathToCheck.startsWith(path)) {
            return true;
        }
        return false;
    }

    public cst: typeof WebComponent;
    public constructor(component: typeof WebComponent) {
        this.cst = component;
    }

    //#region only used for main template
    private htmlParts: TemplateHTML[] = [];
    public setHTML(data: TemplateHTML) {
        this.htmlParts.push(data);
    }
    public generateTemplate(): void {
        this.template = document.createElement('template');
        let currentHTML = "<slot></slot>";
        let previousSlots: { [name: string]: string; } = {
            default: '<slot></slot>'
        };
        for(let htmlPart of this.htmlParts) {
            for(let blockName in htmlPart.blocks) {
                if(!previousSlots.hasOwnProperty(blockName)) {
                    throw "can't found slot with name " + blockName;
                }
                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);
            }
            for(let slotName in htmlPart.slots) {
                previousSlots[slotName] = htmlPart.slots[slotName];
            }
        }
        this.template.innerHTML = currentHTML;
    }
    //#endregion

    /**
     * Used by the for loop and the if
     * @param template 
     */
    public setTemplate(template: string) {
        this.template = document.createElement('template');
        this.template.innerHTML = template;
    }

    public template!: HTMLTemplateElement;
    public actions: Actions = {};
    public setActions(actions: Actions) {
        if(!this.actions) {
            this.actions = actions;
        }
        else {
            if(actions.elements) {
                if(!this.actions.elements) { this.actions.elements = []; }
                this.actions.elements = [...actions.elements, ...this.actions.elements];
            }
            if(actions.events) {
                if(!this.actions.events) { this.actions.events = []; }
                this.actions.events = [...actions.events, ...this.actions.events];
            }
            if(actions.pressEvents) {
                if(!this.actions.pressEvents) { this.actions.pressEvents = []; }
                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];
            }


            if(actions.content) {
                if(!this.actions.content) {
                    this.actions.content = actions.content;
                }
                else {
                    for(let contextProp in actions.content) {
                        if(!this.actions.content[contextProp]) {
                            this.actions.content[contextProp] = actions.content[contextProp];
                        }
                        else {
                            throw 'this should be impossible';
                        }
                    }
                }
            }

            if(actions.injection) {
                if(!this.actions.injection) {
                    this.actions.injection = actions.injection;
                }
                else {
                    for(let contextProp in actions.injection) {
                        if(!this.actions.injection[contextProp]) {
                            this.actions.injection[contextProp] = actions.injection[contextProp];
                        }
                        else {
                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };
                        }
                    }
                }
            }

            if(actions.bindings) {
                if(!this.actions.bindings) {
                    this.actions.bindings = actions.bindings;
                }
                else {
                    for(let contextProp in actions.bindings) {
                        if(!this.actions.bindings[contextProp]) {
                            this.actions.bindings[contextProp] = actions.bindings[contextProp];
                        }
                        else {
                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };
                        }
                    }
                }
            }

            if(actions.contextEdits) {
                if(!this.actions.contextEdits) { this.actions.contextEdits = []; }
                this.actions.contextEdits = [...actions.contextEdits, ...this.actions.contextEdits];
            }
        }
    }

    public loops: Loop[] = [];
    public addLoop(loop: Loop) {
        this.loops.push(loop);
    }

    public ifs: If[] = [];
    public addIf(_if: If) {
        this.ifs.push(_if);
    }


    public createInstance(component: WebComponent) {
        let content = this.template.content.cloneNode(true) as DocumentFragment;
        return new TemplateInstance(component, content, this.actions, this.loops, this.ifs);
    }
}



export class TemplateInstance {
    @Internal()
    public context: TemplateContext;
    public content: DocumentFragment;
    private actions: Actions;
    private component: WebComponent;
    private _components: { [key: string]: HTMLElement[]; } = {};
    private firstRenderUniqueCb: { [key: string]: () => void; } = {};
    private firstRenderCb: (() => void)[] = [];
    public firstChild: HTMLElement | null;
    public lastChild: HTMLElement | null;
    private computeds: Effect[] = [];
    private renderingComputeds: Effect[] = [];
    private loopRegisteries: {
        [name: string]: LoopRegistery;
    } = {};
    private loops: Loop[] = [];
    private ifs: If[] = [];
    private isDestroyed: boolean = false;



    public constructor(component: WebComponent, content: DocumentFragment, actions: Actions, loops: Loop[], ifs: If[], context?: TemplateContext) {
        this.component = component;
        this.content = content;
        this.actions = actions;
        this.ifs = ifs;
        this.loops = loops;
        this.context = context ? context : new TemplateContext(component);
        this.firstChild = content.firstElementChild as HTMLElement;
        this.lastChild = content.lastElementChild as HTMLElement;

        this.selectElements();
        this.transformActionsListening();
    }

    public render() {
        this.updateContext();
        this.bindEvents();
        for(let cb of this.firstRenderCb) {
            cb();
        }
        for(let key in this.firstRenderUniqueCb) {
            this.firstRenderUniqueCb[key]();
        }

        this.renderSubTemplate();
    }

    public destructor() {
        this.isDestroyed = true;
        for(let name in this.loopRegisteries) {
            for(let item of this.loopRegisteries[name].templates) {
                item.destructor();
            }
            for(let item of this.loopRegisteries[name].computeds) {
                item.destroy();
            }
        }
        this.loopRegisteries = {};

        this.context.destructor();
        for(let computed of this.computeds) {
            computed.destroy();
        }
        for(let computed of this.renderingComputeds) {
            computed.destroy();
        }
        this.computeds = [];
        this.removeFromDOM();
    }
    public removeFromDOM(avoidTrigger: boolean = false) {
        if(avoidTrigger) {
            let node: Element | null = this.firstChild;
            while(node && node != this.lastChild) {
                let next = node.nextElementSibling;
                node.parentNode?.removeChild(node);
                node = next;
            }
            this.lastChild?.parentNode?.removeChild(this.lastChild);
        }
        else {
            let node: Element | null = this.firstChild;
            while(node && node != this.lastChild) {
                let next = node.nextElementSibling;
                node.remove();
                node = next;
            }
            this.lastChild?.remove();
        }
    }

    private selectElements() {
        this._components = {};
        let idEls = Array.from(this.content.querySelectorAll('[_id]'));
        for(let idEl of idEls) {
            let id = idEl.attributes['_id'].value;
            if(!this._components[id]) {
                this._components[id] = [];
            }
            this._components[id].push(idEl as HTMLElement);
        }
        if(this.actions.elements) {
            for(let element of this.actions.elements) {
                let components: HTMLElement[] = [];
                for(let id of element.ids) {
                    if(this._components[id]) {
                        components = [...components, ...this._components[id]];
                    }
                }
                if(element.isArray) {
                    setValueToObject(element.name, this.component, components);
                }
                else if(components[0]) {
                    setValueToObject(element.name, this.component, components[0]);
                }
            }
        }
    }

    private updateContext() {
        if(this.actions.contextEdits) {
            for(let contextEdit of this.actions.contextEdits) {
                this.renderContextEdit(contextEdit);
            }
        }
    }
    private renderContextEdit(edit: ContextEdit) {
        let _class = edit.once ? ComputedNoRecomputed : Computed;
        let computed = new _class(() => {
            try {
                return edit.fct(this.context);
            } catch(e) {

            }
            return {};
        });
        computed.subscribe((action, path, value) => {
            for(let key in computed.value) {
                let newValue = computed.value[key];
                this.context.updateWatch(key, newValue);
            }
        });
        this.computeds.push(computed);
        for(let key in computed.value) {
            this.context.registerWatch(key, computed.value[key]);
        }
    }

    private bindEvents() {
        if(this.actions.events) {
            for(let event of this.actions.events) {
                this.bindEvent(event);
            }
        }
        if(this.actions.pressEvents) {
            for(let event of this.actions.pressEvents) {
                this.bindPressEvent(event);
            }
        }
    }
    private bindEvent(event: ActionEvent) {
        if(!this._components[event.id]) {
            return;
        }
        if(event.isCallback) {
            for(let el of this._components[event.id]) {
                let cb = getValueFromObject(event.eventName, el);
                cb?.add((...args) => {
                    // TODO check if it's working
                    try {
                        event.fct(this.context, args);
                    } catch(e) {
                        console.error(e);
                    }
                });
            }
        }
        else {
            for(let el of this._components[event.id]) {
                el.addEventListener(event.eventName, (e) => {
                    try {
                        event.fct(e, this.context);
                    } catch(e) {
                        console.error(e);
                    }

                });
            }
        }
    }
    private bindPressEvent(event: PressManagerOptions) {
        let id = event['id'];
        if(id && this._components[id]) {
            let clone: any = {};
            for(let temp in event) {
                if(temp != 'id') {
                    if(event[temp] instanceof Function) {
                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };
                    }
                    else {
                        clone[temp] = event[temp];
                    }
                }
            }
            clone.element = this._components[id];
            PressManager.create(clone);
        }
    }

    private transformActionsListening() {
        if(this.actions.content) {
            for(let name in this.actions.content) {
                this.transformChangeAction(name, this.actions.content[name]);
            }
        }
        if(this.actions.injection) {
            for(let injection of this.actions.injection) {
                this.transformInjectionAction(injection);
            }
        }
        if(this.actions.bindings) {
            for(let binding of this.actions.bindings) {
                this.transformBindigAction(binding);
            }
        }
    }

    private transformChangeAction(name: string, change: ActionChange) {
        const [id, attr] = name.split("°");
        if(!this._components[id]) return;

        let apply = () => { };
        if(attr == "@HTML") {
            apply = () => {
                let value = this.context.print(computed.value);
                for(const el of this._components[id])
                    el.innerHTML = value;
            };
        }
        else {
            apply = () => {
                let value = this.context.print(computed.value);
                if(value === "false") {
                    for(const el of this._components[id]) {
                        el.removeAttribute(attr);
                    }
                }
                else {
                    for(const el of this._components[id]) {
                        el.setAttribute(attr, value);
                    }
                }
            };
        }

        let _class = change.once ? ComputedNoRecomputed : Computed;
        let computed = new _class(() => {
            try {
                return change.fct(this.context);
            } catch(e) {
                // if failed, it can mean that the user is using a ! => we must recompute full chain 
                if(computed instanceof ComputedNoRecomputed) {
                    computed.isInit  = false;
                }
                debugger;
            }
            return "";
        });

        let timeout: number;
        computed.subscribe((action, path, value) => {
            clearTimeout(timeout);
            // add timeout to group change that append on the same frame (for example index update)
            timeout = setTimeout(() => {
                if(computed.isDestroy) return;
                apply();
            });

        });

        this.renderingComputeds.push(computed);

        this.firstRenderUniqueCb[name] = () => {
            apply();
        };
    }

    private transformInjectionAction(injection: ActionInjection) {
        if(!this._components[injection.id]) return;
        let _class = injection.once ? ComputedNoRecomputed : Computed;
        let computed = new _class(() => {
            return injection.inject(this.context);
        });
        this.computeds.push(computed);
        computed.subscribe(() => {
            for(const el of this._components[injection.id]) {
                el[injection.injectionName] = computed.value;
            }
        });
        this.firstRenderCb.push(() => {
            for(const el of this._components[injection.id]) {
                el[injection.injectionName] = computed.value;
            }
        });
    }

    private transformBindigAction(binding: ActionBindings) {
        let isLocalChange = false;
        let _class = binding.once ? ComputedNoRecomputed : Computed;
        let computed = new _class(() => {
            return binding.inject(this.context);
        });
        this.computeds.push(computed);
        computed.subscribe(() => {
            if(isLocalChange) return;
            for(const el of this._components[binding.id]) {
                el[binding.injectionName] = computed.value;
            }
        });
        this.firstRenderCb.push(() => {
            for(const el of this._components[binding.id]) {
                el[binding.injectionName] = computed.value;
            }
        });

        if(binding.isCallback) {
            this.firstRenderCb.push(() => {
                for(var el of this._components[binding.id]) {
                    for(let fct of binding.eventNames) {
                        let cb = getValueFromObject(fct, el);
                        cb?.add((value) => {
                            let valueToSet = getValueFromObject(binding.injectionName, el);
                            isLocalChange = true;
                            binding.extract(this.context, valueToSet);
                            isLocalChange = false;
                        });
                    }
                }
            });
        }
        else {
            this.firstRenderCb.push(() => {
                for(var el of this._components[binding.id]) {
                    for(let fct of binding.eventNames) {
                        el.addEventListener(fct, (e) => {
                            let valueToSet = getValueFromObject(binding.injectionName, e.target);
                            isLocalChange = true;
                            binding.extract(this.context, valueToSet);
                            isLocalChange = false;
                        });
                    }
                }
            });
        }
    }

    private renderSubTemplate() {
        for(let loop of this.loops) {
            this.renderLoop(loop);
        }
        for(let _if of this.ifs) {
            this.renderIf(_if);
        }
    }
    private renderLoop(loop: Loop) {
        if(loop.func) {
            this.renderLoopComplex(loop);
        }
        else if(loop.simple) {
            this.renderLoopSimple(loop, loop.simple);
        }
    }
    private resetLoop(loop: Loop) {
        if(this.loopRegisteries[loop.anchorId]) {
            for(let item of this.loopRegisteries[loop.anchorId].templates) {
                item.destructor();
            }
            for(let item of this.loopRegisteries[loop.anchorId].computeds) {
                item.destroy();
            }

            if(loop.simple && this.loopRegisteries[loop.anchorId].sub) {
                let elements = this.context.getValueFromItem(loop.simple.data.replace(/^this\./, ''));
                if(elements) {
                    elements.unsubscribe(this.loopRegisteries[loop.anchorId].sub);
                }
            }
        }
        this.loopRegisteries[loop.anchorId] = {
            templates: [],
            computeds: [],
        };
    }
    private renderLoopComplex(loop: Loop) {
        if(!loop.func) return;
        let fctsTemp = loop.func.bind(this.component)(this.context);
        let fcts: Required<LoopFct> = {
            apply: fctsTemp.apply,
            condition: fctsTemp.condition,
            transform: fctsTemp.transform ?? (() => { })
        };
        this.resetLoop(loop);
        let computedsCondition: Computed[] = [];
        let alreadyRecreated = false;
        const createComputedCondition = () => {
            let compCondition = new Computed<any>(() => {
                return fcts.condition();
            });
            compCondition.value;
            compCondition.subscribe((action, path, value) => {
                if(!alreadyRecreated) {
                    alreadyRecreated = true;
                    this.renderLoopComplex(loop);
                }
            });
            computedsCondition.push(compCondition);
            this.loopRegisteries[loop.anchorId].computeds.push(compCondition);
            return compCondition;
        };

        let result: any[] = [];
        let compCondition = createComputedCondition();
        while(compCondition.value) {
            result.push(fcts.apply());
            fcts.transform();
            compCondition = createComputedCondition();
        }


        let anchor = this._components[loop.anchorId][0];
        for(let i = 0; i < result.length; i++) {
            let context = new TemplateContext(this.component, result[i], this.context, this.loopRegisteries[loop.anchorId]);
            let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = loop.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);
            instance.render();
            anchor.parentNode?.insertBefore(instance.content, anchor);
            this.loopRegisteries[loop.anchorId].templates.push(instance);
        }
    }

    private renderLoopSimple(loop: Loop, simple: LoopSimple) {
        this.resetLoop(loop);
        let basePath = simple.data.replace(/^this\./, '');
        let getElements = () => this.context.getValueFromItem(basePath);
        let elements = getElements();
        if(!elements) {
            let currentPath = basePath;

            while(currentPath != '' && !elements) {
                let splittedPath = currentPath.split(".");
                splittedPath.pop();
                currentPath = splittedPath.join(".");
                elements = this.context.getValueFromItem(currentPath);
            }
            if(!elements && simple.data.startsWith("this.")) {
                elements = this.component.__watch;
            }
            if(!elements || !elements.__isProxy) {
                debugger;
            }

            const subTemp = (action, path, value) => {
                if(basePath.startsWith(path)) {
                    elements.unsubscribe(subTemp);
                    this.renderLoopSimple(loop, simple)
                    return;
                }
            };
            elements.subscribe(subTemp);
            return;
        }
        let indexName = this.context.registerIndex();
        let keys = Object.keys(elements);
        if(elements.__isProxy) {
            let regexArray = new RegExp("^\\[(\\d+?)\\]$");
            let regexObject = new RegExp("^([^\\.]*)$");
            let sub: WatcherFunction = (action, path, value) => {
                if(path == "") {
                    this.renderLoopSimple(loop, simple);
                    return;
                }
                // updated is deal by other function
                if(action == WatchAction.UPDATED) {
                    return;
                }

                let index: undefined | number = undefined;
                regexArray.lastIndex = 0;
                regexObject.lastIndex = 0;
                let resultArray = regexArray.exec(path);
                if(resultArray) {
                    index = Number(resultArray[1]);
                }
                else {
                    let resultObject = regexObject.exec(path);
                    if(resultObject) {
                        let oldKey = resultObject[1];
                        if(action == WatchAction.CREATED) {
                            keys = Object.keys(getElements());
                            index = keys.indexOf(oldKey);
                        }
                        else if(action == WatchAction.DELETED) {
                            index = keys.indexOf(oldKey);
                            keys = Object.keys(getElements());
                        }


                    }
                }

                if(index !== undefined) {
                    let registry = this.loopRegisteries[loop.anchorId];
                    if(action == WatchAction.CREATED) {
                        let context = new TemplateContext(this.component, {}, this.context, registry);
                        context.registerLoop(simple.data, index, indexName, simple.index, simple.item);
                        let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
                        let actions = loop.template.actions;
                        let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);
                        instance.render();

                        let anchor: HTMLElement | null;
                        if(index < registry.templates.length) {
                            anchor = registry.templates[index].firstChild;
                        }
                        else {
                            anchor = this._components[loop.anchorId][0];
                        }

                        anchor?.parentNode?.insertBefore(instance.content, anchor);
                        registry.templates.splice(index, 0, instance);
                        for(let i = index + 1; i < registry.templates.length; i++) {
                            registry.templates[i].context.increaseIndex(indexName);

                        }
                    }
                    else if(action == WatchAction.DELETED) {
                        registry.templates[index].destructor();
                        registry.templates.splice(index, 1);
                        for(let i = index; i < registry.templates.length; i++) {
                            registry.templates[i].context.decreaseIndex(indexName);
                        }
                    }
                }
            };
            this.loopRegisteries[loop.anchorId].sub = sub;
            elements.subscribe(sub);
        }

        let anchor = this._components[loop.anchorId][0];
        for(let i = 0; i < keys.length; i++) {
            let context = new TemplateContext(this.component, {}, this.context, this.loopRegisteries[loop.anchorId]);
            context.registerLoop(simple.data, i, indexName, simple.index, simple.item);
            let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = loop.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, loop.template.loops, loop.template.ifs, context);
            instance.render();
            anchor.parentNode?.insertBefore(instance.content, anchor);
            this.loopRegisteries[loop.anchorId].templates.push(instance);

        }
    }

    private renderIf(_if: If) {
        let computeds: Computed<boolean>[] = [];
        let instances: TemplateInstance[] = [];
        let anchor = this._components[_if.anchorId][0];
        let currentActive: number = -1;
        const calculateActive = () => {
            let newActive = -1;
            for(let i = 0; i < _if.parts.length; i++) {
                if(computeds[i].value) {
                    newActive = i;
                    break;
                }
            }

            if(newActive == currentActive) {
                return;
            }

            if(currentActive != -1) {
                let instance = instances[currentActive];
                let node: Element | null = instance.firstChild;
                while(node && node != instance.lastChild) {
                    let next = node.nextElementSibling;
                    instance.content.appendChild(node);
                    node = next;
                }
                if(instance.lastChild)
                    instance.content.appendChild(instance.lastChild);
            }

            currentActive = newActive;
            if(instances[currentActive])
                anchor.parentNode?.insertBefore(instances[currentActive].content, anchor);
        };

        for(let i = 0; i < _if.parts.length; i++) {
            const part = _if.parts[i];
            let _class = part.once ? ComputedNoRecomputed : Computed;
            let computed = new _class(() => {
                return part.condition(this.context);
            });
            computeds.push(computed);
            computed.subscribe(() => {
                calculateActive();
            });
            this.computeds.push(computed);



            let context = new TemplateContext(this.component, {}, this.context);
            let content = part.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = part.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, part.template.loops, part.template.ifs, context);
            instances.push(instance);
            instance.render();
        }

        calculateActive();
    }

}

export class TemplateContext {
    public data: { [name: string]: any; } = {};
    public comp: WebComponent;
    private computeds: Computed[] = [];
    private watch: any;
    private registry?: LoopRegistery;
    private isDestroyed: boolean = false;

    public constructor(component: WebComponent, data: { [key: string]: any; } = {}, parentContext?: TemplateContext, registry?: LoopRegistery) {
        this.comp = component;
        this.registry = registry;
        this.watch = Watcher.get({});
        let that = this;
        for(let key in data) {
            if(data[key].__isProxy) {
                Object.defineProperty(this.data, key, {
                    get() {
                        return data[key];
                    }
                });
            }
            else {
                this.watch[key] = data[key];
                Object.defineProperty(this.data, key, {
                    get() {
                        return that.watch[key];
                    }
                });
            }
        }

        if(parentContext) {
            const descriptors = Object.getOwnPropertyDescriptors(parentContext.data);
            for(let name in descriptors) {
                Object.defineProperty(this.data, name, {
                    get() {
                        return parentContext.data[name];
                    }
                });
            }
        }
    }

    public print(value: any) {
        return value == null ? "" : value + "";
    }


    public registerIndex() {
        let name = "index";
        let i = 0;
        let fullName = name + i;
        while(this.watch[fullName] !== undefined) {
            i++;
            fullName = name + i;
        }
        return fullName;
    }

    public registerLoop(dataName: string, _indexValue: number, _indexName: string, indexName: string | undefined, itemName: string | undefined) {
        this.watch[_indexName] = _indexValue;
        let getItems: Computed<any[]>;
        let mustBeRecomputed = /if|switch|\?|\[.+?\]/g.test(dataName);
        let _class = mustBeRecomputed ? Computed : ComputedNoRecomputed;
        if(!dataName.startsWith("this.")) {
            getItems = new _class(() => {
                return getValueFromObject(dataName, this.data);
            });
        }
        else {
            dataName = dataName.replace(/^this\./, '');
            getItems = new _class(() => {
                return getValueFromObject(dataName, this.comp);
            });
        }

        let getIndex: Computed<any> = new ComputedNoRecomputed(() => {
            let items = getItems.value;
            if(!items) throw 'impossible';
            let keys = Object.keys(items);
            let index = keys[_getIndex.value];
            if(/^[0-9]+$/g.test(index)) return Number(index);
            return index;
        });
        let getItem: Computed<any> = new ComputedNoRecomputed(() => {
            let items = getItems.value;
            if(!items) throw 'impossible';
            let keys = Object.keys(items);
            let index = keys[_getIndex.value];
            let element = items[index];
            if(element === undefined && (Array.isArray(items) || !items)) {
                debugger;
                if(this.registry) {
                    let indexNb = Number(_getIndex.value);
                    if(!isNaN(indexNb)) {
                        this.registry.templates[indexNb].destructor();
                        this.registry.templates.splice(indexNb, 1);
                        for(let i = indexNb; i < this.registry.templates.length; i++) {
                            this.registry.templates[i].context.decreaseIndex(_indexName);
                        }
                    }
                }
            }
            return element;
        });
        let _getIndex: Computed<any> = new ComputedNoRecomputed(() => {
            return this.watch[_indexName];
        });

        this.computeds.push(getIndex);
        this.computeds.push(getItem);
        this.computeds.push(_getIndex);
        if(itemName) {
            Object.defineProperty(this.data, itemName, {
                get() {
                    return getItem.value;
                }
            });
        }
        if(indexName) {
            Object.defineProperty(this.data, indexName, {
                get() {
                    return getIndex.value;
                }
            });
        }
    }

    private updateIndex(newIndex: number, _indexName: string) {
        // let fullName: string;
        // let items: any[] | {};
        // if(!dataName.startsWith("this.")) {
        //     let comp = new Computed(() => {
        //         return getValueFromObject(dataName, this.data);
        //     });
        //     items = comp.value;
        //     fullName = comp.callbacks[comp.callbacks.length - 1].path;
        // }
        // else {
        //     fullName = dataName.replace(/^this\./, '');
        //     items = getValueFromObject(fullName, this.comp);
        // }

        // if(Array.isArray(items)) {
        //     let regex = new RegExp("^(" + fullName.replace(/\./g, "\\.") + ")\\[(\\d+?)\\]");
        //     for(let computed of computeds) {
        //         for(let cb of computed.callbacks) {
        //             regex.lastIndex = 0;
        //             cb.path = cb.path.replace(regex, "$1[" + newIndex + "]");
        //         }
        //     }
        // }
        // else {
        //     let oldKey = Object.keys(items)[this.watch[_indexName]]
        //     let newKey = Object.keys(items)[newIndex]
        //     let regex = new RegExp("^(" + fullName.replace(/\./g, "\\.") + "\\.)(" + oldKey + ")($|\\.)");
        //     for (let computed of computeds) {
        //         for (let cb of computed.callbacks) {
        //             regex.lastIndex = 0;
        //             cb.path = cb.path.replace(regex, "$1" + newKey + "$3")
        //         }
        //     }
        // }

        this.watch[_indexName] = newIndex;
    }
    public increaseIndex(_indexName: string) {
        this.updateIndex(this.watch[_indexName] + 1, _indexName);
    }
    public decreaseIndex(_indexName: string) {
        this.updateIndex(this.watch[_indexName] - 1, _indexName);
    }


    public destructor() {
        this.isDestroyed = true;
        for(let computed of this.computeds) {
            computed.destroy();
        }
        this.computeds = [];
    }

    public registerWatch(name: string, value: any) {
        let that = this;
        that.watch[name] = value;
        Object.defineProperty(that.data, name, {
            get() {
                return that.watch[name];
            }
        });
    }
    public updateWatch(name: string, value: any) {
        this.watch[name] = value;
    }

    public getValueFromItem(name: string) {
        if(!name) return undefined;

        let result = getValueFromObject(name, this.data);
        if(result !== undefined) {
            return result;
        }

        result = getValueFromObject(name, this.comp);
        if(result !== undefined) {
            return result;
        }

        return undefined;
    }
    public setValueToItem(name: string, value: any) {
        setValueToObject(name, this.comp, value);
    }
}

