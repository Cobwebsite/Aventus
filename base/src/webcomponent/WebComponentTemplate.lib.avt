import { Computed, Effect, WatchAction, Watcher } from "../lib/Watcher.lib.avt";
import { PressManager, type PressManagerOptions } from "../lib/PressManager.lib.avt";
import { WebComponent } from "./WebComponent.lib.avt";

type TemplateHTML = { slots: { [name: string]: string; }, blocks: { [name: string]: string; }; };

type ActionChange = {
    fct: (c: TemplateContext) => string;
};
type ActionInjection = {
    id: string,
    injectionName: string;
    inject: (c: TemplateContext) => any;
    path?: string;
};
type ActionBindings = {
    id: string,
    valueName: string,
    eventNames: string[],
    isCallback?: boolean,
    path?: string,
};
type ActionEventListener = (e: Event, c: TemplateContext) => void;
type ActionEventCallback = (c: TemplateContext, ...args: any) => void;
type ActionEvent = {
    id: string,
    eventName: string,
    isCallback?: boolean,
    fct: ActionEventListener & ActionEventCallback,
};

type Actions = {
    elements?: { name: string, ids: string[], isArray?: boolean; }[],
    content?: { [id_attr: string]: ActionChange; },
    injection?: {
        [contextProp: string]: ActionInjection[];
    };
    bindings?: {
        [contextProp: string]: ActionBindings[];
    };
    events?: ActionEvent[];
    pressEvents?: PressManagerOptions[];
};
type Loop = {
    data: string,
    item: string,
    index: string,
    anchorId: string,
    template: Template;
};
type If = {
    anchorId: string;
    parts: {
        condition: (c: TemplateContext) => boolean;
        template: Template;
    }[];
};

export class Template {
    public static setValueToItem(path: string, obj: any, value: any) {
        let splitted = path.split(".");
        for(let i = 0; i < splitted.length - 1; i++) {
            let split = splitted[i];
            if(!obj[split]) {
                obj[split] = {};
            }
            obj = obj[split];
        }
        obj[splitted[splitted.length - 1]] = value;
    }
    public static getValueFromItem(path: string, obj: any) {
        let splitted = path.split(".");
        for(let i = 0; i < splitted.length - 1; i++) {
            let split = splitted[i];
            if(!obj[split] || typeof obj[split] !== 'object') {
                return undefined;
            }
            obj = obj[split];
        }
        if(!obj || typeof obj !== 'object') {
            return undefined;
        }
        return obj[splitted[splitted.length - 1]];
    }
    public static validatePath(path: string, pathToCheck: string) {
        if(pathToCheck.startsWith(path)) {
            return true;
        }
        return false;
    }

    public cst: typeof WebComponent;
    public constructor(component: typeof WebComponent) {
        this.cst = component;
    }

    //#region only used for main template
    private htmlParts: TemplateHTML[] = [];
    public setHTML(data: TemplateHTML) {
        this.htmlParts.push(data);
    }
    public generateTemplate(): void {
        this.template = document.createElement('template');
        let currentHTML = "<slot></slot>";
        let previousSlots: { [name: string]: string; } = {
            default: '<slot></slot>'
        };
        for(let htmlPart of this.htmlParts) {
            for(let blockName in htmlPart.blocks) {
                if(!previousSlots.hasOwnProperty(blockName)) {
                    throw "can't found slot with name " + blockName;
                }
                currentHTML = currentHTML.replace(previousSlots[blockName], htmlPart.blocks[blockName]);
            }
            for(let slotName in htmlPart.slots) {
                previousSlots[slotName] = htmlPart.slots[slotName];
            }
        }
        this.template.innerHTML = currentHTML;
    }
    //#endregion

    /**
     * Used by the for loop and the if
     * @param template 
     */
    public setTemplate(template: string) {
        this.template = document.createElement('template');
        this.template.innerHTML = template;
    }

    public template!: HTMLTemplateElement;
    public actions: Actions = {};
    public setActions(actions: Actions) {
        if(!this.actions) {
            this.actions = actions;
        }
        else {
            if(actions.elements) {
                if(!this.actions.elements) { this.actions.elements = []; }
                this.actions.elements = [...actions.elements, ...this.actions.elements];
            }
            if(actions.events) {
                if(!this.actions.events) { this.actions.events = []; }
                this.actions.events = [...actions.events, ...this.actions.events];
            }
            if(actions.pressEvents) {
                if(!this.actions.pressEvents) { this.actions.pressEvents = []; }
                this.actions.pressEvents = [...actions.pressEvents, ...this.actions.pressEvents];
            }


            if(actions.content) {
                if(!this.actions.content) {
                    this.actions.content = actions.content;
                }
                else {
                    for(let contextProp in actions.content) {
                        if(!this.actions.content[contextProp]) {
                            this.actions.content[contextProp] = actions.content[contextProp];
                        }
                        else {
                            throw 'this should be impossible';
                        }
                    }
                }
            }

            if(actions.injection) {
                if(!this.actions.injection) {
                    this.actions.injection = actions.injection;
                }
                else {
                    for(let contextProp in actions.injection) {
                        if(!this.actions.injection[contextProp]) {
                            this.actions.injection[contextProp] = actions.injection[contextProp];
                        }
                        else {
                            this.actions.injection[contextProp] = { ...actions.injection[contextProp], ...this.actions.injection[contextProp] };
                        }
                    }
                }
            }

            if(actions.bindings) {
                if(!this.actions.bindings) {
                    this.actions.bindings = actions.bindings;
                }
                else {
                    for(let contextProp in actions.bindings) {
                        if(!this.actions.bindings[contextProp]) {
                            this.actions.bindings[contextProp] = actions.bindings[contextProp];
                        }
                        else {
                            this.actions.bindings[contextProp] = { ...actions.bindings[contextProp], ...this.actions.bindings[contextProp] };
                        }
                    }
                }
            }
        }
    }

    public loops: Loop[] = [];
    public addLoop(loop: Loop) {
        this.loops.push(loop);
    }

    public ifs: If[] = [];
    public addIf(_if: If) {
        this.ifs.push(_if);
    }


    public createInstance(component: WebComponent) {
        let content = this.template.content.cloneNode(true) as DocumentFragment;
        return new TemplateInstance(component, content, this.actions, "", this.loops, this.ifs);
    }
}



export class TemplateInstance {
    private context: TemplateContext;
    public content: DocumentFragment;
    private actions: Actions;
    private component: WebComponent;
    private _components: { [key: string]: HTMLElement[]; } = {};
    private firstRenderUniqueCb: { [key: string]: () => void; } = {};
    private firstRenderCb: (() => void)[] = [];
    public firstChild: HTMLElement | null;
    public lastChild: HTMLElement | null;
    private computeds: Effect[] = [];
    private pathFrom: string;
    private loopRegisteries: { [name: string]: TemplateInstance[]; } = {};
    private loops: Loop[] = [];
    private ifs: If[] = [];



    public constructor(component: WebComponent, content: DocumentFragment, actions: Actions, pathFrom: string, loops: Loop[], ifs: If[], context?: TemplateContext) {
        this.component = component;
        this.content = content;
        this.actions = actions;
        this.pathFrom = pathFrom;
        this.ifs = ifs;
        this.loops = loops;
        this.context = context ? context : new TemplateContext(component);
        this.firstChild = content.firstChild as HTMLElement;
        this.lastChild = content.lastChild as HTMLElement;

        this.selectElements();
        this.transformActionsListening();
    }

    public render() {
        this.bindEvents();
        for(let cb of this.firstRenderCb) {
            cb();
        }
        for(let key in this.firstRenderUniqueCb) {
            this.firstRenderUniqueCb[key]();
        }

        this.renderSubTemplate();
    }

    public destructor() {
        for(let name in this.loopRegisteries) {
            for(let item of this.loopRegisteries[name]) {
                item.destructor();
            }
        }
        this.loopRegisteries = {};

        this.context.destructor();
        for(let computed of this.computeds) {
            computed.destroy();
        }
        this.computeds = [];
        this.removeFromDOM();
    }
    public removeFromDOM(avoidTrigger: boolean = false) {
        if(avoidTrigger) {
            let node: Element | null = this.firstChild;
            while(node && node != this.lastChild) {
                let next = node.nextElementSibling;
                node.parentNode?.removeChild(node);
                node = next;
            }
            this.lastChild?.parentNode?.removeChild(this.lastChild);
        }
        else {
            let node: Element | null = this.firstChild;
            while(node && node != this.lastChild) {
                let next = node.nextElementSibling;
                node.remove();
                node = next;
            }
            this.lastChild?.remove();
        }
    }

    private selectElements() {
        this._components = {};
        let idEls = Array.from(this.content.querySelectorAll('[_id]'));
        for(let idEl of idEls) {
            let id = idEl.attributes['_id'].value;
            if(!this._components[id]) {
                this._components[id] = [];
            }
            this._components[id].push(idEl as HTMLElement);
        }
        if(this.actions.elements) {
            for(let element of this.actions.elements) {
                let components: HTMLElement[] = [];
                for(let id of element.ids) {
                    if(this._components[id]) {
                        components = [...components, ...this._components[id]];
                    }
                }
                if(element.isArray) {
                    Template.setValueToItem(element.name, this.component, components);
                }
                else if(components[0]) {
                    Template.setValueToItem(element.name, this.component, components[0]);
                }
            }
        }
    }


    private bindEvents() {
        if(this.actions.events) {
            for(let event of this.actions.events) {
                this.bindEvent(event);
            }
        }
        if(this.actions.pressEvents) {
            for(let event of this.actions.pressEvents) {
                this.bindPressEvent(event);
            }
        }
    }
    private bindEvent(event: ActionEvent) {
        if(!this._components[event.id]) {
            return;
        }
        if(event.isCallback) {
            for(let el of this._components[event.id]) {
                let cb = Template.getValueFromItem(event.eventName, el);
                cb?.add((...args) => {
                    // TODO check if it's working
                    event.fct(this.context, args);
                });
            }
        }
        else {
            for(let el of this._components[event.id]) {
                el.addEventListener(event.eventName, (e) => { event.fct(e, this.context); });
            }
        }
    }
    private bindPressEvent(event: PressManagerOptions) {
        let id = event['id'];
        if(id && this._components[id]) {
            let clone: any = {};
            for(let temp in event) {
                if(temp != 'id') {
                    if(event[temp] instanceof Function) {
                        clone[temp] = (e, pressInstance) => { event[temp](e, pressInstance, this.context); };
                    }
                    else {
                        clone[temp] = event[temp];
                    }
                }
            }
            clone.element = this._components[id];
            PressManager.create(clone);
        }
    }

    private transformActionsListening() {
        if(this.actions.content) {
            for(let name in this.actions.content) {
                this.transformChangeAction(name, this.actions.content[name]);
            }
        }
        if(this.actions.injection) {
            for(let name in this.actions.injection) {
                for(let injection of this.actions.injection[name]) {
                    this.transformInjectionAction(name, injection);
                }
            }
        }
        if(this.actions.bindings) {
            for(let name in this.actions.bindings) {
                for(let binding of this.actions.bindings[name]) {
                    this.transformBindigAction(name, binding);
                }
            }
        }
    }

    private transformChangeAction(name: string, change: ActionChange) {
        const [id, attr] = name.split("°");
        if(!this._components[id]) return;

        let computed: Computed<string>;
        let apply = () => { };
        if(attr == "@HTML") {
            apply = () => {
                let value = this.context.print(computed.value);
                for(const el of this._components[id])
                    el.innerHTML = value;
            };
        }
        else {
            apply = () => {
                let value = this.context.print(computed.value);
                if(value === "false") {
                    for(const el of this._components[id]) {
                        el.removeAttribute(attr);
                    }
                }
                else {
                    for(const el of this._components[id]) {
                        el.setAttribute(attr, value);
                    }
                }
            };
        }

        computed = new Computed<string>(() => {
            return change.fct(this.context);
        });

        let timeout: number;
        computed.subscribe((action, path, value) => {
            clearTimeout(timeout);
            // add timeout to group change that append on the same frame (for example index update)
            timeout = setTimeout(() => {
                apply();
            });

        });

        this.computeds.push(computed);

        this.firstRenderUniqueCb[name] = () => {
            apply();
        };
    }

    private transformInjectionAction(name: string, injection: ActionInjection) {
        if(!this._components[injection.id]) return;
        if(injection.path) {
            this.context.registerChange(name, (path) => {
                if(Template.validatePath(path, injection.path ?? '')) {
                    for(const el of this._components[injection.id]) {
                        el[injection.injectionName] = injection.inject(this.context);
                    }
                }
            });
        }
        else {
            this.context.registerChange(name, (path) => {
                for(const el of this._components[injection.id]) {
                    el[injection.injectionName] = injection.inject(this.context);
                }
            });
        }
        this.firstRenderCb.push(() => {
            for(const el of this._components[injection.id]) {
                el[injection.injectionName] = injection.inject(this.context);
            }
        });
    }

    private transformBindigAction(name: string, binding: ActionBindings) {
        if(!this._components[binding.id]) return;
        if(binding.path) {
            this.context.registerChange(name, (path) => {
                let bindingPath = binding.path ?? '';
                if(Template.validatePath(path, bindingPath)) {
                    let valueToSet = this.context.getValueFromItem(bindingPath);
                    for(const el of this._components[binding.id]) {
                        Template.setValueToItem(binding.valueName, el, valueToSet);
                    }
                }
            });
        }
        else {
            binding.path = name;
            this.context.registerChange(name, (path) => {
                let valueToSet = this.context.getValueFromItem(name);
                for(const el of this._components[binding.id]) {
                    Template.setValueToItem(binding.valueName, el, valueToSet);
                }
            });
        }

        if(binding.isCallback) {
            this.firstRenderCb.push(() => {
                for(var el of this._components[binding.id]) {
                    for(let fct of binding.eventNames) {
                        let cb = Template.getValueFromItem(fct, el);
                        cb?.add((value) => {
                            this.context.setValueToItem(binding.path ?? '', value);
                        });
                    }
                    let valueToSet = this.context.getValueFromItem(binding.path ?? '');
                    Template.setValueToItem(binding.valueName, el, valueToSet);
                }
            });
        }
        else {
            this.firstRenderCb.push(() => {
                for(var el of this._components[binding.id]) {
                    for(let fct of binding.eventNames) {
                        el.addEventListener(fct, (e) => {
                            let valueToSet = Template.getValueFromItem(binding.valueName, e.target);
                            this.context.setValueToItem(binding.path ?? '', valueToSet);
                        });
                    }
                    let valueToSet = this.context.getValueFromItem(binding.path ?? '');
                    Template.setValueToItem(binding.valueName, el, valueToSet);
                }
            });
        }
    }

    private renderSubTemplate() {
        for(let loop of this.loops) {
            this.renderLoop(loop);
            this.registerLoopWatchEvent(loop);
        }
        for(let _if of this.ifs) {
            this.renderIf(_if);
        }
    }
    private renderLoop(loop: Loop) {
        if(this.loopRegisteries[loop.anchorId]) {
            for(let item of this.loopRegisteries[loop.anchorId]) {
                item.destructor();
            }
        }
        this.loopRegisteries[loop.anchorId] = [];

        let result: any[];
        let pathFromArray = this.pathFrom == "" ? [] : [this.pathFrom];
        if(loop.data.startsWith("°")) {
            result = Template.getValueFromItem(loop.data, this.context.data);
            let array = loop.data.split(".");
            array.splice(0, 1);
            let txtFinal = array.join(".");
            if(txtFinal != "")
                pathFromArray.push(txtFinal);
        }
        else {
            result = Template.getValueFromItem(loop.data, this.component);
            pathFromArray.push(loop.data);
        }


        let anchor = this._components[loop.anchorId][0];
        for(let i = 0; i < result.length; i++) {
            let context = new TemplateContext(this.component, this.context);
            context.registerLoop(loop.item, loop.data, loop.index, i);

            let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = loop.template.actions;
            let newPathFrom = pathFromArray.join(".") + "[" + i + "]";
            let instance = new TemplateInstance(this.component, content, actions, newPathFrom, loop.template.loops, loop.template.ifs, context);
            instance.render();
            anchor.parentNode?.insertBefore(instance.content, anchor);
            this.loopRegisteries[loop.anchorId].push(instance);
        }
    }
    private registerLoopWatchEvent(loop: Loop) {
        let computed: Effect;
        let pathFromArray = this.pathFrom == "" ? [] : [this.pathFrom];
        if(loop.data.startsWith("°")) {
            computed = new Effect(() => {
                Template.getValueFromItem(loop.data, this.context.data);
            });
            let array = loop.data.split(".");
            array.splice(0, 1);
            let txtFinal = array.join(".");
            if(txtFinal != "")
                pathFromArray.push(txtFinal);
        }
        else {
            computed = new Effect(() => {
                Template.getValueFromItem(loop.data, this.component);
            });
            pathFromArray.push(loop.data);
        }

        let regex = new RegExp(loop.data.replace(/\./g, "\\.") + "\\[(\\d+?)\\]$");
        computed.subscribe((action, path, value) => {
            if(path == loop.data) {
                this.renderLoop(loop);
                return;
            }
            regex.lastIndex = 0;
            let result = regex.exec(path);
            if(result) {
                let registry = this.loopRegisteries[loop.anchorId];
                let index = Number(result[1]);
                if(action == WatchAction.CREATED) {
                    let context = new TemplateContext(this.component, this.context);
                    context.registerLoop(loop.item, loop.data, loop.index, index);
                    let content = loop.template.template?.content.cloneNode(true) as DocumentFragment;
                    let actions = loop.template.actions;
                    let newPathFrom = pathFromArray.join(".") + "[" + index + "]";
                    let instance = new TemplateInstance(this.component, content, actions, newPathFrom, loop.template.loops, loop.template.ifs, context);
                    instance.render();

                    let anchor: HTMLElement | null;
                    if(index < registry.length) {
                        anchor = registry[index].firstChild;
                    }
                    else {
                        anchor = this._components[loop.anchorId][0];
                    }

                    anchor?.parentNode?.insertBefore(instance.content, anchor);
                    registry.splice(index, 0, instance);
                    for(let i = index + 1; i < registry.length; i++) {
                        registry[i].context.increaseIndex(loop.index);
                    }
                }
                else if(action == WatchAction.UPDATED) {
                    registry[index].render();
                }
                else if(action == WatchAction.DELETED) {
                    registry[index].destructor();
                    registry.splice(index, 1);
                    for(let i = index; i < registry.length; i++) {
                        registry[i].context.decreaseIndex(loop.index);
                    }
                }
            }
        });

        this.computeds.push(computed);
    }
    private renderIf(_if: If) {
        let computeds: Computed<boolean>[] = [];
        let instances: TemplateInstance[] = [];
        let anchor = this._components[_if.anchorId][0];
        let currentActive: number = -1;
        const calculateActive = () => {
            let newActive = -1;
            for(let i = 0; i < _if.parts.length; i++) {
                if(computeds[i].value) {
                    newActive = i;
                    break;
                }
            }

            if(newActive == currentActive) {
                return;
            }

            if(currentActive != -1) {
                let instance = instances[currentActive];
                let node: Element | null = instance.firstChild;
                while(node && node != instance.lastChild) {
                    let next = node.nextElementSibling;
                    instance.content.appendChild(node);
                    node = next;
                }
                if(instance.lastChild)
                    instance.content.appendChild(instance.lastChild);
            }

            currentActive = newActive;
            anchor.parentNode?.insertBefore(instances[currentActive].content, anchor);
        };

        for(let i = 0; i < _if.parts.length; i++) {
            const part = _if.parts[i];
            let computed = new Computed<boolean>(() => {
                return part.condition(this.context);
            });
            computeds.push(computed);
            computed.subscribe(() => {
                calculateActive();
            });
            this.computeds.push(computed);



            let context = new TemplateContext(this.component, this.context);
            let content = part.template.template?.content.cloneNode(true) as DocumentFragment;
            let actions = part.template.actions;
            let instance = new TemplateInstance(this.component, content, actions, this.pathFrom, part.template.loops, part.template.ifs, context);
            instances.push(instance);
            instance.render();
        }

        calculateActive();
    }

}

export class TemplateContext {
    public data: { [name: string]: any; } = {};
    public comp: WebComponent;
    private computeds: Computed[] = [];
    private watch: any;

    public constructor(component: WebComponent, parentContext?: TemplateContext) {
        this.comp = component;
        this.watch = Watcher.get({});

        if(parentContext) {
            const descriptors = Object.getOwnPropertyDescriptors(parentContext.data);
            for(let name in descriptors) {
                Object.defineProperty(this.data, name, {
                    get() {
                        return parentContext.data.name;
                    }
                });
            }
        }
    }

    public print(value: any) {
        return value == null ? "" : value + "";
    }


    public increaseIndex(indexName: string) {
        this.watch[indexName] = this.watch[indexName] + 1;
    }
    public decreaseIndex(indexName: string) {
        this.watch[indexName] = this.watch[indexName] - 1;
    }
    public registerLoop(itemName: string, dataName: string, indexName: string, indexValue: number | string) {
        this.watch[indexName] = indexValue;
        let getItem: Computed<any>;
        let getIndex: Computed<any> = new Computed(() => {
            return this.watch[indexName];
        });

        if(dataName.startsWith("°")) {
            // it's a local variable from another loop
            getItem = new Computed(() => {
                let indexValue = this.data[indexName];
                return Template.getValueFromItem(dataName, this.data)[indexValue];
            });
        }
        else {
            // its a variable from the component
            getItem = new Computed(() => {
                let indexValue = this.data[indexName];
                return Template.getValueFromItem(dataName, this.comp)[indexValue];
            });
        }
        this.computeds.push(getItem);
        this.computeds.push(getIndex);
        Object.defineProperty(this.data, itemName, {
            get() {
                return getItem.value;
            }
        });
        Object.defineProperty(this.data, indexName, {
            get() {
                return getIndex.value;
            }
        });
    }

    public registerChange(name: string, fct: (path: string) => void) {
        let computed: Computed<any>;
        if(name.startsWith("°")) {
            // it's a local variable from another loop
            computed = new Computed(() => {
                return Template.getValueFromItem(name, this.data);
            });
        }
        else {
            // its a variable from the component
            computed = new Computed(() => {
                return Template.getValueFromItem(name, this.comp);
            });
        }
        this.computeds.push(computed);
        computed.subscribe((action, path, value) => {
            fct(path);
        });
    }

    public destructor() {
        for(let computed of this.computeds) {
            computed.destroy();
        }
        this.computeds = [];
    }

    public getValueFromItem(name: string) {
        let result = Template.getValueFromItem(name, this.data);
        if(result !== undefined) {
            return result;
        }

        result = Template.getValueFromItem(name, this.comp);
        if(result !== undefined) {
            return result;
        }

        return undefined;
    }

    public setValueToItem(name: string, value: any) {
        Template.setValueToItem(name, this.comp, value);
    }
}

