import { NormalizedEvent, PressManager } from "./PressManager.lib.avt";
@Storybook({
    prefix: "Lib/DragAndDrop"
})
export interface DragAndDropOptionsShadow {
    /** If set to true, the drag and drop will create a shadow element while dragging and removing it on drop. It will not move the original element anymore */
    enable: boolean,
    /** The container where the shadow element will be added, default is body */
    container?: DragElement;
    /** Remove shadow from tree */
    removeOnStop?: boolean,
    /** Add custom transformation for the shadow element */
    transform?: (el: DragElement) => void;
    /** Trigger to destroy the clone element, If you set the paramater you must remove the element from DOM yourself */
    delete?: (el: DragElement) => void;
}

export type DragElement = DragElementXY | DragElementLeftRight;
export type DragElementXY = SVGGElement | SVGRectElement | SVGEllipseElement | SVGTextElement;
export type DragElementLeftRight = HTMLElement | SVGElement;


@Storybook({
    prefix: "Lib/DragAndDrop"
})
export interface DragAndDropOptions {
    /** If set to false, the element won't move */
    applyDrag?: boolean;
    /** Element to drag and drog */
    element: DragElement;
    /** Element that trigger the drag action; default is element */
    elementTrigger?: DragElement;
    /** Set the default offset for the drag trigger; default is DragAndDrop.defaultOffsetDrag */
    offsetDrag?: number;
    /** Options to create a shadow element */
    shadow?: DragAndDropOptionsShadow;
    /** If set to false, the element will be considered as in the target if it touches it */
    strict?: boolean;
    /** The targets for the drop action */
    targets?: DragElement[] | (() => DragElement[]);
    /** Use percent instead of pixel */
    usePercent?: boolean;
    /** Stop Propagation */
    stopPropagation?: boolean | (() => boolean);

    /** Determine if drag is active or not */
    isDragEnable?: () => boolean;
    /** Get current zoom */
    getZoom?: () => number;
    /** Get offset X in px related to element.offsetTarget */
    getOffsetX?: () => number;
    /** Get offset Y in px related to element.offsetTarget */
    getOffsetY?: () => number;
    /** Trigger on pointer down*/
    onPointerDown?: (e: NormalizedEvent) => void;
    /** Trigger on pointer up*/
    onPointerUp?: (e: NormalizedEvent) => void;
    /** Trigger on drag start*/
    onStart?: (e: NormalizedEvent) => void | boolean;
    /** Trigger on moving  */
    onMove?: (e: NormalizedEvent, position: Coordinate) => void;
    /** Trigger after stop moving */
    onStop?: (e: NormalizedEvent) => void;
    /** Trigger after drop if at least one target found; Element is the shadow or the target*/
    onDrop?: (element: DragElement, targets: DragElement[]) => void;
    /** correct the position if you need */
    correctPosition?: (position: Coordinate) => Coordinate;
}
@Storybook({
    prefix: "Lib/DragAndDrop"
})
    type DragAndDropOptionsInternal = Required<DragAndDropOptions> & { shadow: Required<DragAndDropOptionsShadow>; };

@Storybook({
    prefix: "Lib/DragAndDrop"
})
interface Coordinate {
    x: number;
    y: number;
}

@Storybook({
    prefix: "Lib/DragAndDrop"
})
export class DragAndDrop {
    /**
     * Default offset before drag element
     */
    public static defaultOffsetDrag: number = 20;
    private pressManager: PressManager;
    private options: DragAndDropOptionsInternal;
    private startCursorPosition: Coordinate = { x: 0, y: 0 };
    private startElementPosition: Coordinate = { x: 0, y: 0 };
    private isEnable: boolean = true;
    private draggableElement!: DragElement;


    constructor(options: DragAndDropOptions) {
        this.options = this.getDefaultOptions(options.element);
        this.mergeProperties(options);
        this.mergeFunctions(options);
        this.options.elementTrigger.style.touchAction = 'none';
        this.pressManager = new PressManager({
            element: this.options.elementTrigger,
            onPressStart: this.onPressStart.bind(this),
            onPressEnd: this.onPressEnd.bind(this),
            onDragStart: this.onDragStart.bind(this),
            onDrag: this.onDrag.bind(this),
            onDragEnd: this.onDragEnd.bind(this),
            offsetDrag: this.options.offsetDrag,
            stopPropagation: this.options.stopPropagation
        });
    }
    // #region merge params
    private getDefaultOptions(element: DragElement): DragAndDropOptionsInternal {
        return {
            applyDrag: true,
            element: element,
            elementTrigger: element,
            offsetDrag: DragAndDrop.defaultOffsetDrag,
            shadow: {
                enable: false,
                container: document.body,
                removeOnStop: true,
                transform: () => { },
                delete: (el) => {
                    el.remove();
                }
            },
            strict: false,
            targets: [],
            usePercent: false,
            stopPropagation: true,

            isDragEnable: () => true,
            getZoom: () => 1,
            getOffsetX: () => 0,
            getOffsetY: () => 0,
            onPointerDown: (e: NormalizedEvent) => { },
            onPointerUp: (e: NormalizedEvent) => { },
            onStart: (e: NormalizedEvent) => { },
            onMove: (e: NormalizedEvent) => { },
            onStop: (e: NormalizedEvent) => { },
            onDrop: (element: DragElement, targets: DragElement[]) => { },
            correctPosition: (position: Coordinate) => position
        };
    }
    private mergeProperties(options: DragAndDropOptions) {
        if(options.element === void 0) {
            throw "You must define the element for the drag&drop";
        }
        this.options.element = options.element;
        if(options.elementTrigger === void 0) {
            this.options.elementTrigger = this.options.element;
        }
        else {
            this.options.elementTrigger = options.elementTrigger;
        }
        this.defaultMerge(options, "applyDrag");
        this.defaultMerge(options, "offsetDrag");
        this.defaultMerge(options, "strict");
        this.defaultMerge(options, "targets");
        this.defaultMerge(options, "usePercent");
        this.defaultMerge(options, "stopPropagation");
        if(options.shadow !== void 0) {
            this.options.shadow.enable = options.shadow.enable;
            if(options.shadow.container !== void 0) {
                this.options.shadow.container = options.shadow.container;
            }
            else {
                this.options.shadow.container = document.body;
            }
            if(options.shadow.removeOnStop !== void 0) {
                this.options.shadow.removeOnStop = options.shadow.removeOnStop;
            }
            if(options.shadow.transform !== void 0) {
                this.options.shadow.transform = options.shadow.transform;
            }
            if(options.shadow.delete !== void 0) {
                this.options.shadow.delete = options.shadow.delete;
            }
        }
    }
    private mergeFunctions(options: DragAndDropOptions) {
        this.defaultMerge(options, "isDragEnable");
        this.defaultMerge(options, "getZoom");
        this.defaultMerge(options, "getOffsetX");
        this.defaultMerge(options, "getOffsetY");
        this.defaultMerge(options, "onPointerDown");
        this.defaultMerge(options, "onPointerUp");
        this.defaultMerge(options, "onStart");
        this.defaultMerge(options, "onMove");
        this.defaultMerge(options, "onStop");
        this.defaultMerge(options, "onDrop");
        this.defaultMerge(options, "correctPosition");
    }
    private defaultMerge(options: DragAndDropOptions, name: string) {
        if(options[name] !== void 0) {
            this.options[name] = options[name];
        }
    }
    // #endregion

    private positionShadowRelativeToElement: Coordinate = { x: 0, y: 0 };
    private onPressStart(e: NormalizedEvent) {
        this.options.onPointerDown(e);
    }
    private onPressEnd(e: NormalizedEvent) {
        this.options.onPointerUp(e);
    }
    private onDragStart(e: NormalizedEvent): void | boolean {
        this.isEnable = this.options.isDragEnable();
        if(!this.isEnable) {
            return false;
        }
        let draggableElement = this.options.element;
        this.startCursorPosition = {
            x: e.pageX,
            y: e.pageY
        };
        if(this.isLeftRightElement(draggableElement)) {
            this.startElementPosition = {
                //using getBoundingClientRect because offsetLeft and offsetTop are not working with SVGElements
                x: draggableElement.getBoundingClientRect().left,
                y: draggableElement.getBoundingClientRect().top
            };

        }
        else {
            draggableElement = draggableElement as DragElementXY;
            const transform = draggableElement.getAttribute("transform");
            const tvalue = transform?.match(/translate\(([^,]+),([^,]+)\)/);
            const x = tvalue ? parseFloat(tvalue[1]) : 0;
            const y = tvalue ? parseFloat(tvalue[2]) : 0;
            this.startElementPosition = {
                x: x,
                y: y
            };
        }

        if(this.options.shadow.enable) {
            draggableElement = this.options.element.cloneNode(true) as DragElement;
            let elBox = this.options.element.getBoundingClientRect();
            let containerBox = this.options.shadow.container.getBoundingClientRect();
            this.positionShadowRelativeToElement = {
                x: elBox.x - containerBox.x,
                y: elBox.y - containerBox.y
            };
            if(this.options.applyDrag) {
                draggableElement.style.position = "absolute";
                draggableElement.style.top = this.positionShadowRelativeToElement.y + this.options.getOffsetY() + 'px';
                draggableElement.style.left = this.positionShadowRelativeToElement.x + this.options.getOffsetX() + 'px';
            }
            this.options.shadow.transform(draggableElement);
            this.options.shadow.container.appendChild(draggableElement);
        }
        this.draggableElement = draggableElement;
        return this.options.onStart(e);
    }
    private onDrag(e: NormalizedEvent) {
        if(!this.isEnable) {
            return;
        }
        let zoom = this.options.getZoom();
        let diff: Coordinate = {
            x: 0,
            y: 0
        };
        if(this.options.shadow.enable) {
            diff = {
                x: (e.pageX - this.startCursorPosition.x) + this.positionShadowRelativeToElement.x + this.options.getOffsetX(),
                y: (e.pageY - this.startCursorPosition.y) + this.positionShadowRelativeToElement.y + this.options.getOffsetY(),
            };
        }
        else {
            diff = {
                x: (e.pageX - this.startCursorPosition.x) / zoom + this.startElementPosition.x + this.options.getOffsetX(),
                y: (e.pageY - this.startCursorPosition.y) / zoom + this.startElementPosition.y + this.options.getOffsetY()
            };
        }
        let newPos = this.setPosition(diff);
        this.options.onMove(e, newPos);
    }
    private onDragEnd(e: NormalizedEvent) {
        if(!this.isEnable) {
            return;
        }
        let targets = this.getMatchingTargets();
        let draggableElement = this.draggableElement;
        if(this.options.shadow.enable && this.options.shadow.removeOnStop) {
            this.options.shadow.delete(draggableElement);
        }
        if(targets.length > 0) {
            this.options.onDrop(this.options.element, targets);
        }

        this.options.onStop(e);
    }
    private setPosition(position: Coordinate): Coordinate {
        let draggableElement = this.draggableElement;
        if(this.options.usePercent) {
            if(draggableElement instanceof HTMLElement) {
                let elementParent = draggableElement.offsetParent as HTMLElement;
                let percentPosition = {
                    x: (position.x / elementParent.offsetWidth) * 100,
                    y: (position.y / elementParent.offsetHeight) * 100
                };
                percentPosition = this.options.correctPosition(percentPosition);
                if(this.options.applyDrag) {
                    draggableElement.style.left = percentPosition.x + '%';
                    draggableElement.style.top = percentPosition.y + '%';
                }
                return percentPosition;
            }
            else {
                console.error("usePercent is not supported for anything else than HTMLElement");
            }
        }
        else {
            position = this.options.correctPosition(position);
            if(this.options.applyDrag) {
                if(this.isLeftRightElement(draggableElement)) {
                    draggableElement.style.left = position.x + 'px';
                    draggableElement.style.top = position.y + 'px';
                }
                else {
                    draggableElement.setAttribute("transform", `translate(${position.x},${position.y})`);
                }
            }
        }
        return position;
    }
    /**
     * Get targets within the current element position is matching
     */
    public getMatchingTargets(): DragElement[] {
        let draggableElement = this.draggableElement;
        let matchingTargets: DragElement[] = [];
        let srcTargets: DragElement[];
        if(typeof this.options.targets == "function") {
            srcTargets = this.options.targets();
        }
        else {
            srcTargets = this.options.targets;
        }
        for(let target of srcTargets) {
            const elementCoordinates = draggableElement.getBoundingClientRect();
            const targetCoordinates = target.getBoundingClientRect();
            let offsetX = this.options.getOffsetX();
            let offsetY = this.options.getOffsetY();
            let zoom = this.options.getZoom();
            targetCoordinates.x += offsetX;
            targetCoordinates.y += offsetY;
            targetCoordinates.width *= zoom;
            targetCoordinates.height *= zoom;
            if(this.options.strict) {
                if(
                    (elementCoordinates.x >= targetCoordinates.x && elementCoordinates.x + elementCoordinates.width <= targetCoordinates.x + targetCoordinates.width) &&
                    (elementCoordinates.y >= targetCoordinates.y && elementCoordinates.y + elementCoordinates.height <= targetCoordinates.y + targetCoordinates.height)
                ) {
                    matchingTargets.push(target);
                }
            } else {
                let elementLeft = elementCoordinates.x;
                let elementRight = elementCoordinates.x + elementCoordinates.width;
                let elementTop = elementCoordinates.y;
                let elementBottom = elementCoordinates.y + elementCoordinates.height;
                let targetLeft = targetCoordinates.x;
                let targetRight = targetCoordinates.x + targetCoordinates.width;
                let targetTop = targetCoordinates.y;
                let targetBottom = targetCoordinates.y + targetCoordinates.height;
                if(
                    !(elementRight < targetLeft ||
                        elementLeft > targetRight ||
                        elementBottom < targetTop ||
                        elementTop > targetBottom)
                ) {
                    matchingTargets.push(target);
                }
            }
        }
        return matchingTargets;
    }

    /**
     * Get element currently dragging
     */
    public getElementDrag(): DragElement {
        return this.options.element;
    }
    /**
     * Set targets where to drop
     */
    public setTargets(targets: DragElement[]) {
        this.options.targets = targets;
    }
    /**
     * Set targets where to drop
     */
    public setTargetsFct(targets: () => DragElement[]) {
        this.options.targets = targets;
    }
    /**
     * Destroy the current drag&drop instance
     */
    public destroy() {
        this.pressManager.destroy();
    }

    private isLeftRightElement(element: DragElement): boolean {
        //HOW ???
        return element instanceof HTMLElement || element instanceof SVGSVGElement;
    }
}