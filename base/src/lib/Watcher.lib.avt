import { Template } from "../webcomponent/WebComponentTemplate.lib.avt";
import { compareObject, getValueFromObject } from "../tools/CompareObject.lib.avt";

type NotVoid<T> = T extends void ? never : T;
export type WatcherFunction = (action: WatchAction, path: string, value: any) => void;

export enum WatchAction {
    CREATED,
    UPDATED,
    DELETED
}

export class Watcher {
    @Internal()
    public static _registering: Effect[] = [];
    @Internal()
    public static get _register(): Effect | undefined {
        return this._registering[this._registering.length - 1];
    }
    /**
     * Transform object into a watcher
     */
    public static get(obj: object, onDataChanged?: WatcherFunction): any {
        if(obj == undefined) {
            console.error("You must define an objet / array for your proxy");
            return;
        }
        if((obj as any).__isProxy) {
            if(onDataChanged)
                (obj as any).subscribe(onDataChanged);
            return obj;
        }
        const reservedName = {
            __path: '__path',
        };
        const clearReservedNames = (data) => {
            if(data instanceof Object && !data.__isProxy) {
                for(let key in reservedName) {
                    delete data[key];
                }
            }
        };
        let setProxyPath = (newProxy, newPath) => {
            if(newProxy instanceof Object && newProxy.__isProxy) {
                newProxy.__path = newPath;
            }
        };
        let jsonReplacer = (key, value) => {
            if(reservedName[key]) return undefined;
            return value;
        };
        let addAlias = (otherBaseData, name, cb) => {
            let cbs = aliases.get(otherBaseData);
            if(!cbs) {
                cbs = [];
                aliases.set(otherBaseData, cbs);
            }
            cbs.push({
                name: name,
                fct: cb
            });
        };
        let deleteAlias = (otherBaseData, name) => {
            let cbs = aliases.get(otherBaseData);
            if(!cbs) return;
            for(let i = 0; i < cbs.length; i++) {
                if(cbs[i].name == name) {
                    cbs.splice(i, 1);
                    if(cbs.length == 0) {
                        aliases.delete(otherBaseData);
                    }
                    return;
                }
            }
        };
        let replaceByAlias = (target, element, prop, receiver) => {
            //#region determine current path internal
            let fullInternalPath = "";
            if(Array.isArray(target)) {
                if(prop != "length") {
                    if((target as any).__path) {
                        fullInternalPath = (target as any).__path;
                    }
                    fullInternalPath += "[" + prop + "]";
                }
            }
            else {
                if(target.__path) {
                    fullInternalPath = target.__path + '.';
                }
                fullInternalPath += prop;
            }
            //#endregion

            //#region remove old binding if exist
            // receiver is set only during a set process
            if(receiver && internalAliases[fullInternalPath]) {
                internalAliases[fullInternalPath].unbind();
            }
            //#endregion

            if(element instanceof Object && element.__isProxy) {
                let root = element.__root;
                if(root != proxyData.baseData) {
                    //#region get real value shared across the 2 proxy
                    let oldPath = element.__path;
                    let unbindElement = getValueFromObject(oldPath, root);
                    //#endregion
                    if(receiver == null) {
                        // get the proxy value to replace it
                        receiver = getValueFromObject(target.__path, realProxy);
                        // it's a weird case but can arrive is the proxy is a sub child of an element added
                        if(internalAliases[fullInternalPath]) {
                            internalAliases[fullInternalPath].unbind();
                        }
                    }
                    //#region assign raw element into the new proxy
                    let result = Reflect.set(target, prop, unbindElement, receiver);
                    //#endregion

                    //#region add alias into the parent to notify trigger
                    element.__addAlias(proxyData.baseData, oldPath, (type, target, receiver2, value, prop2, dones) => {

                        let triggerPath: string;
                        if(prop2.startsWith("[") || fullInternalPath == "" || prop2 == "") {
                            triggerPath = fullInternalPath + prop2;
                        }
                        else {
                            triggerPath = fullInternalPath + "." + prop2;
                        }
                        triggerPath = triggerPath.replace(/\[(.*?)\]/g, '.$1');
                        if(type == 'DELETED' && internalAliases[triggerPath]) {
                            internalAliases[triggerPath].unbind();
                        }
                        let splitted = triggerPath.split(".");
                        let newProp = splitted.pop();
                        let newReceiver = getValueFromObject(splitted.join("."), realProxy);
                        trigger(type, target, newReceiver, value, newProp, dones);
                    });
                    //#enregion


                    //#region add alias internal and create function to unbind from parent
                    internalAliases[fullInternalPath] = {
                        unbind: () => {
                            delete internalAliases[fullInternalPath];
                            element.__deleteAlias(proxyData.baseData, oldPath);
                            deleteAlias(root, prop);
                        }
                    };
                    //#enregion


                    //#region set internal alias to notify parent from changes
                    addAlias(root, prop, (type, target, receiver2, value, prop2: string, dones: any[]) => {
                        let proxy = element.__getProxy;
                        let triggerPath: string;
                        if(prop2.startsWith("[") || oldPath == "" || prop2 == "") {
                            triggerPath = oldPath + prop2;
                        }
                        else {
                            triggerPath = oldPath + "." + prop2;
                        }
                        triggerPath = triggerPath.replace(/\[(.*?)\]/g, '.$1');
                        let splitted = triggerPath.split(".");
                        let newProp = splitted.pop();
                        let newReceiver = getValueFromObject(splitted.join("."), proxy);
                        element.__trigger(type, target, newReceiver, value, newProp, dones);
                    });

                    //#endregion

                    return unbindElement;


                }
            }

            return element;
        };
        let currentTrace = new Error().stack?.split("\n") ?? [];
        currentTrace.shift();
        currentTrace.shift();

        const aliases: Map<any, { name: string, fct: any; }[]> = new Map();
        const internalAliases: {
            [key: string]: {
                unbind: () => void;
            };
        } = {};

        type ProxyData = {
            baseData: any,
            callbacks: { [key: string]: WatcherFunction[]; },
            callbacksReverse: Map<WatcherFunction, string>,
            avoidUpdate: string[],
            pathToRemove: string[],
            history: any[],
            useHistory: boolean,
            getProxyObject: (target: any, element: any, prop: string) => any,
            tryCustomFunction: (target: any, prop: string, receiver: any) => any,
            get: (target: any, prop: string, receiver: any) => any,
            set: (target: any, prop: string, value: any, receiver: any) => any,
            deleteProperty: (target: any, prop: string) => boolean,
            defineProperty: (target: any, prop: string, descriptor: any) => boolean,
            ownKeys: (target: any) => (string | symbol)[],
        };
        let proxyData: ProxyData = {
            baseData: {},
            callbacks: {},
            callbacksReverse: new Map<WatcherFunction, string>(),
            avoidUpdate: [],
            pathToRemove: [],
            history: [{
                object: JSON.parse(JSON.stringify(obj, jsonReplacer)),
                trace: currentTrace,
                action: 'init',
                path: ''
            }],
            useHistory: false,
            getProxyObject(target, element, prop) {
                let newProxy;
                element = replaceByAlias(target, element, prop, null);
                if(element instanceof Object && element.__isProxy) {
                    newProxy = element;
                }
                else {
                    try {
                        if(element instanceof Computed) {
                            return element;
                        }
                        if(element instanceof HTMLElement) {
                            return element;
                        }
                        if(element instanceof Object) {
                            newProxy = new Proxy(element, this);
                        } else {
                            return element;
                        }
                    } catch {
                        // it's not an array or object
                        return element;
                    }
                }
                let newPath = '';
                if(Array.isArray(target)) {
                    if(/^[0-9]*$/g.exec(prop)) {
                        if((target as any).__path) {
                            newPath = (target as any).__path;
                        }
                        newPath += "[" + prop + "]";
                        setProxyPath(newProxy, newPath);
                    }
                    else {
                        newPath += "." + prop;
                        setProxyPath(newProxy, newPath);
                    }
                }
                else if(element instanceof Date) {
                    return element;
                }
                else {
                    if(target.__path) {
                        newPath = target.__path + '.';
                    }
                    newPath += prop;
                    setProxyPath(newProxy, newPath);
                }
                return newProxy;

            },
            tryCustomFunction(target, prop, receiver) {
                if(prop == "__isProxy") {
                    return true;
                }
                else if(prop == "__getProxy") {
                    return realProxy;
                }
                else if(prop == "__root") {
                    return this.baseData;
                }
                else if(prop == "__callbacks") {
                    return this.callbacks;
                }
                else if(prop == "subscribe") {
                    let path = receiver.__path;
                    return (cb) => {
                        if(!this.callbacks[path]) {
                            this.callbacks[path] = [];
                        }
                        this.callbacks[path].push(cb);
                        this.callbacksReverse.set(cb, path);
                    };
                }
                else if(prop == "unsubscribe") {
                    return (cb) => {
                        let oldPath = this.callbacksReverse.get(cb);
                        if(oldPath === undefined) return;
                        if(!this.callbacks[oldPath]) {
                            return;
                        }
                        let index = this.callbacks[oldPath].indexOf(cb);
                        if(index > -1) {
                            this.callbacks[oldPath].splice(index, 1);
                        }
                        this.callbacksReverse.delete(cb);
                    };
                }
                else if(prop == "getHistory") {
                    return () => {
                        return this.history;
                    };
                }
                else if(prop == "clearHistory") {
                    this.history = [];
                }
                else if(prop == "enableHistory") {
                    return () => {
                        this.useHistory = true;
                    };
                }
                else if(prop == "disableHistory") {
                    return () => {
                        this.useHistory = false;
                    };
                }
                else if(prop == "getTarget") {
                    return () => {
                        clearReservedNames(target);
                        return target;
                    };
                }
                else if(prop == "toJSON") {
                    if(Array.isArray(target)) {
                        return () => {
                            let result: any[] = [];
                            for(let element of target) {
                                result.push(element);
                            }
                            return result;
                        };
                    }
                    return () => {
                        let result = {};
                        for(let key of Object.keys(target)) {
                            if(reservedName[key]) {
                                continue;
                            }
                            result[key] = target[key];
                        }
                        return result;
                    };
                }
                else if(prop == "__addAlias") {
                    return addAlias;
                }
                else if(prop == "__deleteAlias") {
                    return deleteAlias;
                }
                else if(prop == "__trigger") {
                    return trigger;
                }

                return undefined;
            },
            get(target, prop, receiver) {
                if(reservedName[prop]) {
                    return target[prop];
                }

                let customResult = this.tryCustomFunction(target, prop, receiver);
                if(customResult !== undefined) {
                    return customResult;
                }

                let element = target[prop];
                if(typeof (element) == 'function') {
                    if(Array.isArray(target)) {
                        let result;
                        if(prop == 'push') {
                            if((target as any).__isProxy) {
                                result = (el) => {
                                    let index = target.push(el);
                                    return index;
                                };
                            }
                            else {
                                result = (el) => {
                                    let index = target.push(el);
                                    // get real objetct with proxy to have the correct subscription
                                    target.splice(target.length - 1, 1, el);
                                    trigger('CREATED', target, receiver, receiver[index - 1], "[" + (index - 1) + "]");
                                    trigger('UPDATED', target, receiver, target.length, "length");
                                    return index;
                                };
                            }
                        }
                        else if(prop == 'splice') {
                            if((target as any).__isProxy) {
                                result = (index, nbRemove, ...insert) => {
                                    let res = target.splice(index, nbRemove, ...insert);
                                    return res;
                                };
                            }
                            else {
                                result = (index, nbRemove, ...insert) => {
                                    let oldValues: any[] = [];
                                    for(let i = index; i < index + nbRemove; i++) {
                                        oldValues.push(receiver[i]);
                                    }
                                    let updateLength = nbRemove != insert.length;
                                    let res = target.splice(index, nbRemove, ...insert);
                                    for(let i = 0; i < oldValues.length; i++) {
                                        trigger('DELETED', target, receiver, oldValues[i], "[" + index + "]");
                                    }
                                    for(let i = 0; i < insert.length; i++) {
                                        // get real objetct with proxy to have the correct subscription
                                        target.splice((index + i), 1, insert[i]);
                                        trigger('CREATED', target, receiver, receiver[(index + i)], "[" + (index + i) + "]");
                                    }
                                    // let fromIndex = index + insert.length;
                                    // update path and subscription
                                    // for(let i = fromIndex, j = 0; i < target.length; i++, j++) {
                                    //     let proxyEl = this.getProxyObject(target, target[i], i);

                                    //     let recuUpdate = (childEl) => {
                                    //         if(Array.isArray(childEl)) {
                                    //             for(let i = 0; i < childEl.length; i++) {
                                    //                 if(childEl[i] instanceof Object && childEl[i].__path) {
                                    //                     let newProxyEl = this.getProxyObject(childEl, childEl[i], i);
                                    //                     recuUpdate(newProxyEl);
                                    //                 }
                                    //             }
                                    //         }
                                    //         else if(childEl instanceof Object && !(childEl instanceof Date)) {
                                    //             for(let key in childEl) {
                                    //                 if(childEl[key] instanceof Object && childEl[key].__path) {
                                    //                     let newProxyEl = this.getProxyObject(childEl, childEl[key], key);
                                    //                     recuUpdate(newProxyEl);
                                    //                 }
                                    //             }
                                    //         }
                                    //     };
                                    //     recuUpdate(proxyEl);
                                    // }
                                    if(updateLength)
                                        trigger('UPDATED', target, receiver, target.length, "length");
                                    return res;
                                };
                            }

                        }
                        else if(prop == 'pop') {
                            if((target as any).__isProxy) {
                                result = () => {
                                    let res = target.pop();
                                    return res;
                                };
                            }
                            else {
                                result = () => {
                                    let index = target.length - 1;
                                    let oldValue = receiver.length ? receiver[receiver.length] : undefined;
                                    let res = target.pop();
                                    trigger('DELETED', target, receiver, oldValue, "[" + index + "]");
                                    trigger('UPDATED', target, receiver, target.length, "length");
                                    return res;
                                };
                            }
                        }
                        else {
                            result = element.bind(target);
                        }
                        return result;
                    }
                    return element.bind(target);
                }

                if(element instanceof Computed) {
                    return element.value;
                }

                if(Watcher._registering.length > 0) {
                    let currentPath: string;
                    let fullPath: string;
                    let isArray = Array.isArray(receiver);
                    if(isArray && /^[0-9]*$/g.exec(prop)) {
                        fullPath = receiver.__path + "[" + prop + "]";
                        currentPath = "[" + prop + "]";
                    }
                    else {
                        fullPath = receiver.__path ? receiver.__path + '.' + prop : prop;
                        currentPath = prop;
                    }
                    Watcher._register?.register(receiver, currentPath, Watcher._register.version, fullPath);
                }

                if(typeof (element) == 'object') {
                    return this.getProxyObject(target, element, prop);
                }

                return Reflect.get(target, prop, receiver);
            },
            set(target, prop, value, receiver) {
                value = replaceByAlias(target, value, prop, receiver);
                let triggerChange = false;
                if(!reservedName[prop]) {
                    if(Array.isArray(target)) {
                        if(prop != "length") {
                            triggerChange = true;
                        }
                    }
                    else {
                        let oldValue = Reflect.get(target, prop, receiver);
                        if(!compareObject(value, oldValue)) {
                            triggerChange = true;
                        }
                    }
                }
                let result = Reflect.set(target, prop, value, receiver);
                if(triggerChange) {
                    let index = this.avoidUpdate.indexOf(prop);

                    if(index == -1) {
                        trigger('UPDATED', target, receiver, value, prop);
                    }
                    else {
                        this.avoidUpdate.splice(index, 1);
                    }
                }
                return result;
            },
            deleteProperty(target, prop) {
                let triggerChange = false;
                let pathToDelete = '';
                if(!reservedName[prop]) {
                    if(Array.isArray(target)) {
                        if(prop != "length") {
                            if((target as any).__path) {
                                pathToDelete = (target as any).__path;
                            }
                            pathToDelete += "[" + prop + "]";
                            triggerChange = true;
                        }
                    }
                    else {
                        if(target.__path) {
                            pathToDelete = target.__path + '.';
                        }
                        pathToDelete += prop;
                        triggerChange = true;
                    }
                }
                if(internalAliases[pathToDelete]) {
                    internalAliases[pathToDelete].unbind();
                }
                if(target.hasOwnProperty(prop)) {
                    let oldValue = target[prop];
                    if(oldValue instanceof Effect) {
                        oldValue.destroy();
                    }
                    delete target[prop];
                    if(triggerChange) {
                        clearReservedNames(oldValue);
                        trigger('DELETED', target, null, oldValue, prop);
                    }

                    return true;
                }
                return false;
            },
            defineProperty(target, prop, descriptor) {
                let triggerChange = false;
                let newPath = '';
                if(!reservedName[prop]) {
                    if(Array.isArray(target)) {
                        if(prop != "length") {
                            if((target as any).__path) {
                                newPath = (target as any).__path;
                            }
                            newPath += "[" + prop + "]";
                            if(!target.hasOwnProperty(prop)) {
                                triggerChange = true;
                            }
                        }
                    }
                    else {
                        if(target.__path) {
                            newPath = target.__path + '.';
                        }
                        newPath += prop;
                        if(!target.hasOwnProperty(prop)) {
                            triggerChange = true;
                        }
                    }
                }
                let result = Reflect.defineProperty(target, prop, descriptor);
                if(triggerChange) {
                    this.avoidUpdate.push(prop);
                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);
                    target[prop] = proxyEl;
                    trigger('CREATED', target, null, proxyEl, prop);
                }
                return result;
            },
            ownKeys(target) {
                let result = Reflect.ownKeys(target);
                for(let i = 0; i < result.length; i++) {
                    if(reservedName[result[i]]) {
                        result.splice(i, 1);
                        i--;
                    }
                }
                return result;
            },
        };

        if(onDataChanged) {
            proxyData.callbacks[''] = [onDataChanged];
        }
        const trigger = (type: 'CREATED' | 'UPDATED' | 'DELETED', target, receiver, value, prop, dones: any[] = []) => {
            if(target.__isProxy) {
                return;
            }
            let rootPath: string;
            if(receiver == null) {
                rootPath = target.__path;
            }
            else {
                rootPath = receiver.__path;
            }
            if(rootPath != "") {
                if(Array.isArray(target)) {
                    if(!prop.startsWith("[")) {
                        if(/^[0-9]*$/g.exec(prop)) {
                            rootPath += "[" + prop + "]";
                        }
                        else {
                            rootPath += "." + prop;
                        }
                    }
                    else {
                        rootPath += prop;
                    }
                }
                else {
                    if(!prop.startsWith("[")) {
                        rootPath += ".";
                    }
                    rootPath += prop;
                }
            }
            else {
                rootPath = prop;
            }

            let stacks: string[] = [];
            if(proxyData.useHistory) {
                let allStacks = new Error().stack?.split("\n") ?? [];
                for(let i = allStacks.length - 1; i >= 0; i--) {
                    let current = allStacks[i].trim().replace("at ", "");
                    if(current.startsWith("Object.set") || current.startsWith("Proxy.result")) {
                        break;
                    }
                    stacks.push(current);
                }
            }

            dones.push(proxyData.baseData);
            let aliasesDone: any[] = [];
            for(let name in proxyData.callbacks) {
                let pathToSend = rootPath;
                if(name !== "") {
                    let regex = new RegExp("^" + name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') + "(\\.|(\\[)|$)");
                    if(!regex.test(rootPath)) {
                        // it' s not a child but maybe the parent change
                        let regex2 = new RegExp("^" + rootPath.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') + "(\\.|(\\[)|$)");
                        if(!regex2.test(name)) {
                            continue;
                        }
                        else {
                            pathToSend = "";
                        }
                    }
                    else {
                        pathToSend = rootPath.replace(regex, "$2");
                    }
                }

                if(name === "" && proxyData.useHistory) {
                    proxyData.history.push({
                        object: JSON.parse(JSON.stringify(proxyData.baseData, jsonReplacer)),
                        trace: stacks.reverse(),
                        action: WatchAction[type],
                        path: pathToSend
                    });
                }

                let cbs = [...proxyData.callbacks[name]];
                for(let cb of cbs) {
                    try {
                        cb(WatchAction[type] as any, pathToSend, value);
                    } catch(e) {
                        if(e != 'impossible')
                            console.log(e);
                    }
                }

                // trigger aliases
                for(let [key, infos] of aliases) {
                    if(!dones.includes(key)) {
                        for(let info of infos) {
                            if(info.name == name) {
                                aliasesDone.push(key);
                                info.fct(type, target, receiver, value, prop, dones);
                            }
                        }
                    }
                }
            }

            // trigger aliases
            for(let [key, infos] of aliases) {
                if(!dones.includes(key) && !aliasesDone.includes(key)) {
                    for(let info of infos) {
                        let regex = new RegExp("^" + info.name.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') + "(\\.|(\\[)|$)");
                        if(!regex.test(rootPath)) {
                            continue;
                        }
                        let name = rootPath.replace(regex, "$2");
                        info.fct(type, target, receiver, value, name, dones);
                    }
                }
            }
        };

        var realProxy = new Proxy(obj, proxyData);
        proxyData.baseData = obj;
        setProxyPath(realProxy, '');
        return realProxy;
    }

    /**
     * Create a computed variable that will watch any changes
     */
    public static computed<T>(fct: () => NotVoid<T>): Computed<T> {
        const comp = new Computed<T>(fct);
        return comp;
    }
    /**
     * Create an effect variable that will watch any changes
     */
    public static effect(fct: () => void): Effect {
        const comp = new Effect(fct);
        return comp;
    }
}

export type WatcherChange = (action: WatchAction, changePath: string, value: any) => void;
export type EffectReceiver = {
    subscribe: (fct: WatcherChange) => void;
    unsubscribe: (fct: WatcherChange) => void;
    __path: string;
};
type WatcherAllowed = (action: WatchAction, path: string, value: any) => boolean;

/**
 * Effect will recomputed each time a watchable variable or effect or computed are changed
 * Each time the function is called, dependances tree is updated. It's usefull when you have array or conditional inside
 */
export class Effect {
    @InternalProtected()
    public callbacks: {
        receiver: EffectReceiver,
        path: string,
        registerPath: string;
        fullPath: string,
        cb: WatcherChange;
        version: number;
    }[] = [];

    @InternalProtected()
    public isInit: boolean = false;
    @InternalProtected()
    public isDestroy: boolean = false;
    protected __subscribes: WatcherChange[] = [];
    protected __allowChanged: WatcherAllowed[] = [];
    @InternalProtected()
    public version: number = 0;

    protected fct: () => void;

    public constructor(fct: () => void) {
        this.fct = fct;
        if(this.autoInit()) {
            this.init();
        }
    }

    protected autoInit(): boolean {
        return true;
    }

    protected init() {
        this.isInit = true;
        this.run();
    }

    protected run() {
        this.version++;
        Watcher._registering.push(this);
        let result = this.fct();
        Watcher._registering.splice(Watcher._registering.length - 1, 1);
        for(let i = 0; i < this.callbacks.length; i++) {
            if(this.callbacks[i].version != this.version) {
                this.callbacks[i].receiver.unsubscribe(this.callbacks[i].cb);
                this.callbacks.splice(i, 1);
                i--;
            }
        }
        return result;
    }

    @InternalProtected()
    public register(receiver: EffectReceiver, path: string, version: number, fullPath: string) {
        for(let info of this.callbacks) {
            if(info.receiver == receiver && info.path == path && receiver.__path == info.registerPath) {
                info.version = version;
                info.fullPath = fullPath;
                return;
            }
        }

        let cb: WatcherChange;
        if(path == "*") {
            cb = (action, changePath, value) => { this.onChange(action, changePath, value); };
        }
        else {
            cb = (action, changePath, value) => {
                let full = fullPath;
                if(changePath == path) {
                    this.onChange(action, changePath, value);
                }
            };
        }


        this.callbacks.push({
            receiver,
            path,
            registerPath: receiver.__path,
            cb,
            version,
            fullPath
        });
        receiver.subscribe(cb);
    }

    public canChange(fct: WatcherAllowed) {
        this.__allowChanged.push(fct);
    }

    protected checkCanChange(action: WatchAction, changePath: string, value: any): boolean {
        if(this.isDestroy) {
            return false;
        }
        for(let fct of this.__allowChanged) {
            if(!fct(action, changePath, value)) {
                return false;
            }
        }
        return true;
    }

    protected onChange(action: WatchAction, changePath: string, value: any) {
        if(!this.checkCanChange(action, changePath, value)) {
            return;
        }
        this.run();
        for(let fct of this.__subscribes) {
            fct(action, changePath, value);
        }
    }

    public destroy() {
        this.isDestroy = true;
        this.clearCallbacks();
        this.isInit = false;
    }

    protected clearCallbacks() {
        for(let pair of this.callbacks) {
            pair.receiver.unsubscribe(pair.cb);
        }
        this.callbacks = [];
    }


    public subscribe(fct: WatcherChange): void {
        let index = this.__subscribes.indexOf(fct);
        if(index == -1) {
            this.__subscribes.push(fct);
        }
    }

    public unsubscribe(fct: WatcherChange): void {
        let index = this.__subscribes.indexOf(fct);
        if(index > -1) {
            this.__subscribes.splice(index, 1);
        }
    }
}

/**
 * Effect will recomputed each time a watchable variable or effect or computed are changed
 * The dependances tree is created only during the first execution
 */
export class EffectNoRecomputed extends Effect {
    protected override init() {
        this.isInit = true;
        Watcher._registering.push(this);
        this.fct();
        Watcher._registering.splice(Watcher._registering.length - 1, 1);
    }

    protected override run() {
        if(!this.isInit) {
            this.init();
        }
    }
}

/**
 * Computed will recomputed each time a watchable variable or effect or computed are changed
 * When no change occured you can get the value by calling the value property
 * Each time the function is called, dependances tree is updated. It's usefull when you have array or conditional inside
 */
export class Computed<T = any> extends Effect {
    protected _value?: T;
    @Internal()
    public __path: string = "*";

    public get value(): T | undefined {
        if(!this.isInit) {
            this.init();
        }
        Watcher._register?.register(this, "*", Watcher._register.version, "*");
        return this._value;
    }

    protected override autoInit(): boolean {
        return false;
    }

    public constructor(fct: () => NotVoid<T>) {
        super(fct);
    }

    protected override init(): void {
        this.isInit = true;
        this.computedValue();
    }

    protected computedValue() {
        this._value = this.run() as T;
    }

    protected override onChange(action: WatchAction, changePath: string, value: any): void {
        if(!this.checkCanChange(action, changePath, value)) {
            return;
        }
        let oldValue = this._value;
        this.computedValue();
        if(oldValue === this._value) {
            return;
        }
        for(let fct of this.__subscribes) {
            fct(action, changePath, value);
        }
    }
}

/**
 * Computed will recomputed each time a watchable variable or effect or computed are changed
 * When no change occured you can get the value by calling the value property
 * The dependances tree is created only during the first execution
 */
export class ComputedNoRecomputed<T = any> extends Computed<T> {
    protected override init() {
        this.isInit = true;
        Watcher._registering.push(this);
        this._value = this.fct() as T;
        Watcher._registering.splice(Watcher._registering.length - 1, 1);
    }

    protected override computedValue() {
        if(this.isInit)
            this._value = this.fct() as T;
        else
            this.init();
    }

    protected override run() { }
}