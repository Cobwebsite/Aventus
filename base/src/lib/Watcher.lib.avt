import { compareObject } from "../tools/CompareObject.lib.avt";

type NotVoid<T> = T extends void ? never : T;
export type WatcherFunction = (action: WatchAction, path: string, value: any) => void;

export enum WatchAction {
    CREATED,
    UPDATED,
    DELETED
}

export class Watcher {
    private static __maxProxyData: number = 0;
    @Internal()
    public static _registering: Effect[] = [];
    @Internal()
    public static get _register(): Effect | undefined {
        return this._registering[this._registering.length - 1];
    }
    /**
     * Transform object into a watcher
     */
    public static get(obj: object, onDataChanged?: WatcherFunction): any {
        if(obj == undefined) {
            console.error("You must define an objet / array for your proxy");
            return;
        }
        if((obj as any).__isProxy) {
            if(onDataChanged)
                (obj as any).subscribe(onDataChanged);
            return obj;
        }
        Watcher.__maxProxyData++;
        const reservedName = {
            __path: '__path',
            __proxyData: '__proxyData',
        };
        const clearReservedNames = (data) => {
            if(data instanceof Object && !data.__isProxy) {
                for(let key in reservedName) {
                    delete data[key];
                }
            }
        };
        let setProxyPath = (newProxy, newPath) => {
            if(newProxy instanceof Object && newProxy.__isProxy) {
                newProxy.__path = newPath;
                if(!newProxy.__proxyData) {
                    newProxy.__proxyData = {};
                }
                if(!newProxy.__proxyData[newPath]) {
                    newProxy.__proxyData[newPath] = [];
                }
                if(newProxy.__proxyData[newPath].indexOf(proxyData) == -1) {
                    newProxy.__proxyData[newPath].push(proxyData);
                }
            }
        };
        let removeProxyPath = (oldValue, pathToDelete, recursive = true) => {
            if(oldValue instanceof Object && oldValue.__isProxy) {
                let allProxies = oldValue.__proxyData;
                for(let triggerPath in allProxies) {
                    if(triggerPath == pathToDelete) {
                        for(let i = 0; i < allProxies[triggerPath].length; i++) {
                            if(allProxies[triggerPath][i] == proxyData) {
                                allProxies[triggerPath].splice(i, 1);
                                i--;
                            }
                        }
                        if(allProxies[triggerPath].length == 0) {
                            delete allProxies[triggerPath];
                            if(Object.keys(allProxies).length == 0) {
                                delete oldValue.__proxyData;
                            }
                        }
                    }
                }
            }
        };
        let jsonReplacer = (key, value) => {
            if(reservedName[key]) return undefined;
            return value;
        };
        let currentTrace = new Error().stack?.split("\n") ?? [];
        currentTrace.shift();
        currentTrace.shift();
        let onlyDuringInit = true;

        type ProxyData = {
            baseData: any,
            id: number,
            callbacks: WatcherFunction[],
            avoidUpdate: string[],
            pathToRemove: string[],
            history: any[],
            useHistory: boolean,
            getProxyObject: (target: any, element: any, prop: string) => any,
            tryCustomFunction: (target: any, prop: string, receiver: any) => any,
            get: (target: any, prop: string, receiver: any) => any,
            set: (target: any, prop: string, value: any, receiver: any) => any,
            deleteProperty: (target: any, prop: string) => boolean,
            defineProperty: (target: any, prop: string, descriptor: any) => boolean,
            ownKeys: (target: any) => (string | symbol)[],
        };
        let proxyData: ProxyData = {
            baseData: {},
            id: Watcher.__maxProxyData,
            callbacks: [],
            avoidUpdate: [],
            pathToRemove: [],
            history: [{
                object: JSON.parse(JSON.stringify(obj, jsonReplacer)),
                trace: currentTrace,
                action: 'init',
                path: ''
            }],
            useHistory: false,
            getProxyObject(target, element, prop) {
                let newProxy;
                if(element instanceof Object && element.__isProxy) {
                    newProxy = element;
                }
                else {
                    try {
                        if(element instanceof Computed) {
                            return element;
                        }
                        if(element instanceof Object) {
                            newProxy = new Proxy(element, this);
                        } else {
                            return element;
                        }
                    } catch {
                        // it's not an array or object
                        return element;
                    }
                }
                let newPath = '';
                if (Array.isArray(target)) {
                    if (/^[0-9]*$/g.exec(prop)) {
                        if ((target as any).__path) {
                            newPath = (target as any).__path;
                        }
                        newPath += "[" + prop + "]";
                        setProxyPath(newProxy, newPath);
                    }
                    else {
                        newPath += "." + prop;
                    }
                }
                else if(element instanceof Date) {
                    return element;
                }
                else {
                    if(target.__path) {
                        newPath = target.__path + '.';
                    }
                    newPath += prop;
                    setProxyPath(newProxy, newPath);
                }
                return newProxy;

            },
            tryCustomFunction(target, prop, receiver) {
                if(prop == "__isProxy") {
                    return true;
                }
                else if(prop == "subscribe") {
                    return (cb) => {
                        this.callbacks.push(cb);
                    };
                }
                else if(prop == "unsubscribe") {
                    return (cb) => {
                        let index = this.callbacks.indexOf(cb);
                        if(index > -1) {
                            this.callbacks.splice(index, 1);
                        }
                    };
                }
                else if(prop == "__proxyId") {
                    return this.id;
                }
                else if(prop == "getHistory") {
                    return () => {
                        return this.history;
                    };
                }
                else if(prop == "clearHistory") {
                    this.history = [];
                }
                else if(prop == "enableHistory") {
                    return () => {
                        this.useHistory = true;
                    };
                }
                else if(prop == "disableHistory") {
                    return () => {
                        this.useHistory = false;
                    };
                }
                else if(prop == "__getTarget" && onlyDuringInit) {
                    return () => {
                        return target;
                    };
                }
                else if(prop == "toJSON") {
                    if(Array.isArray(target)) {
                        return () => {
                            let result: any[] = [];
                            for(let element of target) {
                                result.push(element);
                            }
                            return result;
                        };
                    }
                    return () => {
                        let result = {};
                        for(let key of Object.keys(target)) {
                            if(reservedName[key]) {
                                continue;
                            }
                            result[key] = target[key];
                        }
                        return result;
                    };
                }
                return undefined;
            },
            get(target, prop, receiver) {
                if(reservedName[prop]) {
                    return target[prop];
                }

                let customResult = this.tryCustomFunction(target, prop, receiver);
                if(customResult !== undefined) {
                    return customResult;
                }

                let element = target[prop];
                if(typeof (element) == 'function') {
                    if(Array.isArray(target)) {
                        let result;
                        if(prop == 'push') {
                            if((target as any).__isProxy) {
                                result = (el) => {
                                    let index = target.push(el);
                                    return index;
                                };
                            }
                            else {
                                result = (el) => {
                                    let index = target.push(el);
                                    // get real objetct with proxy to have the correct subscription
                                    let proxyEl = this.getProxyObject(target, el, (index - 1));
                                    target.splice(target.length - 1, 1, proxyEl);
                                    trigger('CREATED', target, receiver, proxyEl, "[" + (index - 1) + "]");
                                    trigger('UPDATED', target, receiver, target.length, "length");
                                    return index;
                                };
                            }
                        }
                        else if(prop == 'splice') {
                            if((target as any).__isProxy) {
                                result = (index, nbRemove, ...insert) => {
                                    let res = target.splice(index, nbRemove, ...insert);
                                    return res;
                                };
                            }
                            else {
                                result = (index, nbRemove, ...insert) => {
                                    let oldValues: any[] = [];
                                    for (let i = index; i < index + nbRemove; i++) {
                                        oldValues.push(receiver[i]);
                                    }
                                    let updateLength = nbRemove != insert.length;
                                    let res = target.splice(index, nbRemove, ...insert);
                                    let path = (target as any).__path ? (target as any).__path : '';
                                    for (let i = 0; i < oldValues.length; i++) {
                                        removeProxyPath(oldValues[i], path + "[" + (index + i) + "]");
                                        trigger('DELETED', target, receiver, oldValues[i], "[" + index + "]");
                                    }
                                    for (let i = 0; i < insert.length; i++) {
                                        // get real objetct with proxy to have the correct subscription
                                        let proxyEl = this.getProxyObject(target, insert[i], (index + i));
                                        target.splice((index + i), 1, proxyEl);
                                        trigger('CREATED', target, receiver, proxyEl, "[" + (index + i) + "]");
                                    }
                                    let fromIndex = index + insert.length;
                                    let baseDiff = index - insert.length + res.length + 1;
                                    // update path and subscription
                                    for (let i = fromIndex, j = 0; i < target.length; i++, j++) {
                                        let oldPath = path + "[" + (j + baseDiff) + "]";
                                        removeProxyPath(target[i], oldPath, false);
                                        let proxyEl = this.getProxyObject(target, target[i], i);

                                        let recuUpdate = (childEl) => {
                                            if (Array.isArray(childEl)) {
                                                for (let i = 0; i < childEl.length; i++) {
                                                    if (childEl[i] instanceof Object && childEl[i].__path) {
                                                        let oldPathRecu = proxyEl[i].__path.replace(proxyEl.__path, oldPath);
                                                        removeProxyPath(childEl[i], oldPathRecu, false);
                                                        let newProxyEl = this.getProxyObject(childEl, childEl[i], i);
                                                        recuUpdate(newProxyEl);
                                                    }
                                                }
                                            }
                                            else if (childEl instanceof Object && !(childEl instanceof Date)) {
                                                for (let key in childEl) {
                                                    if (childEl[key] instanceof Object && childEl[key].__path) {
                                                        let oldPathRecu = proxyEl[key].__path.replace(proxyEl.__path, oldPath);
                                                        removeProxyPath(childEl[key], oldPathRecu, false);
                                                        let newProxyEl = this.getProxyObject(childEl, childEl[key], key);
                                                        recuUpdate(newProxyEl);
                                                    }
                                                }
                                            }
                                        };
                                        recuUpdate(proxyEl);
                                    }
                                    if (updateLength)
                                        trigger('UPDATED', target, receiver, target.length, "length");
                                    return res;
                                };
                            }

                        }
                        else if(prop == 'pop') {
                            if((target as any).__isProxy) {
                                result = () => {
                                    let res = target.pop();
                                    return res;
                                };
                            }
                            else {
                                result = () => {
                                    let index = target.length - 1;
                                    let oldValue = receiver.length ? receiver[receiver.length] : undefined;
                                    let res = target.pop();
                                    let path = (target as any).__path ? (target as any).__path : '';
                                    removeProxyPath(oldValue, path + "[" + index + "]");
                                    trigger('DELETED', target, receiver, oldValue, "[" + index + "]");
                                    trigger('UPDATED', target, receiver, target.length, "length");
                                    return res;
                                };
                            }
                        }
                        else {
                            result = element.bind(target);
                        }
                        return result;
                    }
                    return element.bind(target);
                }

                if(element instanceof Computed) {
                    return element.value;
                }
                
                if (Watcher._registering.length > 0) {
                    let currentPath: string;
                    let isArray = Array.isArray(receiver);
                    if (isArray && /^[0-9]*$/g.exec(prop)) {
                        currentPath = receiver.__path + "[" + prop + "]";
                    }
                    else {
                        currentPath = receiver.__path ? receiver.__path + '.' + prop : prop
                    }
                    Watcher._register?.register(receiver, currentPath);
                }

                if (typeof (element) == 'object') {
                    return this.getProxyObject(target, element, prop);
                }

                return Reflect.get(target, prop, receiver);
            },
            set(target, prop, value, receiver) {
                let triggerChange = false;
                if(!reservedName[prop]) {
                    if(Array.isArray(target)) {
                        if(prop != "length") {
                            triggerChange = true;
                        }
                    }
                    else {
                        let oldValue = Reflect.get(target, prop, receiver);
                        if(!compareObject(value, oldValue)) {
                            triggerChange = true;
                        }
                    }
                }
                let result = Reflect.set(target, prop, value, receiver);
                if(triggerChange) {
                    let index = this.avoidUpdate.indexOf(prop);

                    if(index == -1) {
                        trigger('UPDATED', target, receiver, value, prop);
                    }
                    else {
                        this.avoidUpdate.splice(index, 1);
                    }
                }
                return result;
            },
            deleteProperty(target, prop) {
                let triggerChange = false;
                let pathToDelete = '';
                if(!reservedName[prop]) {
                    if(Array.isArray(target)) {
                        if(prop != "length") {
                            if((target as any).__path) {
                                pathToDelete = (target as any).__path;
                            }
                            pathToDelete += "[" + prop + "]";
                            triggerChange = true;
                        }
                    }
                    else {
                        if(target.__path) {
                            pathToDelete = target.__path + '.';
                        }
                        pathToDelete += prop;
                        triggerChange = true;
                    }
                }
                if(target.hasOwnProperty(prop)) {
                    let oldValue = target[prop];
                    if(oldValue instanceof Effect) {
                        oldValue.destroy();
                    }
                    delete target[prop];
                    if(triggerChange) {
                        clearReservedNames(oldValue);
                        removeProxyPath(oldValue, pathToDelete);
                        trigger('DELETED', target, null, oldValue, prop);
                    }
                    return true;
                }
                return false;
            },
            defineProperty(target, prop, descriptor) {
                let triggerChange = false;
                let newPath = '';
                if(!reservedName[prop]) {
                    if(Array.isArray(target)) {
                        if(prop != "length") {
                            if((target as any).__path) {
                                newPath = (target as any).__path;
                            }
                            newPath += "[" + prop + "]";
                            if(!target.hasOwnProperty(prop)) {
                                triggerChange = true;
                            }
                        }
                    }
                    else {
                        if(target.__path) {
                            newPath = target.__path + '.';
                        }
                        newPath += prop;
                        if(!target.hasOwnProperty(prop)) {
                            triggerChange = true;
                        }
                    }
                }
                let result = Reflect.defineProperty(target, prop, descriptor);
                if(triggerChange) {
                    this.avoidUpdate.push(prop);
                    let proxyEl = this.getProxyObject(target, descriptor.value, prop);
                    target[prop] = proxyEl;
                    trigger('CREATED', target, null, proxyEl, prop);
                }
                return result;
            },
            ownKeys(target) {
                let result = Reflect.ownKeys(target);
                for(let i = 0; i < result.length; i++) {
                    if(reservedName[result[i]]) {
                        result.splice(i, 1);
                        i--;
                    }
                }
                return result;
            },
        };

        if(onDataChanged) {
            proxyData.callbacks.push(onDataChanged);
        }
        const trigger = (type, target, receiver, value, prop) => {

            if(target.__isProxy) {
                return;
            }
            let allProxies = target.__proxyData;
            // trigger only if same id
            let receiverId = 0;
            if(receiver == null) {
                receiverId = proxyData.id;
            }
            else {
                receiverId = receiver.__proxyId;
            }
            if(proxyData.id == receiverId) {
                let stacks: string[] = [];
                if(proxyData.useHistory) {
                    let allStacks = new Error().stack?.split("\n") ?? [];
                    for(let i = allStacks.length - 1; i >= 0; i--) {
                        let current = allStacks[i].trim().replace("at ", "");
                        if(current.startsWith("Object.set") || current.startsWith("Proxy.result")) {
                            break;
                        }
                        stacks.push(current);
                    }
                }


                for(let triggerPath in allProxies) {
                    for(let currentProxyData of allProxies[triggerPath]) {

                        let pathToSend = triggerPath;
                        if (pathToSend != "") {
                            if (Array.isArray(target)) {
                                if (!prop.startsWith("[")) {
                                    if (/^[0-9]*$/g.exec(prop)) {
                                        pathToSend += "[" + prop + "]";
                                    }
                                    else {
                                        pathToSend += "." + prop
                                    }
                                }
                                else {
                                    pathToSend += prop;
                                }
                            }
                            else {
                                if (!prop.startsWith("[")) {
                                    pathToSend += ".";
                                }
                                pathToSend += prop;
                            }
                        }
                        else {
                            pathToSend = prop;
                        }

                        if(proxyData.useHistory) {
                            proxyData.history.push({
                                object: JSON.parse(JSON.stringify(currentProxyData.baseData, jsonReplacer)),
                                trace: stacks.reverse(),
                                action: WatchAction[type],
                                path: pathToSend
                            });
                        }

                        const cbs = [...currentProxyData.callbacks];
                        for(let cb of cbs) {
                            cb(WatchAction[type], pathToSend, value);
                        }
                    }

                }
            }
        };


        var realProxy = new Proxy(obj, proxyData);
        proxyData.baseData = realProxy.__getTarget();
        onlyDuringInit = false;
        setProxyPath(realProxy, '');
        return realProxy;
    }

    public static computed<T>(fct: () => NotVoid<T>) {
        const comp = new Computed<T>(fct);
        return comp;
    }
    public static effect(fct: () => void) {
        const comp = new Effect(fct);
        return comp;
    }
}

export type WatcherChange = (action: WatchAction, changePath: string, value: any) => void;
export type EffectReceiver = {
    subscribe: (fct: WatcherChange) => void;
    unsubscribe: (fct: WatcherChange) => void;
};
type WatcherAllowed = (action: WatchAction, path: string, value: any) => boolean;

export class Effect {
    @InternalProtected()
    public callbacks: {
        receiver: EffectReceiver,
        path: string,
        cb: WatcherChange;
    }[] = [];

    protected isInit: boolean = false;
    protected isDestroy: boolean = false;
    protected __subscribes: WatcherChange[] = [];
    protected __allowChanged: WatcherAllowed[] = [];

    protected fct: () => void;

    public constructor(fct: () => void) {
        this.fct = fct;
        if(this.autoInit()) {
            this.init();
        }
    }

    protected autoInit(): boolean {
        return true;
    }

    protected init() {
        this.isInit = true;
        Watcher._registering.push(this);
        this.fct();
        Watcher._registering.splice(Watcher._registering.length - 1, 1);
    }

    @InternalProtected()
    public register(receiver: EffectReceiver, path: string) {
        let cb: WatcherChange;
        if (path == "*") {
            cb = (action, changePath, value) => { this.onChange(action, changePath, value) }
        }
        else {
            cb = (action, changePath, value) => {
                if (changePath == path) {
                    this.onChange(action, changePath, value);
                }
            };
        }

        for(let info of this.callbacks) {
            if(info.receiver == receiver && info.path == path) {
                return;
            }
        }
        this.callbacks.push({
            receiver,
            path,
            cb
        });
        receiver.subscribe(cb);
    }

    public canChange(fct: WatcherAllowed) {
        this.__allowChanged.push(fct);
    }

    protected checkCanChange(action: WatchAction, changePath: string, value: any): boolean {
        if (this.isDestroy) {
            return false;
        }
        for(let fct of this.__allowChanged) {
            if(!fct(action, changePath, value)) {
                return false;
            }
        }
        return true;
    }

    protected onChange(action: WatchAction, changePath: string, value: any) {
        if(!this.checkCanChange(action, changePath, value)) {
            return;
        }
        this.fct();
        for(let fct of this.__subscribes) {
            fct(action, changePath, value);
        }
    }

    public destroy() {
        this.isDestroy = true;
        for(let pair of this.callbacks) {
            pair.receiver.unsubscribe(pair.cb);
        }
        this.callbacks = [];
        this.isInit = false;
    }


    public subscribe(fct: WatcherChange): void {
        let index = this.__subscribes.indexOf(fct);
        if(index == -1) {
            this.__subscribes.push(fct);
        }
    }

    public unsubscribe(fct: WatcherChange): void {
        let index = this.__subscribes.indexOf(fct);
        if(index > -1) {
            this.__subscribes.splice(index, 1);
        }
    }
}

export class Computed<T = any> extends Effect {
    private _value?: T;

    public get value(): T | undefined {
        if(!this.isInit) {
            this.init();
        }
        Watcher._register?.register(this, "*");
        return this._value;
    }

    protected override autoInit(): boolean {
        return false;
    }

    public constructor(fct: () => NotVoid<T>) {
        super(fct);
    }

    protected override init(): void {
        this.isInit = true;
        Watcher._registering.push(this);
        this._value = this.fct() as T;
        Watcher._registering.splice(Watcher._registering.length - 1, 1);
    }


    protected override onChange(action: WatchAction, changePath: string, value: any): void {
        if(!this.checkCanChange(action, changePath, value)) {
            return;
        }
        let oldValue = this._value;
        this._value = this.fct() as T;
        if(oldValue === this._value) {
            return;
        }
        for(let fct of this.__subscribes) {
            fct(action, changePath, value);
        }
    }
}