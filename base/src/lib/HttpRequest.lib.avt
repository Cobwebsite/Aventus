/**
 * List of HTTP Method allowed
 */
export enum HttpRequestMethod {
    GET,
    POST,
    DELETE,
    PUT,
    OPTION
}
export interface HttpRequestOptions {
    url: string;
    method?: HttpRequestMethod,
    data?: { [key: string]: any; } | FormData;
    useJSON?: boolean;
}
export class DefaultHttpRequestOptions implements HttpRequestOptions {
    /** The url to use */
    public url: string = "";
    /** The method get */
    public method: HttpRequestMethod = HttpRequestMethod.GET;
    /** The method use json */
    public  useJSON: boolean = false;
}


export class HttpRequest {
    private options: RequestInit = {};
    private url: string = '';
    /**
     * Get the right http method inside enum
     */
    public static getMethod(method: string): HttpRequestMethod {
        let genericMethod = method.toLowerCase().trim();
        if(genericMethod == "get") {
            return HttpRequestMethod.GET;
        }
        if(genericMethod == "post") {
            return HttpRequestMethod.POST;
        }
        if(genericMethod == "delete") {
            return HttpRequestMethod.DELETE;
        }
        if(genericMethod == "put") {
            return HttpRequestMethod.PUT;
        }
        if(genericMethod == "option") {
            return HttpRequestMethod.OPTION;
        }
        console.error("unknow type " + method + ". I ll return GET by default");
        return HttpRequestMethod.GET;
    }

    /**
     * Get http method in string
     */
    private getMethod(method: HttpRequestMethod): string {
        if(method == HttpRequestMethod.GET) return "GET";
        if(method == HttpRequestMethod.POST) return "POST";
        if(method == HttpRequestMethod.DELETE) return "DELETE";
        if(method == HttpRequestMethod.OPTION) return "OPTION";
        if(method == HttpRequestMethod.PUT) return "PUT";
        return "GET";
    }

    constructor(options: HttpRequestOptions) {
        options = {
            ...new DefaultHttpRequestOptions(),
            ...options
        };

        let optionsToSend: RequestInit = {
            method: this.getMethod(options.method),
        };
        if(options.data) {
            if(!options.useJSON) {
                if(options.data instanceof FormData) {
                    optionsToSend.body = options.data;
                }
                else {
                    let formData = new FormData();
                    this.recuFillFormData(options.data, "", formData);
                    optionsToSend.body = formData;
                }
            }
            else {
                optionsToSend.body = JSON.stringify(options.data);
                optionsToSend.headers = {};
                optionsToSend.headers['Content-Type'] = "application/json";
            }
        }

        this.options = optionsToSend;
        this.url = options.url;
    }

    private recuFillFormData(data: any, key: string, form: FormData): void {
        if(typeof data === 'object' && data !== null) {
            if(Array.isArray(data)) {
                for(let i = 0; i < data.length; i++) {
                    this.recuFillFormData(data[i], key + '[' + i + ']', form);
                }
            }
            else if(data instanceof Date) {
                form.append(key, data.toISOString());
            }
            else {
                let props = Object.getOwnPropertyNames(data);
                for(let prop of props) {
                    let newKey = key === "" ? prop : key + '.' + prop;
                    this.recuFillFormData(data[prop], newKey, form);
                }
            }
        }
        else {
            form.append(key, data);
        }
    }

    /**
     * Send the http request
     */
    public async send(): Promise<Response> {
        let result = await fetch(this.url, this.options);
        return result;
    }

    /**
     * Send a get request
     */
    public static async get(url: string): Promise<Response> {
        return await fetch(url, {
            method: "GET"
        });
    }
    /**
     * Send a post request and wait a result in JSON format
     */
    public static async post<T>(url: string, data: {}): Promise<T> {
        let formData = new FormData();
        for(let key in data) {
            formData.append(key, data[key]);
        }

        const response = await fetch(url, {
            method: "POST",
            body: formData
        });

        const content = await response.json();
        return new Promise((resolve, reject) => {
            if(response.ok) {
                resolve(content);
            }
            else {
                reject(content);
            }
        });
    }

}