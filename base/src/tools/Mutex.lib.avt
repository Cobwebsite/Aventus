export class Mutex {
    private waitingList: ((run: boolean) => void)[] = [];
    private isLocked: boolean = false;
    /**
     * Wait the mutex to be free then get it
     */
    public waitOne() {
        return new Promise<boolean>((resolve) => {
            if(this.isLocked) {
                this.waitingList.push((run: boolean) => {
                    resolve(run);
                });
            }
            else {
                this.isLocked = true;
                resolve(true);
            }
        });
    }
    /**
     * Release the mutex
     */
    public release() {
        let nextFct = this.waitingList.shift();
        if(nextFct) {
            nextFct(true);
        }
        else {
            this.isLocked = false;
        }
    }

    /**
     * Release the mutex
     */
    public releaseOnlyLast() {
        if(this.waitingList.length > 0) {
            let lastFct = this.waitingList.pop();
            for(let fct of this.waitingList) {
                fct(false);
            }
            this.waitingList = [];
            if(lastFct) {
                lastFct(true);
            }
        }
        else {
            this.isLocked = false;
        }
    }

    /**
     * Clear mutex
     */
    public dispose() {
        this.waitingList = [];
        this.isLocked = false;
    }

    public async safeRun<T = void>(cb: () => T): Promise<T | null> {
        let result: T | null = null;
        await this.waitOne();
        try {
            result = cb.apply(null, []);
        }
        catch(e) {

        }
        await this.release();
        return result;
    }

    public async safeRunAsync<T = void>(cb: () => Promise<T>): Promise<T | null> {
        let result: T | null = null;
        await this.waitOne();
        try {
            result = await cb.apply(null, []);
        }
        catch(e) {

        }
        await this.release();
        return result;
    }

    public async safeRunLast<T = void>(cb: () => T): Promise<T | null> {
        let result: T | null = null;
        if(await this.waitOne()) {
            try {
                result = cb.apply(null, []);
            }
            catch(e) {

            }
            await this.releaseOnlyLast();
        }
        return result;
    }
    public async safeRunLastAsync<T = void>(cb: () => Promise<T>): Promise<T | undefined> {
        let result: T | undefined;
        if(await this.waitOne()) {
            try {
                result = await cb.apply(null, []);
            }
            catch(e) {

            }
            await this.releaseOnlyLast();
        }
        return result;
    }
}


/**
 * Class that manages unique execution of asynchronous actions based on specified keys.
 */
export class ActionGuard {
    /**
     * Map to store actions that are currently running.
     * @type {Map<any[], ((res: any) => void)[]>}
     * @private
     */
    private runningAction: Map<any[], ((res: any) => void)[]> = new Map();

    /**
     * Executes an action uniquely based on the specified keys.
     * @template T
     * @param {any[]} keys - The keys associated with the action.
     * @param {() => Promise<T>} action - The action to execute.
     * @returns {Promise<T>} A promise that resolves with the result of the action.
     * @example
     * // Example usage:
     * // Create an instance of ActionGuard
     * const actionGuard = new Aventus.ActionGuard();
     * 
     * // Define keys for the action
     * const keys = ["key1", "key2"];
     * 
     * // Define the action to execute
     * const action = async () => {
     *     // Simulate an asynchronous operation
     *     await new Promise(resolve => setTimeout(resolve, 1000));
     *     return "Action executed";
     * };
     * 
     * // Execute the action using ActionGuard
     * await actionGuard.run(keys, action)
     *
     */
    public run<T>(keys: any[], action: () => Promise<T>): Promise<T> {
        return new Promise<T>(async (resolve) => {
            // Retrieve actions associated with the keys
            let actions = this.runningAction.get(keys);
            if(actions) {
                // If actions already exist, add the promise resolution to the actions list
                actions.push((res: T) => {
                    resolve(res);
                });
            }
            else {
                // If no action exists for the specified keys, initialize a new actions list
                this.runningAction.set(keys, []);
                // Execute the specified action
                let res = await action();
                // Retrieve actions associated with the keys again
                let actions = this.runningAction.get(keys);
                if(actions) {
                    // Execute all registered actions with the result of the action
                    for(let action of actions) {
                        action(res);
                    }
                }
                // Delete actions once they've all been executed
                this.runningAction.delete(keys);
                // Resolve the promise with the final result of the action
                resolve(res);
            }
        });
    }
}