import type { Enum, EnumValue } from "./Enum.lib.avt";

export class GenericError<T extends (number | Enum) = any> {
    /**
     * Code for the error
     */
    public code: EnumValue<T>;
    /**
     * Description of the error
     */
    public message: string;

    public details: any[] = [];

    public constructor(code: EnumValue<T>, message: string) {
        this.code = code;
        this.message = message;
    }
}

export class VoidWithError<T extends GenericError = GenericError> {

    /**
     * Determine if the action is a success
     */
    public get success(): boolean {
        return this.errors.length == 0;
    }
    /**
     * List of errors
     */
    public errors: T[] = [];


    public toGeneric(): VoidWithError {
        const result = new VoidWithError();
        result.errors = this.errors;
        return result;
    }

    public containsCode<U extends GenericError<any>, T extends (number | Enum)>(code: EnumValue<T>, type?: new (...args) => U): boolean {
        if(type) {
            for(let error of this.errors) {
                if(error instanceof type) {
                    if(error.code == code) {
                        return true;
                    }
                }
            }
        }
        else {
            for(let error of this.errors) {
                if(error.code == code) {
                    return true;
                }
            }
        }
        return false;
    }
}
export class ResultWithError<U, T extends GenericError = GenericError> extends VoidWithError<T> {

    /**
     * Result
     */
    public result: U | undefined;

    public override toGeneric(): ResultWithError<U> {
        const result: ResultWithError<U> = new ResultWithError();
        result.errors = this.errors;
        result.result = this.result;
        return result;
    }
}
