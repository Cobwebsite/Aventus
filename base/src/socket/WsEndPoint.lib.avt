import { WsRoute } from "./WsRoute.lib.avt";
import { SocketOptions } from "./ISocket.lib.avt";
import { Socket } from "./Socket.lib.avt";
import { WsEvent } from "./WsEvent.lib.avt";
import { MergeWsEventsType, MergeWsRoutesType, WsEventType, WsRouteType } from "./type.lib.avt";
import { MixProto } from "../tools/MergePrototype.lib.avt";

export abstract class WsEndPoint extends Socket {


    public static With<const T extends { routes: readonly { type: WsRouteType, path: string; }[], events: readonly { type: WsEventType, path: string; }[]; }>(options: T) {
        abstract class EndPoint extends WsEndPoint {
            constructor() {
                super();
                for(let route of options.routes) {
                    if(typeof route == "function") {
                        this._routes.addRoute(route);
                    }
                    else {
                        this._routes.addRoute(route.type, route.path);
                    }
                }
                for(let _event of options.events) {
                    if(typeof _event == "function") {
                        this._events.addEvent(_event);
                    }
                    else {
                        this._events.addEvent(_event.type, _event.path);
                    }
                }
            }
        }
        return EndPoint as MixProto<MixProto<typeof WsEndPoint, MergeWsRoutesType<T['routes']>, "routes">, MergeWsEventsType<T['events']>, "events">;
    }


    private _routes: any;
    private _events: any;

    public constructor() {
        super();
        Object.defineProperty(this, "routes", {
            get: () => { return this._routes; }
        });
        Object.defineProperty(this, "events", {
            get: () => { return this._events; }
        });
        this.createProxy();
    }


    private createProxy() {
        if(!this._routes) {
            let that = this;
            let proxyData = {
                routePath: {},
                get(target, prop, receiver) {
                    if(prop == "addRoute") {
                        return (routeClass: new (...args: any[]) => WsRoute, path) => {
                            try {
                                if(!path) {
                                    path = "";
                                }
                                let splitted = path.split(".");
                                let current = this.routePath;
                                for(let part of splitted) {
                                    if(part != "") {
                                        if(!current[part]) {
                                            current[part] = {};
                                        }
                                        current = current[part];
                                    }
                                }
                                let routeInstance = new routeClass(that);
                                let keyFromChild: string[] = [];
                                while(routeClass.prototype) {
                                    let keys = Object.getOwnPropertyNames(routeClass.prototype);
                                    for(let key of keys) {
                                        if(key != "constructor" && !keyFromChild.includes(key)) {
                                            keyFromChild.push(key);
                                            current[key] = routeInstance[key].bind(routeInstance);
                                        }
                                    }
                                    routeClass = Object.getPrototypeOf(routeClass);
                                }
                            } catch(e) {
                                console.error(e);
                            }
                        };
                    }
                    else if(prop == "allRoutes") {
                        return (flat) => {
                            if(!flat) {
                                return this.routePath;
                            }
                            else {
                                let result = {};
                                let load = (current, pathes: string[]) => {
                                    for(let key in current) {
                                        pathes.push(key);
                                        if(typeof current[key] == "function") {
                                            result[pathes.join(".")] = current[key];
                                        }
                                        else {
                                            load(current[key], pathes);
                                        }
                                        pathes.pop();
                                    }
                                };
                                load(this.routePath, []);
                                return result;
                            }
                        };
                    }
                    else if(this.routePath[prop]) {
                        return this.routePath[prop];
                    }
                    return null;
                }
            };
            this._routes = new Proxy({}, proxyData);
        }

        if(!this._events) {
            let that = this;
            let proxyData = {
                eventPath: {},
                get(target, prop, receiver) {
                    if(prop == "addEvent") {
                        return (eventClass: new (...args: any[]) => WsEvent, path) => {
                            try {
                                if(!path) {
                                    path = "";
                                }
                                let splitted = path.split(".");
                                let current = this.eventPath;
                                for(let part of splitted) {
                                    if(part != "") {
                                        if(!current[part]) {
                                            current[part] = {};
                                        }
                                        current = current[part];
                                    }
                                }
                                let routeInstance = new eventClass(that);
                                routeInstance['configure']();
                                let keyFromChild: string[] = [];
                                while(eventClass.prototype) {
                                    let keys = Object.getOwnPropertyNames(eventClass.prototype);
                                    for(let key of keys) {
                                        if(key != "constructor" && !keyFromChild.includes(key)) {
                                            keyFromChild.push(key);
                                            current[key] = routeInstance[key].bind(routeInstance);
                                        }
                                    }
                                    eventClass = Object.getPrototypeOf(eventClass);
                                }
                            } catch(e) {
                                console.error(e);
                            }
                        };
                    }
                    else if(prop == "allEvents") {
                        return (flat) => {
                            if(!flat) {
                                return this.eventPath;
                            }
                            else {
                                let result = {};
                                let load = (current, pathes: string[]) => {
                                    for(let key in current) {
                                        pathes.push(key);
                                        if(typeof current[key] == "function") {
                                            result[pathes.join(".")] = current[key];
                                        }
                                        else {
                                            load(current[key], pathes);
                                        }
                                        pathes.pop();
                                    }
                                };
                                load(this.eventPath, []);
                                return result;
                            }
                        };
                    }
                    else if(this.eventPath[prop]) {
                        return this.eventPath[prop];
                    }
                    return null;
                }
            };
            this._events = new Proxy({}, proxyData);
        }
    }

    /**
     * @inheritdoc
     */
    protected override configure(options: SocketOptions): SocketOptions {
        options.socketName = this.path;

        return options;
    }

    protected abstract get path(): string;

}